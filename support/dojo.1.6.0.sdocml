<?xml version="1.0"?>
<!-- Aptana Studio support for the Dojo 1.6.0 JavaScript Libary -->
<javascript>
  <class type="dijit">
    <methods>
      <method name="_underlay" scope="instance">
        <description>A shared instance of a `dijit.DialogUnderlay` created and
	used by `dijit.Dialog`, though never created until some Dialog
	or subclass thereof is shown.</description>
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showTooltip" scope="instance">
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="position" type="String[]" usage="optional"/>
          <parameter name="rtl" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="hideTooltip" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectOnUseEventHandler" scope="instance">
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="isCollapsed" scope="instance"/>
      <method name="getBookmark" scope="instance">
        <return-types>
          <return-type type="Object."/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="moveToBookmark" scope="instance">
        <parameters>
          <parameter name="bookmark" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFocus" scope="instance">
        <parameters>
          <parameter name="menu" type="Widget" usage="optional"/>
          <parameter name="openedForWindow" type="Window" usage="optional"/>
        </parameters>
        <return-description>A handle to restore focus/selection, to be passed to `dijit.focus`</return-description>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerIframe" scope="instance">
        <description>Currently only used by editor.</description>
        <parameters>
          <parameter name="iframe" type="DomNode" usage="required"/>
        </parameters>
        <return-description>Handle to pass to unregisterIframe()</return-description>
      </method>
      <method name="unregisterIframe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerWin" scope="instance">
        <description>Users should call registerIframe() instead of this method.</description>
        <parameters>
          <parameter name="targetWindow" type="Window" usage="optional"/>
          <parameter name="effectiveNode" type="DomNode" usage="optional"/>
        </parameters>
        <return-description>Handle to pass to unregisterWin()</return-description>
      </method>
      <method name="unregisterWin" scope="instance">
        <parameters>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlurNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onTouchNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setStack" scope="instance">
        <parameters>
          <parameter name="newStack" type="String[]" usage="required"/>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="String|dijit._Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getUniqueId" scope="instance">
        <parameters>
          <parameter name="widgetType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="findWidgets" scope="instance">
        <parameters>
          <parameter name="root" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyAll" scope="instance"/>
      <method name="byNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getEnclosingWidget" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_isElementShown" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="hasDefaultTabStop" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="isTabNavigable" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_getTabNavigable" scope="instance">
        <description>Finds the following descendants of the specified root node:
	* the first tab-navigable element in document order
	without a tabIndex or with tabIndex="0"
	* the last tab-navigable element in document order
	without a tabIndex or with tabIndex="0"
	* the first element in document order with the lowest
	positive tabIndex value
	* the last element in document order with the highest
	positive tabIndex value</description>
        <parameters>
          <parameter name="root" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstInTabbingOrder" scope="instance">
        <parameters>
          <parameter name="root" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getLastInTabbingOrder" scope="instance">
        <parameters>
          <parameter name="root" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getViewport" scope="instance"/>
      <method name="placeOnScreen" scope="instance">
        <description>NOTE: node is assumed to be absolutely or relatively positioned.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="dijit.__Position" usage="required"/>
          <parameter name="corners" type="String[]" usage="required"/>
          <parameter name="padding" type="dijit.__Position" usage="optional"/>
        </parameters>
      </method>
      <method name="_place" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="choices" type="Array" usage="required"/>
          <parameter name="layoutNode" type="Function(node," usage="required"/>
          <parameter name="aroundNodeCoords" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundNode" scope="instance">
        <description>Place node such that corner of node touches a corner of
	aroundNode, and that node is fully visible.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundRectangle" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundRect" type="dijit.__Rectangle" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_placeOnScreenAroundRect" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="y" type="Number" usage="required"/>
          <parameter name="width" type="Number" usage="required"/>
          <parameter name="height" type="Number" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundElement" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundElement" type="Object" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getPopupAroundAlignment" scope="instance">
        <parameters>
          <parameter name="position" type="Array" usage="required"/>
          <parameter name="leftToRight" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="hasWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="optional"/>
        </parameters>
        <return-description>True if elem has the specific role attribute and false if not.
	For backwards compatibility if role parameter not provided,
	returns true if has a role</return-description>
      </method>
      <method name="getWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
        <return-description>The role of elem or an empty string if elem
	does not have a role.</return-description>
      </method>
      <method name="setWaiRole" scope="instance">
        <description>Replace existing role attribute with new role.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="hasWaiState" scope="instance">
        <description>Checks for an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
        <return-description>true if elem has a value for the given state and
	false if it does not.</return-description>
      </method>
      <method name="getWaiState" scope="instance">
        <description>Checks for an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
        <return-description>The value of the requested state on elem
	or an empty string if elem has no value for state.</return-description>
      </method>
      <method name="setWaiState" scope="instance">
        <description>Sets an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiState" scope="instance">
        <description>Sets an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getDocumentWindow" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectInputText" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_dialogStack" scope="instance" type="Array"/>
      <property name="_masterTT" scope="instance" type="Object"/>
      <property name="_Calendar" scope="instance" type="Object"/>
      <property name="_lastKeyDownNode" scope="instance" type="Object"/>
      <property name="_curFocus" scope="instance" type="DomNode"/>
      <property name="_prevFocus" scope="instance" type="DomNode"/>
      <property name="_activeStack" scope="instance" type="dijit._Widget[]"/>
      <property name="defaultDuration" scope="instance" type="Integer"/>
      <property name="placementRegistry" scope="instance" type="Object"/>
      <property name="_frames" scope="instance" type="Object"/>
      <property name="dijit-all" scope="instance" type="Object"/>
      <property name="dijit" scope="instance" type="Object"/>
      <property name="demos" scope="instance" type="Object"/>
      <property name="robot" scope="instance" type="Object"/>
      <property name="robotx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar" superclass="dijit._Widget">
    <description>A simple GUI for choosing a date in the context of a monthly calendar.
	This widget can't be used in a form because it doesn't serialize the date to an
	`&lt;input&gt;` field.  For a form element, use dijit.form.DateTextBox instead.
	Note that the parser takes all dates attributes passed in the
	[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
	so that they are serializable and locale-independent.</description>
    <methods>
      <method name="_isValidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Set the current date and update the UI.  If the date is disabled, the value will
	not change, but the display will change to the corresponding month.</description>
        <parameters>
          <parameter name="value" type="Date|Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateGrid" scope="instance"/>
      <method name="goToToday" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_adjustDisplay" scope="instance">
        <parameters>
          <parameter name="part" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_setCurrentFocusAttr" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="forceFocus" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_onMonthSelect" scope="instance">
        <parameters>
          <parameter name="newMonth" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOver" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOut" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="handleKey" scope="instance">
        <description>Called from _onKeyPress() to handle keypress on a stand alone Calendar,
	and also from `dijit.form._DateTimeTextBox` to pass a keypress event
	from the `dijit.form.DateTextBox` to be handled in this widget</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-description>False if the key was recognized as a navigation key,
	to indicate that the event was handled by Calendar and shouldn't be propogated</return-description>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="instance">
        <description>Formerly used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
	to get notification when the user has clicked a date.  Now onExecute() (above) is used.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_isSelectedDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getClassForDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Date"/>
      <property name="datePackage" scope="instance-prototype" type="String"/>
      <property name="dayWidth" scope="instance" type="String"/>
      <property name="tabIndex" scope="instance" type="Integer"/>
      <property name="currentFocus" scope="instance" type="Date"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_currentNode" scope="instance" type="Object"/>
      <property name="dateClassObj" scope="instance" type="Object"/>
      <property name="dateFuncObj" scope="instance" type="Object"/>
      <property name="dateLocaleModule" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar.cssStateNodes">
    <properties>
      <property name="decrementMonth" scope="instance" type="String"/>
      <property name="incrementMonth" scope="instance" type="String"/>
      <property name="previousYearLabelNode" scope="instance" type="String"/>
      <property name="nextYearLabelNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Calendar.monthDropDownButton.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Calendar.monthDropDownButton">
    <properties>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar._MonthDropDown" superclass="dijit._Widget">
    <methods>
      <method name="_setMonthsAttr" scope="instance">
        <parameters>
          <parameter name="months" type="String[]" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onMenuHover" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="months" scope="instance" type="String[]"/>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Calendar._MonthDropDown.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.CheckedMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="checked" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette" superclass="dijit._Widget">
    <description>Grid showing various colors, so the user can pick a certain color.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="palette" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="dyeClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._palettes">
    <properties>
      <property name="7x10" scope="instance" type="Array"/>
      <property name="3x4" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._imagePaths">
    <properties>
      <property name="7x10" scope="instance" type="Object"/>
      <property name="3x4" scope="instance" type="Object"/>
      <property name="7x10-rtl" scope="instance" type="Object"/>
      <property name="3x4-rtl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Color" superclass="dojo.Color">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
          <parameter name="blankGif" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.Color" scope="instance"/>
    </mixins>
    <properties>
      <property name="_alias" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Declaration" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="_noScript" scope="instance" type="Boolean"/>
      <property name="stopParser" scope="instance" type="Boolean"/>
      <property name="widgetClass" scope="instance" type="String"/>
      <property name="mixins" scope="instance" type="String[]"/>
    </properties>
  </class>
  <class type="dijit.Declaration.defaults">
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_skipNodeCache" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._DialogBase" superclass="dijit._Templated">
    <description>Pops up a modal dialog window, blocking access to the screen
	and also graying out the screen Dialog is extended from
	ContentPane so it supports all the same parameters (href, etc.)</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onLoad" scope="instance"/>
      <method name="_endDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setup" scope="instance"/>
      <method name="_size" scope="instance"/>
      <method name="_position" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="just let it go"/>
        </return-types>
      </method>
      <method name="show" scope="instance">
        <return-description>dojo.Deferred
	Deferred object that resolves when the display animation is complete</return-description>
      </method>
      <method name="hide" scope="instance">
        <return-description>dojo.Deferred
	Deferred object that resolves when the hide animation is complete</return-description>
      </method>
      <method name="layout" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit._DialogMixin.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit._DialogMixin" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="open" scope="instance" type="Boolean"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="refocus" scope="instance" type="Boolean"/>
      <property name="autofocus" scope="instance" type="Boolean"/>
      <property name="_firstFocusItem" scope="instance" type="DomNode"/>
      <property name="_lastFocusItem" scope="instance" type="DomNode"/>
      <property name="doLayout" scope="instance" type="Boolean"/>
      <property name="draggable" scope="instance" type="Boolean"/>
      <property name="aria-describedby" scope="instance" type="String"/>
      <property name="_modalconnects" scope="instance" type="Array"/>
      <property name="_relativePosition" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_moveable" scope="instance" type="Object"/>
      <property name="_dndListener" scope="instance" type="Object"/>
      <property name="underlayAttrs" scope="instance" type="Object"/>
      <property name="_singleChildOriginalStyle" scope="instance" type="Object"/>
      <property name="_alreadyInitialized" scope="instance" type="Object"/>
      <property name="_fadeInDeferred" scope="instance" type="Object"/>
      <property name="_fadeOutDeferred" scope="instance" type="Object"/>
      <property name="_scrollConnected" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._DialogBase.cssStateNodes">
    <properties>
      <property name="closeButtonNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._DialogBase._singleChild.domNode.style">
    <properties>
      <property name="cssText" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Dialog" superclass="dijit.layout.ContentPane">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._DialogBase.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._DialogBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._DialogLevelManager">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="dialog" type="dijit._Widget" usage="required"/>
          <parameter name="underlayAttrs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="dialog" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="isTop" scope="instance">
        <parameters>
          <parameter name="dialog" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.DialogUnderlay" superclass="dijit._Widget">
    <description>A component used to block input behind a `dijit.Dialog`. Only a single
	instance of this widget is created by `dijit.Dialog`, and saved as
	a reference to be shared between all Dialogs as `dijit._underlay`
	The underlay itself can be styled based on and id:
		#myDialog_underlay { background-color:red; }
	In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
	suffixed with _underlay.</description>
    <methods>
      <method name="_setDialogIdAttr" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setClassAttr" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="layout" scope="instance">
        <description>Sets the background to the size of the viewport (rather than the size
	of the document) since we need to cover the whole browser window, even
	if the document is only a few lines long.</description>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="dialogId" scope="instance" type="String"/>
      <property name="class" scope="instance" type="String"/>
      <property name="bgIframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.attributeMap">
    <properties>
      <property name="id" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.node">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.domNode"/>
  <class type="dijit.DialogUnderlay.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.node.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Editor" superclass="dijit._editor.RichText">
    <description>This widget provides basic WYSIWYG editing features, based on the browser's
	underlying rich text editing capability, accompanied by a toolbar (`dijit.Toolbar`).
	A plugin model is available to extend the editor's capabilities as well as the
	the options available in the toolbar.  Content generation may vary across
	browsers, and clipboard operations may have different results, to name
	a few limitations.  Note: this widget should not be used with the HTML
	&amp;lt;TEXTAREA&amp;gt; tag -- see dijit._editor.RichText for details.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="addPlugin" scope="instance">
        <parameters>
          <parameter name="plugin" type="String||Object" usage="required"/>
          <parameter name="index" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_onIEMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeActivate" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeDeactivate" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginEditing" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="execCommand" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToBookmark" scope="instance">
        <parameters>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_changeToStep" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="undo" scope="instance"/>
      <method name="redo" scope="instance"/>
      <method name="endEditing" scope="instance">
        <parameters>
          <parameter name="ignore_caret" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBookmark" scope="instance"/>
      <method name="_beginEditing" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endEditing" scope="instance">
        <parameters>
          <parameter name="ignore_caret" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_saveSelection" scope="instance"/>
      <method name="_restoreSelection" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="replaceValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.RichText" scope="instance"/>
    </mixins>
    <properties>
      <property name="plugins" scope="instance-prototype" type="Object[]"/>
      <property name="extraPlugins" scope="instance" type="Object[]"/>
      <property name="setValueDeferred" scope="instance" type="Object"/>
      <property name="_steps" scope="instance" type="Array"/>
      <property name="_undoedSteps" scope="instance" type="Array"/>
      <property name="commands" scope="instance" type="Object"/>
      <property name="toolbar" scope="instance" type="Object"/>
      <property name="_plugins" scope="instance-prototype" type="Array"/>
      <property name="_layoutMode" scope="instance" type="Object"/>
      <property name="customUndo" scope="instance" type="Boolean"/>
      <property name="editActionInterval" scope="instance" type="Integer"/>
      <property name="_inEditing" scope="instance" type="bool"/>
      <property name="_editTimer" scope="instance" type="Object"/>
      <property name="_undoRedoActive" scope="instance" type="Object"/>
      <property name="_savedSelection" scope="instance" type="Object"/>
      <property name="_editInterval" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.Editor.editingArea.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Editor.iframe.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Editor.document"/>
  <class type="dijit.Editor.document.body">
    <properties>
      <property name="clientWidth" scope="instance" type="Object"/>
      <property name="clientHeight" scope="instance" type="Object"/>
      <property name="clientLeft" scope="instance" type="Object"/>
      <property name="offsetWidth" scope="instance" type="Object"/>
      <property name="offsetHeight" scope="instance" type="Object"/>
      <property name="offsetLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor">
    <methods>
      <method name="escapeXml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getNodeHtml" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getChildrenHtml" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="html" scope="instance" type="Object"/>
      <property name="range" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
          <parameter name="node" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance">
        <description>This is called on meaningful events in the editor, such as change of selection
	or caret position (but not simple typing of alphanumeric keys).   It gives the
	plugin a chance to update the CSS of its button.
	For example, the "bold" plugin will highlight/unhighlight the bold button depending on whether the
	characters next to the caret are bold or not.
	Only makes sense when `useDefaultCommand` is true, as it calls Editor.queryCommandEnabled(`command`).</description>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit.Toolbar" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a plugin which may potentially be handled by a
	setter in the plugin.
	For example, if the plugin has a properties "foo"
	and "bar" and a method named "_setFooAttr", calling:
		plugin.set("foo", "Howdy!");
	would be equivalent to writing:
		plugin._setFooAttr("Howdy!");
	and:
		plugin.set("bar", 3);
	would be equivalent to writing:
		plugin.bar = 3;
	set() may also be called with a hash of name/value pairs, ex:
		plugin.set({
			foo: "Howdy",
			bar: 3
		})
	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)</description>
        <parameters>
          <parameter name="name" type="attribute" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <description>Get a named property from a plugin. The property may
	potentially be retrieved via a getter method. If no getter is defined, this
	just retrieves the object's property.
	For example, if the plugin has a properties "foo"
	and "bar" and a method named "_getFooAttr", calling:
		plugin.get("foo");
	would be equivalent to writing:
		plugin._getFooAttr();
	and:
		plugin.get("bar");
	would be equivalent to writing:
		plugin.bar;</description>
        <parameters>
          <parameter name="name" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttrNames" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="editor" scope="instance" type="dijit.Editor"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="button" scope="instance" type="dijit._Widget"/>
      <property name="command" scope="instance" type="String"/>
      <property name="useDefaultCommand" scope="instance" type="Boolean"/>
      <property name="buttonClass" scope="instance" type="Widget"/>
      <property name="disabled" scope="instance" type="Boolean"/>
      <property name="enabled" scope="instance" type="Object"/>
      <property name="checked" scope="instance" type="Object"/>
      <property name="_attrPairNames" scope="instance-prototype" type="Object"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox" superclass="dijit._Widget">
    <description>Behavior for an existing node (`&lt;p&gt;`, `&lt;div&gt;`, `&lt;span&gt;`, etc.) so that
	when you click it, an editor shows up in place of the original
	text.  Optionally, Save and Cancel button are displayed below the edit widget.
	When Save is clicked, the text is pulled from the edit
	widget and redisplayed and the edit widget is again hidden.
	By default a plain Textarea widget is used as the editor (or for
	inline values a TextBox), but you can specify an editor such as
	dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	An edit widget must support the following API to be used:
	- displayedValue or value as initialization parameter,
	and available through set('displayedValue') / set('value')
	- void focus()
	- DOM-node focusNode = node containing editable text</description>
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="instance"/>
      <method name="_onMouseOut" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="edit" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_showText" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="editing" scope="instance" type="Boolean"/>
      <property name="autoSave" scope="instance" type="Boolean"/>
      <property name="buttonSave" scope="instance" type="String"/>
      <property name="buttonCancel" scope="instance" type="String"/>
      <property name="renderAsHtml" scope="instance" type="Boolean"/>
      <property name="editor" scope="instance" type="String|Function"/>
      <property name="editorWrapper" scope="instance" type="String|Function"/>
      <property name="editorParams" scope="instance-prototype" type="Object"/>
      <property name="disabled" scope="instance" type="Boolean"/>
      <property name="width" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
      <property name="noValueIndicator" scope="instance" type="String"/>
      <property name="_savedPosition" scope="instance" type="Object"/>
      <property name="_savedOpacity" scope="instance" type="Object"/>
      <property name="_savedTabIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox.displayNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox.wrapperWidget">
    <properties>
      <property name="editWidget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onIntermediateChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="getValue" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <description>For autoSave widgets, if Esc/Enter, call cancel/save.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_onChange" scope="instance"/>
      <method name="enableSave" scope="instance"/>
      <method name="focus" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="messages" scope="instance" type="Object"/>
      <property name="sourceStyle" scope="instance" type="Object"/>
      <property name="editWidget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor.inlineEditBox">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MenuBase" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="onExecute" scope="instance"/>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="closeAll" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToPopup" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onPopupHover" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onItemHover" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onItemUnhover" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_stopPopupTimer" scope="instance"/>
      <method name="_stopPendingCloseTimer" scope="instance">
        <parameters>
          <parameter name="popup" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_stopFocusTimer" scope="instance"/>
      <method name="_getTopMenu" scope="instance"/>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_openPopup" scope="instance">
        <return-types>
          <return-type type="the focused child lost focus since the timer was started"/>
        </return-types>
      </method>
      <method name="_markActive" scope="instance"/>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_markInactive" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="_closeChild" scope="instance"/>
      <method name="_onItemFocus" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_cleanUp" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._KeyNavContainer.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._KeyNavContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="parentMenu" scope="instance" type="Widget"/>
      <property name="popupDelay" scope="instance" type="Integer"/>
      <property name="hover_timer" scope="instance" type="Object"/>
      <property name="_hoveredChild" scope="instance" type="Object"/>
      <property name="_focus_timer" scope="instance" type="Object"/>
      <property name="isActive" scope="instance" type="bool"/>
      <property name="isShowingNow" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._MenuBase.currentPopup"/>
  <class type="dijit._MenuBase.currentPopup.parentMenu">
    <properties>
      <property name="focusedChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MenuBase.focusedChild"/>
  <class type="dijit._MenuBase.focusedChild.popup">
    <properties>
      <property name="parentMenu" scope="instance" type="Object"/>
      <property name="from_item" scope="instance" type="Object"/>
      <property name="_focus_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Menu" superclass="dijit._MenuBase">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeContentWindow" scope="instance">
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
      <method name="_iframeContentDocument" scope="instance">
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="HTMLDocument"/>
        </return-types>
      </method>
      <method name="bindDomNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="unBindDomNode" scope="instance">
        <parameters>
          <parameter name="nodeName" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_scheduleOpen" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="optional"/>
          <parameter name="iframe" type="DomNode" usage="optional"/>
          <parameter name="coords" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_openMyself" scope="instance">
        <parameters>
          <parameter name="args" type="This" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="getPlaceholders" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="optional"/>
        </parameters>
        <return-description>An array of placeholders that match the given label</return-description>
        <return-types>
          <return-type type="dojox.widget.PlaceholderMenuItem[]"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._MenuBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="targetNodeIds" scope="instance" type="String[]"/>
      <property name="contextMenuForWindow" scope="instance" type="Boolean"/>
      <property name="leftClickToOpen" scope="instance" type="Boolean"/>
      <property name="refocus" scope="instance" type="Boolean"/>
      <property name="_openSubMenuKey" scope="instance" type="Object"/>
      <property name="_closeSubMenuKey" scope="instance" type="Object"/>
      <property name="_openTimer" scope="instance" type="Object"/>
      <property name="_bindings" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.MenuBar" superclass="dijit._MenuBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="focusChild" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._MenuBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_isMenuBar" scope="instance" type="Boolean"/>
      <property name="_orient" scope="instance" type="Object"/>
      <property name="focusedChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo">
    <methods>
      <method name="attr" scope="instance">
        <description>Handles normalized getting and setting of attributes on DOM
	Nodes. If 2 arguments are passed, and a the second argumnt is a
	string, acts as a getter.
	If a third argument is passed, or if the second argument is a
	map of attributes, acts as a setter.
	When passing functions as values, note that they will not be
	directly assigned to slots on the node, but rather the default
	behavior will be removed and the new behavior will be added
	using `dojo.connect()`, meaning that event handler properties
	will be normalized and that some caveats with regards to
	non-standard behaviors for onsubmit apply. Namely that you
	should cancel form submission using `dojo.stopEvent()` on the
	passed event object instead of returning a boolean value from
	the handler itself.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="name" type="String|Object" usage="required"/>
          <parameter name="value" type="String" usage="optional"/>
        </parameters>
        <return-description>when used as a getter, the value of the requested attribute
	or null if that attribute does not have a specified or
	default value;
	when used as a setter, the DOM node</return-description>
        <return-types>
          <return-type type="DomNode"/>
          <return-type type="Anything"/>
        </return-types>
      </method>
      <method name="hasAttr" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-description>true if the requested attribute is specified on the
	given element, and false otherwise</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="style" scope="instance">
        <description>Getting the style value uses the computed style for the node, so the value
	will be a calculated value, not just the immediate node.style value.
	Also when getting values, use specific style names,
	like "borderBottomWidth" instead of "border" since compound values like
	"border" are not necessarily reflected as expected.
	If you want to get node dimensions, use `dojo.marginBox()`,
	`dojo.contentBox()` or `dojo.position()`.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="style" type="String|Object" usage="optional"/>
          <parameter name="value" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_nodeData" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Anything"/>
          <return-type type="Nothing"/>
        </return-types>
      </method>
      <method name="_removeNodeData" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
          <parameter name="key" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_gcNodeData" scope="instance">
        <description>super expensive: GC all data in the data for nodes that no longer exist in the dom.
	MUCH safer to do this yourself, manually, on a per-node basis (via `NodeList.removeData()`)
	provided as a stop-gap for exceptionally large/complex applications with constantly changing
	content regions (eg: a dijit.layout.ContentPane with replacing data)
	There is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData
	prior to destruction.</description>
      </method>
      <method name="blendColors" scope="instance">
        <parameters>
          <parameter name="start" type="dojo.Color" usage="required"/>
          <parameter name="end" type="dojo.Color" usage="required"/>
          <parameter name="weight" type="Number" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromRgb" scope="instance">
        <description>this function can handle all 4 CSS3 Color Module formats: rgb,
	rgba, hsl, hsla, including rgb(a) with percentage values.</description>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromHex" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromArray" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromString" scope="instance">
        <description>Acceptable input values for str may include arrays of any form
	accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
	rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
	10, 50)"</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
      </method>
      <method name="when" scope="instance">
        <parameters>
          <parameter name="promiseOrValue" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="optional"/>
          <parameter name="errback" type="Function" usage="optional"/>
          <parameter name="progressHandler" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="_xhrObj" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadUri" scope="instance">
        <description>Wanted to override getText(), but it is used by
	the widget code in too many, synchronous ways right now.</description>
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="cb" type="Function" usage="required"/>
          <parameter name="currentIsXDomain" type="boolean" usage="required"/>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
          <return-type type="Boolean: contents? true : false"/>
        </return-types>
      </method>
      <method name="_isDocumentOk" scope="instance">
        <parameters>
          <parameter name="http" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getText" scope="instance">
        <parameters>
          <parameter name="uri" type="URI" usage="required"/>
          <parameter name="fail_ok" type="Boolean" usage="required"/>
        </parameters>
        <return-description>The response text. null is returned when there is a
	failure and failure is okay (an exception otherwise)</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="windowUnloaded" scope="instance"/>
      <method name="addOnWindowUnload" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="optional"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="pushContext" scope="instance">
        <description>dojo.pushContext treats contexts as a stack. The
	auto-detected contexts which are initially provided using
	dojo.setContext() require authors to keep state in order to
	"return" to a previous context, whereas the
	dojo.pushContext and dojo.popContext methods provide a more
	natural way to augment blocks of code to ensure that they
	execute in a different window or frame without issue. If
	called without any arguments, the default context (the
	context when Dojo is first loaded) is instead pushed into
	the stack. If only a single string is passed, a node in the
	intitial context's document is looked up and its
	contextWindow and contextDocument properties are used as
	the context to push. This means that iframes can be given
	an ID and code can be executed in the scope of the iframe's
	document in subsequent calls easily.</description>
        <parameters>
          <parameter name="g" type="Object|String" usage="optional"/>
          <parameter name="d" type="MDocumentElement" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="popContext" scope="instance"/>
      <method name="_inContext" scope="instance">
        <parameters>
          <parameter name="g" type="Object" usage="required"/>
          <parameter name="d" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadInit" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="String|DOMNode" usage="required"/>
          <parameter name="doc" type="Document" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="assume it's a node"/>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_isLocalUrl" scope="instance">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="exit" scope="instance">
        <parameters>
          <parameter name="exitcode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="body" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_spidermonkeyCurrentFile" scope="instance">
        <parameters>
          <parameter name="depth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moduleHasPrefix" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getModulePrefix" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_loadPath" scope="instance">
        <description>Loads and interprets the script located at relpath, which is
	relative to the script root directory.  If the script is found but
	its interpretation causes a runtime exception, that exception is
	not caught by us, so the caller will see it.  We return a true
	value if and only if the script is found.</description>
        <parameters>
          <parameter name="relpath" type="String" usage="required"/>
          <parameter name="module" type="String" usage="optional"/>
          <parameter name="cb" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_loadUriAndCheck" scope="instance">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="cb" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loaded" scope="instance"/>
      <method name="unloaded" scope="instance"/>
      <method name="_onto" scope="instance">
        <parameters>
          <parameter name="arr" type="Object" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ready" scope="instance"/>
      <method name="addOnLoad" scope="instance">
        <description>Registers a function to be triggered after the DOM has finished
	loading and `dojo.require` modules have loaded. Widgets declared in markup
	have been instantiated if `djConfig.parseOnLoad` is true when this fires.
	Images and CSS files may or may not have finished downloading when
	the specified function is called.  (Note that widgets' CSS and HTML
	code is guaranteed to be downloaded before said widgets are
	instantiated, though including css resouces BEFORE any script elements
	is highly recommended).</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="_modulesLoaded" scope="instance"/>
      <method name="_callLoaded" scope="instance"/>
      <method name="_getModuleSymbols" scope="instance">
        <parameters>
          <parameter name="modulename" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="loadInit" scope="instance">
        <description>This function is mainly a marker for the xdomain loader to know parts of
	code that needs be executed outside the function wrappper that is placed around modules.
	The init function could be executed more than once, and it should make no assumptions
	on what is loaded, or what modules are available. Only the functionality in Dojo Base
	is allowed to be used. Avoid using this method. For a valid use case,
	see the source for dojox.gfx.</description>
        <parameters>
          <parameter name="init" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_loadModule" scope="instance"/>
      <method name="require" scope="instance">
        <description>Modules are loaded via dojo.require by using one of two loaders: the normal loader
	and the xdomain loader. The xdomain loader is used when dojo was built with a
	custom build that specified loader=xdomain and the module lives on a modulePath
	that is a whole URL, with protocol and a domain. The versions of Dojo that are on
	the Google and AOL CDNs use the xdomain loader.
	If the module is loaded via the xdomain loader, it is an asynchronous load, since
	the module is added via a dynamically created script tag. This
	means that dojo.require() can return before the module has loaded. However, this
	should only happen in the case where you do dojo.require calls in the top-level
	HTML page, or if you purposely avoid the loader checking for dojo.require
	dependencies in your module by using a syntax like dojo["require"] to load the module.
	Sometimes it is useful to not have the loader detect the dojo.require calls in the
	module so that you can dynamically load the modules as a result of an action on the
	page, instead of right at module load time.
	Also, for script blocks in an HTML page, the loader does not pre-process them, so
	it does not know to download the modules before the dojo.require calls occur.
	So, in those two cases, when you want on-the-fly module loading or for script blocks
	in the HTML page, special care must be taken if the dojo.required code is loaded
	asynchronously. To make sure you can execute code that depends on the dojo.required
	modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
	callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
	executing.
	This type of syntax works with both xdomain and normal loaders, so it is good
	practice to always use this idiom for on-the-fly code loading and in HTML script
	blocks. If at some point you change loaders and where the code is loaded from,
	it will all still work.
	More on how dojo.require
	`dojo.require("A.B")` first checks to see if symbol A.B is
	defined. If it is, it is simply returned (nothing to do).
	If it is not defined, it will look for `A/B.js` in the script root
	directory.
	`dojo.require` throws an exception if it cannot find a file
	to load, or if the symbol `A.B` is not defined after loading.
	It returns the object `A.B`, but note the caveats above about on-the-fly loading and
	HTML script blocks when the xdomain loader is loading a module.
	`dojo.require()` does nothing about importing symbols into
	the current namespace.  It is presumed that the caller will
	take care of that.</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="omitModuleCheck" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>the required namespace object</return-description>
      </method>
      <method name="provide" scope="instance">
        <description>Each javascript source file is called a resource.  When a
	resource is loaded by the browser, `dojo.provide()` registers
	that it has been loaded.
	Each javascript source file must have at least one
	`dojo.provide()` call at the top of the file, corresponding to
	the file name.  For example, `js/dojo/foo.js` must have
	`dojo.provide("dojo.foo");` before any calls to
	`dojo.require()` are made.
	For backwards compatibility reasons, in addition to registering
	the resource, `dojo.provide()` also ensures that the javascript
	object for the module exists.  For example,
	`dojo.provide("dojox.data.FlickrStore")`, in addition to
	registering that `FlickrStore.js` is a resource for the
	`dojox.data` module, will ensure that the `dojox.data`
	javascript object exists, so that calls like
	`dojo.data.foo = function(){ ... }` don't fail.
	In the case of a build where multiple javascript source files
	are combined into one bigger file (similar to a .lib or .jar
	file), that file may contain multiple dojo.provide() calls, to
	note that it includes multiple resources.</description>
        <parameters>
          <parameter name="resourceName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="platformRequire" scope="instance">
        <description>This method takes a "map" of arrays which one can use to
	optionally load dojo modules. The map is indexed by the
	possible dojo.name_ values, with two additional values:
	"default" and "common". The items in the "default" array will
	be loaded if none of the other items have been choosen based on
	dojo.name_, set by your host environment. The items in the
	"common" array will *always* be loaded, regardless of which
	list is chosen.</description>
        <parameters>
          <parameter name="modMap" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="requireIf" scope="instance">
        <parameters>
          <parameter name="condition" type="Boolean" usage="required"/>
          <parameter name="resourceName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="registerModulePath" scope="instance">
        <description>An unregistered module is given the default path of ../[module],
	relative to Dojo root. For example, module acme is mapped to
	../acme.  If you want to use a different module name, use
	dojo.registerModulePath.</description>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="prefix" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="requireLocalization" scope="instance">
        <description>Load translated resource bundles provided underneath the "nls"
	directory within a package.  Translated resources may be located in
	different packages throughout the source tree.
	Each directory is named for a locale as specified by RFC 3066,
	(http://www.ietf.org/rfc/rfc3066.txt), normalized in lowercase.
	Note that the two bundles in the example do not define all the
	same variants.  For a given locale, bundles will be loaded for
	that locale and all more general locales above it, including a
	fallback at the root directory.  For example, a declaration for
	the "de-at" locale will first load `nls/de-at/bundleone.js`,
	then `nls/de/bundleone.js` and finally `nls/bundleone.js`.  The
	data will be flattened into a single Object so that lookups
	will follow this cascading pattern.  An optional build step can
	preload the bundles to avoid data redundancy and the multiple
	network hits normally required to load these resources.</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="availableFlatLocales" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="moduleUrl" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="url" type="dojo._Url||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Url"/>
        </return-types>
      </method>
      <method name="_xdDebugFileLoaded" scope="instance">
        <parameters>
          <parameter name="resourceName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdReset" scope="instance"/>
      <method name="_xdClearInterval" scope="instance"/>
      <method name="_xdCreateResource" scope="instance">
        <parameters>
          <parameter name="contents" type="String" usage="required"/>
          <parameter name="resourceName" type="String" usage="required"/>
          <parameter name="resourcePath" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_xdExtractLoadInits" scope="instance">
        <parameters>
          <parameter name="fileContents" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_xdIsXDomainPath" scope="instance">
        <parameters>
          <parameter name="relpath" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_xdResourceLoaded" scope="instance">
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdLoadFlattenedBundle" scope="instance">
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="bundleData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdInitExtraLocales" scope="instance"/>
      <method name="xdRequireLocalization" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="fLocales" type="Object" usage="required"/>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="availableFlatLocales" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_xdUnpackDependency" scope="instance">
        <parameters>
          <parameter name="dep" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_xdWalkReqs" scope="instance"/>
      <method name="_xdEvalReqs" scope="instance">
        <parameters>
          <parameter name="reqChain" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_xdWatchInFlight" scope="instance"/>
      <method name="_xdNotifyLoaded" scope="instance"/>
      <method name="indexOf" scope="instance">
        <description>This method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when
	run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
	1.6's indexOf skips the holes in the sparse array.
	For details on this method, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf</description>
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
          <parameter name="findLast" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="instance">
        <description>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when
	run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
	1.6's lastIndexOf skips the holes in the sparse array.
	For details on this method, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf</description>
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</description>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required"/>
          <parameter name="callback" type="Function|String" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="every" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every</description>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required"/>
          <parameter name="callback" type="Function|String" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some</description>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required"/>
          <parameter name="callback" type="Function|String" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</description>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required"/>
          <parameter name="callback" type="Function|String" usage="required"/>
          <parameter name="thisObject" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</description>
        <parameters>
          <parameter name="arr" type="Array" usage="required"/>
          <parameter name="callback" type="Function|String" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>Connects listeners to actions, so that after event fires, a
	listener is called with the same arguments passed to the original
	function.
	Since `dojo.connect` allows the source of events to be either a
	"regular" JavaScript function or a DOM event, it provides a uniform
	interface for listening to all the types of events that an
	application is likely to deal with though a single, unified
	interface. DOM programmers may want to think of it as
	"addEventListener for everything and anything".
	When setting up a connection, the `event` parameter must be a
	string that is the name of the method/event to be listened for. If
	`obj` is null, `dojo.global` is assumed, meaning that connections
	to global methods are supported but also that you may inadvertently
	connect to a global by passing an incorrect object name or invalid
	reference.
	`dojo.connect` generally is forgiving. If you pass the name of a
	function or method that does not yet exist on `obj`, connect will
	not fail, but will instead set up a stub method. Similarly, null
	arguments may simply be omitted such that fewer than 4 arguments
	may be required to set up a connection See the examples for details.
	The return value is a handle that is needed to
	remove this connection with `dojo.disconnect`.</description>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String" usage="required"/>
          <parameter name="context" type="Object|null" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
          <parameter name="dontFix" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="dontFix" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>Removes the connection between event and the method referenced by handle.</description>
        <parameters>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
      <method name="_disconnect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="handle" type="Object" usage="required"/>
          <parameter name="listener" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectPublisher" scope="instance">
        <parameters>
          <parameter name="topic" type="String" usage="required"/>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="declare" scope="instance">
        <description>Create a constructor using a compact notation for inheritance and
	prototype extension.
	Mixin ancestors provide a type of multiple inheritance.
	Prototypes of mixin ancestors are copied to the new class:
	changes to mixin prototypes will not affect classes to which
	they have been mixed in.
	Ancestors can be compound classes created by this version of
	dojo.declare. In complex cases all base classes are going to be
	linearized according to C3 MRO algorithm
	(see http://www.python.org/download/releases/2.3/mro/ for more
	details).
	"className" is cached in "declaredClass" property of the new class,
	if it was supplied. The immediate super class will be cached in
	"superclass" property of the new class.
	Methods in "props" will be copied and modified: "nom" property
	(the declared name of the method) will be added to all copied
	functions to help identify them for the internal machinery. Be
	very careful, while reusing methods: if you use the same
	function under different names, it can produce errors in some
	cases.
	It is possible to use constructors created "manually" (without
	dojo.declare) as bases. They will be called as usual during the
	creation of an instance, their methods will be chained, and even
	called by "this.inherited()".
	Special property "-chains-" governs how to chain methods. It is
	a dictionary, which uses method names as keys, and hint strings
	as values. If a hint string is "after", this method will be
	called after methods of its base classes. If a hint string is
	"before", this method will be called before methods of its base
	classes.
	If "constructor" is not mentioned in "-chains-" property, it will
	be chained using the legacy mode: using "after" chaining,
	calling preamble() method before each constructor, if available,
	and calling postscript() after all constructors were executed.
	If the hint is "after", it is chained as a regular method, but
	postscript() will be called after the chain of constructors.
	"constructor" cannot be chained "before", but it allows
	a special hint string: "manual", which means that constructors
	are not going to be chained in any way, and programmer will call
	them manually using this.inherited(). In the latter case
	postscript() will be called after the construction.
	All chaining hints are "inherited" from base classes and
	potentially can be overridden. Be very careful when overriding
	hints! Make sure that all chained methods can work in a proposed
	manner of chaining.
	Once a method was chained, it is impossible to unchain it. The
	only exception is "constructor". You don't need to define a
	method in order to supply a chaining hint.
	If a method is chained, it cannot use this.inherited() because
	all other methods in the hierarchy will be called automatically.
	Usually constructors and initializers of any kind are chained
	using "after" and destructors of any kind are chained as
	"before". Note that chaining assumes that chained methods do not
	return any value: any returned value will be discarded.</description>
        <parameters>
          <parameter name="className" type="String:" usage="optional"/>
          <parameter name="superclass" type="Function|Function[]:" usage="required"/>
          <parameter name="props" type="Object:" usage="required"/>
        </parameters>
        <return-description>New constructor function.</return-description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="safeMixin" scope="instance">
        <description>This function is used to mix in properties like dojo._mixin does,
	but it skips a constructor property and decorates functions like
	dojo.declare does.
	It is meant to be used with classes and objects produced with
	dojo.declare. Functions mixed in with dojo.safeMixin can use
	this.inherited() like normal methods.
	This function is used to implement extend() method of a constructor
	produced with dojo.declare().</description>
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fixEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
          <parameter name="sender" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="stopEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="isCopyKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_ieDispatcher" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIeDispatcher" scope="instance">
        <return-types>
          <return-type type="function"/>
        </return-types>
      </method>
      <method name="_fade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_defaultEasing" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="animateProperty" scope="instance">
        <description>The standard animation doesn't know what to do with something like
	rect(...). This class identifies complex properties by they being a
	string and having parenthesis. If so, that property is made into a
	dojox.fx._Complex object and the getValue() is obtained from
	there.</description>
        <parameters>
          <parameter name="args" type="dojo.__AnimArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="anim" scope="instance">
        <description>`dojo.anim` is a simpler (but somewhat less powerful) version
	of `dojo.animateProperty`.  It uses defaults for many basic properties
	and allows for positional parameters to be used in place of the
	packed "property bag" which is used for other Dojo animation
	methods.
	The `dojo.Animation` object returned from `dojo.anim` will be
	already playing when it is returned from this function, so
	calling play() on it again is (usually) a no-op.</description>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="properties" type="Object" usage="required"/>
          <parameter name="duration" type="Integer" usage="optional"/>
          <parameter name="easing" type="Function" usage="optional"/>
          <parameter name="onEnd" type="Function" usage="optional"/>
          <parameter name="delay" type="Integer" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_destroyElement" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <description>Removes a node from its parent, clobbering it and all of its
	children. Function only works with DomNodes, and returns nothing.</description>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="isDescendant" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="ancestor" type="DomNode|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setSelectable" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="selectable" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
          <parameter name="refNode" type="String|DomNode" usage="required"/>
          <parameter name="position" type="String|Number" usage="optional"/>
        </parameters>
        <return-description>DomNode
	Returned values is the first argument resolved to a DOM node.
	.place() is also a method of `dojo.NodeList`, allowing `dojo.query` node lookups.</return-description>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getComputedStyle" scope="instance">
        <description>Gets a "computed style" object which can be used to gather
	information about the current state of the rendered node.
	Note that this may behave differently on different browsers.
	Values may have different formats and value encodings across
	browsers.
	Note also that this method is expensive.  Wherever possible,
	reuse the returned object.
	Use the dojo.style() method for more consistent (pixelized)
	return values.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="CSS2Properties"/>
        </return-types>
      </method>
      <method name="_toPixelValue" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="avalue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getOpacity" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-description>Number between 0 and 1</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_setOpacity" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="opacity" type="Number" usage="required"/>
        </parameters>
        <return-description>Number between 0 and 1</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getPadExtents" scope="instance">
        <description>Returns an object with `w`, `h`, `l`, `t` properties:
			l/t = left/top padding (respectively)
			w = the total of the left and right padding
			h = the total of the top and bottom padding
	If 'node' has position, l/t forms the origin for child nodes.
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderExtents" scope="instance">
        <description>* l/t = the sum of left/top border (respectively)
	* w = the sum of the left and right border
	* h = the sum of the top and bottom border
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorderExtents" scope="instance">
        <description>* l/t = the sum of left/top padding and left/top border (respectively)
	* w = the sum of the left and right padding and border
	* h = the sum of the top and bottom padding and border
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginExtents" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginSize" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getContentBox" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderBox" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="l" type="Number" usage="optional"/>
          <parameter name="t" type="Number" usage="optional"/>
          <parameter name="w" type="Number" usage="optional"/>
          <parameter name="h" type="Number" usage="optional"/>
          <parameter name="u" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_isButtonTag" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_usesBorderBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_setContentSize" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="widthPx" type="Number" usage="required"/>
          <parameter name="heightPx" type="Number" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMarginBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="leftPx" type="Number" usage="optional"/>
          <parameter name="topPx" type="Number" usage="optional"/>
          <parameter name="widthPx" type="Number" usage="optional"/>
          <parameter name="heightPx" type="Number" usage="optional"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="marginBox" scope="instance">
        <description>Getter/setter for the margin-box of node.
	Returns an object in the expected format of box (regardless
	if box is passed). The object might look like:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	for a node offset from its parent 50px to the left, 200px from
	the top with a margin width of 300px and a margin-height of
	150px.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="box" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="contentBox" scope="instance">
        <description>Returns an object in the expected format of box (regardless if box is passed).
	The object might look like:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	for a node offset from its parent 50px to the left, 200px from
	the top with a content width of 300px and a content-height of
	150px. Note that the content box may have a much larger border
	or margin box, depending on the box model currently in use and
	CSS values set/inherited for node.
	While the getter will return top and left values, the
	setter only accepts setting the width and height.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="box" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_docScroll" scope="instance"/>
      <method name="_isBodyLtr" scope="instance"/>
      <method name="_getIeDocumentElementOffset" scope="instance">
        <description>The following values in IE contain an offset:
			event.clientX
			event.clientY
			node.getBoundingClientRect().left
			node.getBoundingClientRect().top
	But other position related values do not contain this offset,
	such as node.offsetLeft, node.offsetTop, node.style.left and
	node.style.top. The offset is always (2, 2) in LTR direction.
	When the body is in RTL direction, the offset counts the width
	of left scroll bar's width.  This function computes the actual
	offset.</description>
      </method>
      <method name="_fixIeBiDiScrollLeft" scope="instance">
        <parameters>
          <parameter name="scrollLeft" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_abs" scope="instance"/>
      <method name="position" scope="instance">
        <description>Returns an object of the form:
	{ x: 100, y: 300, w: 20, h: 15 }
	If includeScroll==true, the x and y values will include any
	document offsets that may affect the position relative to the
	viewport.
	Uses the border-box model (inclusive of border and padding but
	not margin).  Does not act as a setter.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="coords" scope="instance">
        <description>Returns an object that measures margin-box (w)idth/(h)eight
	and absolute position x/y of the border-box. Also returned
	is computed (l)eft and (t)op values in pixels from the
	node's offsetParent as returned from marginBox().
	Return value will be in the form:
				{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
	Does not act as a setter. If includeScroll is passed, the x and
	y params are affected as one would expect in dojo.position().</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="removeAttr" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNodeProp" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Anything"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <description>A DOM Element creation function. A shorthand method for creating a node or
	a fragment, and allowing for a convenient optional attribute setting step,
	as well as an optional DOM placement reference.
	Attributes are set by passing the optional object through `dojo.attr`.
	See `dojo.attr` for noted caveats and nuances, and API if applicable.
	Placement is done via `dojo.place`, assuming the new node to be the action
	node, passing along the optional reference node and position.</description>
        <parameters>
          <parameter name="tag" type="String|DomNode" usage="required"/>
          <parameter name="attrs" type="Object" usage="required"/>
          <parameter name="refNode" type="String|DomNode" usage="optional"/>
          <parameter name="pos" type="String" usage="optional"/>
        </parameters>
        <return-description>DomNode</return-description>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="empty" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
        </parameters>
      </method>
      <method name="_toDom" scope="instance">
        <parameters>
          <parameter name="frag" type="String" usage="required"/>
          <parameter name="doc" type="DocumentNode" usage="optional"/>
        </parameters>
        <return-description>DocumentFragment</return-description>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="hasClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="removeClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String|Array" usage="optional"/>
        </parameters>
      </method>
      <method name="replaceClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="addClassStr" type="String|Array" usage="required"/>
          <parameter name="removeClassStr" type="String|Array" usage="optional"/>
        </parameters>
      </method>
      <method name="toggleClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String|Array" usage="required"/>
          <parameter name="condition" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="fromJson" scope="instance">
        <description>Throws for invalid JSON strings, but it does not use a strict JSON parser. It
	delegates to eval().  The content passed to this method must therefore come
	from a trusted source.</description>
        <parameters>
          <parameter name="json" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_escapeString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="toJson" scope="instance">
        <description>Returns a [JSON](http://json.org) serialization of an object.
	Note that this doesn't check for infinite recursion, so don't do that!</description>
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
          <parameter name="_indentStr" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isString" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isArray" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isFunction" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isObject" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isArrayLike" scope="instance">
        <description>Doesn't strongly test for "arrayness".  Instead, settles for "isn't
	a string or number and has a length property". Arguments objects
	and DOM collections will return true when passed to
	dojo.isArrayLike(), but will return false when passed to
	dojo.isArray().</description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-description>If it walks like a duck and quacks like a duck, return `true`</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isAlien" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="extend" scope="instance">
        <parameters>
          <parameter name="constructor" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_hitchArgs" scope="instance">
        <parameters>
          <parameter name="scope" type="Object" usage="required"/>
          <parameter name="method" type="," usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="hitch" scope="instance">
        <parameters>
          <parameter name="scope" type="Object" usage="required"/>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="delegate" scope="instance">
        <description>This is a small implementaton of the Boodman/Crockford delegation
	pattern in JavaScript. An intermediate object constructor mediates
	the prototype chain for the returned object, using it to delegate
	down to obj for property lookup when object-local lookup fails.
	This can be thought of similarly to ES4's "wrap", save that it does
	not act on types but rather on pure objects.</description>
        <parameters>
          <parameter name="obj" type="The" usage="required"/>
          <parameter name="props" type="an" usage="required"/>
        </parameters>
        <return-description>an Object of anonymous type</return-description>
      </method>
      <method name="_toArray" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="offset" type="Number" usage="optional"/>
          <parameter name="startWith" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="partial" scope="instance">
        <description>Calling dojo.partial is the functional equivalent of calling:
		dojo.hitch(null, funcName, ...);</description>
        <parameters>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="o" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="anything"/>
          <return-type type="Node"/>
          <return-type type="Date"/>
          <return-type type="RegExp"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="trim" scope="instance">
        <description>This version of trim() was selected for inclusion into the base due
	to its compact size and relatively good performance
	(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
	Uses String.prototype.trim instead, if available.
	The fastest but longest version of this function is located at
	dojo.string.trim()</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-description>String
	Returns the trimmed string</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="tmpl" type="String" usage="required"/>
          <parameter name="map" type="Object|Function" usage="required"/>
          <parameter name="pattern" type="RegEx" usage="optional"/>
        </parameters>
        <return-description>String
	Returns the substituted string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="setContext" scope="instance">
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="globalDocument" type="DocumentElement" usage="required"/>
        </parameters>
      </method>
      <method name="withGlobal" scope="instance">
        <description>Invoke callback with globalObject as dojo.global and
	globalObject.document as dojo.doc. If provided, globalObject
	will be executed in the context of object thisObject
	When callback() returns or throws an error, the dojo.global
	and dojo.doc will be restored to its previous state.</description>
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="withDoc" scope="instance">
        <description>Invoke callback with documentObject as dojo.doc. If provided,
	callback will be executed in the context of object thisObject
	When callback() returns or throws an error, the dojo.doc will
	be restored to its previous state.</description>
        <parameters>
          <parameter name="documentObject" type="DocumentElement" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="fieldToObject" scope="instance">
        <description>Returns the value encoded in a form field as
	as a string or an array of strings. Disabled form elements
	and unchecked radio and checkboxes are skipped.	Multi-select
	elements are returned as an array of string values.</description>
        <parameters>
          <parameter name="inputNode" type="DOMNode||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formToObject" scope="instance">
        <description>Returns the values encoded in an HTML form as
	string properties in an object which it then returns. Disabled form
	elements, buttons, and other non-value form elements are skipped.
	Multi-select elements are returned as an array of string values.</description>
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="objectToQuery" scope="instance">
        <parameters>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formToQuery" scope="instance">
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formToJson" scope="instance">
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="queryToObject" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_ioSetArgs" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__IoArgs" usage="required"/>
          <parameter name="canceller" type="Function" usage="required"/>
          <parameter name="okHandler" type="Function" usage="required"/>
          <parameter name="errHandler" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCancelAll" scope="instance"/>
      <method name="_ioNotifyStart" scope="instance">
        <description>Used by IO transports. An IO transport should
	call this method before making the network connection.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioWatch" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
          <parameter name="validCheck" type="Function" usage="required"/>
          <parameter name="ioCheck" type="Function" usage="required"/>
          <parameter name="resHandle" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_ioAddQueryToUrl" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required"/>
        </parameters>
      </method>
      <method name="xhr" scope="instance">
        <description>Sends an HTTP request with the given method.
	See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
	for those HTTP methods. There are also methods for "raw" PUT and POST methods
	via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.</description>
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
          <parameter name="hasBody" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrGet" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="rawXhrPost" scope="instance"/>
      <method name="xhrPost" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="rawXhrPut" scope="instance"/>
      <method name="xhrPut" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrDelete" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="deprecated" scope="instance">
        <parameters>
          <parameter name="behaviour" type="String" usage="required"/>
          <parameter name="extra" type="String" usage="optional"/>
          <parameter name="removal" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="experimental" scope="instance">
        <description>This can be used to mark a function, file, or module as
	experimental.  Experimental code is not ready to be used, and the
	APIs are subject to change without notice.  Experimental code may be
	completed deleted without going through the normal deprecation
	process.</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="extra" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="__backArgs" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hash" scope="instance">
        <description>Handles getting and setting of location.hash.
	- If no arguments are passed, acts as a getter.
	- If a string is passed, acts as a setter.</description>
        <parameters>
          <parameter name="hash" type="String" usage="optional"/>
          <parameter name="replace" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>when used as a getter, returns the current hash string.
	when used as a setter, returns the new hash string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_nodeDataCache" scope="instance" type="Object"/>
      <property name="NodeList-data" scope="instance" type="Object"/>
      <property name="NodeList-fx" scope="instance" type="Object"/>
      <property name="NodeList-html" scope="instance" type="Object"/>
      <property name="NodeList-manipulate" scope="instance" type="Object"/>
      <property name="NodeList-traverse" scope="instance" type="Object"/>
      <property name="_NodeListCtor" scope="instance" type="Object"/>
      <property name="isBrowser" scope="instance" type="Object"/>
      <property name="_name" scope="instance" type="String"/>
      <property name="baseUrl" scope="instance" type="String"/>
      <property name="isMozilla" scope="instance" type="Object"/>
      <property name="isMoz" scope="instance" type="Object"/>
      <property name="isFF" scope="instance" type="Object"/>
      <property name="isQuirks" scope="instance" type="bool"/>
      <property name="locale" scope="instance" type="Object"/>
      <property name="_windowUnloaders" scope="instance" type="Array"/>
      <property name="_defaultContext" scope="instance" type="Array"/>
      <property name="_initFired" scope="instance" type="bool"/>
      <property name="isRhino" scope="instance" type="Object"/>
      <property name="_timeouts" scope="instance" type="Array"/>
      <property name="isSpidermonkey" scope="instance" type="Object"/>
      <property name="_loadedModules" scope="instance" type="Object"/>
      <property name="_inFlightCount" scope="instance" type="Number"/>
      <property name="_hasResource" scope="instance" type="Object"/>
      <property name="_loadedUrls" scope="instance" type="Array"/>
      <property name="_postLoad" scope="instance" type="bool"/>
      <property name="_loaders" scope="instance" type="Array"/>
      <property name="_unloaders" scope="instance" type="Array"/>
      <property name="_loadNotifying" scope="instance" type="bool"/>
      <property name="_global_omit_module_check" scope="instance" type="bool"/>
      <property name="requireAfterIf" scope="instance" type="Object"/>
      <property name="nonDebugProvide" scope="instance" type="Object"/>
      <property name="_xdDebugScopeChecked" scope="instance" type="Object"/>
      <property name="_isXDomain" scope="instance" type="bool"/>
      <property name="_xdInFlight" scope="instance" type="Object"/>
      <property name="_xdOrderedReqs" scope="instance" type="Array"/>
      <property name="_xdDepMap" scope="instance" type="Object"/>
      <property name="_xdContents" scope="instance" type="Array"/>
      <property name="_xdTimer" scope="instance" type="Number"/>
      <property name="_xdCharSet" scope="instance" type="String"/>
      <property name="_xdStartTime" scope="instance" type="Object"/>
      <property name="_headElement" scope="instance" type="Object"/>
      <property name="_xdReqLoc" scope="instance" type="Object"/>
      <property name="_xdBundleMap" scope="instance" type="Object"/>
      <property name="_xdRealRequireLocalization" scope="instance" type="Object"/>
      <property name="_topics" scope="instance" type="Object"/>
      <property name="subscribe" scope="instance" type="Object"/>
      <property name="unsubscribe" scope="instance" type="Object"/>
      <property name="publish" scope="instance" type="Object"/>
      <property name="_mixin" scope="instance" type="Object"/>
      <property name="_ieListenersName" scope="instance" type="String"/>
      <property name="_Animation" scope="instance" type="Object"/>
      <property name="boxModel" scope="instance" type="String"/>
      <property name="toJsonIndentStr" scope="instance" type="String"/>
      <property name="_delegate" scope="instance" type="Object"/>
      <property name="_bodyLtr" scope="instance" type="Object"/>
      <property name="_blockAsync" scope="instance" type="bool"/>
      <property name="jaxer" scope="instance" type="Object"/>
      <property name="robot" scope="instance" type="Object"/>
      <property name="robotx" scope="instance" type="Object"/>
      <property name="tests" scope="instance" type="Object"/>
      <property name="isIE" scope="instance" type="Object"/>
      <property name="isOpera" scope="instance" type="Object"/>
      <property name="uacss" scope="instance" type="Object"/>
      <property name="isWebKit" scope="instance" type="bool"/>
      <property name="isBB" scope="instance" type="Object"/>
      <property name="_oldConnect" scope="instance" type="Object"/>
      <property name="_defaultXhr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MenuBarItemMixin">
    <methods/>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.MenuBarItem" superclass="dijit.MenuItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._MenuBarItemMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
      <mixin type="dijit._MenuBarItemMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.MenuItem" superclass="dijit._Widget">
    <methods>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_onHover" scope="instance"/>
      <method name="_onUnhover" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_onFocus" scope="instance"/>
      <method name="_setSelected" scope="instance">
        <parameters>
          <parameter name="selected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setAccelKeyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
      <property name="accelKey" scope="instance" type="String"/>
      <property name="disabled" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dijit.MenuItem.accelKeyNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.MenuItem.accelKeyNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.MenuSeparator" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="isFocusable" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.PopupMenuBarItem" superclass="dijit.PopupMenuItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._MenuBarItemMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.PopupMenuItem" scope="instance"/>
      <mixin type="dijit._MenuBarItemMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.PopupMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="_fillContent" scope="instance">
        <description>srcNodeRefinnerHTML contains both the menu item text and a popup widget
	The first part holds the menu item text and the second part is the popup</description>
      </method>
      <method name="startup" scope="instance"/>
      <method name="destroyDescendants" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="dropDownContainer" scope="instance" type="Object"/>
      <property name="popup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.PopupMenuItem.popup.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.ProgressBar" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="update" scope="instance">
        <parameters>
          <parameter name="attributes" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setIndeterminateAttr" scope="instance">
        <parameters>
          <parameter name="indeterminate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="report" scope="instance">
        <parameters>
          <parameter name="percent" type="float" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="progress" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
      <property name="maximum" scope="instance" type="Float"/>
      <property name="places" scope="instance" type="Number"/>
      <property name="indeterminate" scope="instance" type="Boolean"/>
      <property name="label" scope="instance" type="String"/>
      <property name="name" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_indeterminateHighContrastImagePath" scope="instance" type="dojo._URL"/>
      <property name="internalProgress" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ProgressBar.labelNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ProgressBar.internalProgress.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.TitlePane" superclass="dijit.layout.ContentPane">
    <description>An accessible container with a title Heading, and a content
	section that slides open and closed. TitlePane is an extension to
	`dijit.layout.ContentPane`, providing all the useful content-control aspects from it.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setOpenAttr" scope="instance">
        <parameters>
          <parameter name="open" type="Boolean" usage="required"/>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setToggleableAttr" scope="instance">
        <parameters>
          <parameter name="canToggle" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="instance">
        <parameters>
          <parameter name="content" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
      <method name="_setCss" scope="instance"/>
      <method name="_onTitleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTitleClick" scope="instance"/>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_dxfindParent" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="open" scope="instance" type="Boolean"/>
      <property name="toggleable" scope="instance" type="Boolean"/>
      <property name="tabIndex" scope="instance" type="String"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="hideNode" scope="instance" type="Object"/>
      <property name="wipeNode" scope="instance" type="Object"/>
      <property name="_wipeIn" scope="instance" type="Object"/>
      <property name="_wipeOut" scope="instance" type="Object"/>
      <property name="titleBarNode" scope="instance" type="Object"/>
      <property name="_titleBarClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.hideNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.wipeNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.arrowNodeInner">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Toolbar" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._KeyNavContainer.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._KeyNavContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.ToolbarSeparator" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="position" type="String[]" usage="optional"/>
          <parameter name="rtl" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="orient" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="tooltipCorner" type="String" usage="required"/>
          <parameter name="spaceAvailable" type="Object" usage="required"/>
          <parameter name="aroundNodeCoords" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="instance"/>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="bgIframe" scope="instance" type="Object"/>
      <property name="fadeIn" scope="instance" type="Object"/>
      <property name="fadeOut" scope="instance" type="Object"/>
      <property name="_onDeck" scope="instance" type="Object"/>
      <property name="isShowingNow" scope="instance" type="bool"/>
      <property name="aroundNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.domNode">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.connectorNode.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="bottom" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="filter" scope="instance" type="String"/>
      <property name="cssText" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.containerNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.connectorNode">
    <properties>
      <property name="offsetHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Tooltip" superclass="dijit._Widget">
    <methods>
      <method name="_setConnectIdAttr" scope="instance">
        <parameters>
          <parameter name="newId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="addTarget" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNODE" usage="required"/>
        </parameters>
      </method>
      <method name="removeTarget" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNODE" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_onTargetMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetMouseLeave" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnHover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="onShow" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="position" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHide" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String"/>
      <property name="showDelay" scope="instance" type="Integer"/>
      <property name="connectId" scope="instance" type="String|String[]"/>
      <property name="position" scope="instance" type="String[]"/>
      <property name="_connections" scope="instance" type="Object"/>
      <property name="_connectIds" scope="instance" type="Object"/>
      <property name="_focus" scope="instance" type="bool"/>
      <property name="_showTimer" scope="instance" type="Object"/>
      <property name="_connectNode" scope="instance" type="Object"/>
      <property name="defaultPosition" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.TooltipDialog" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="_setTitleAttr" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="orient" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="corner" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance"/>
      <method name="_onKey" scope="instance">
        <description>Keep keyboard focus in dialog; close dialog on escape key</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit._DialogMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit._DialogMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="doLayout" scope="instance" type="Boolean"/>
      <property name="autofocus" scope="instance" type="Boolean"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_firstFocusItem" scope="instance" type="[readonly]"/>
      <property name="_lastFocusItem" scope="instance" type="[readonly]"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_currentOrientClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TooltipDialog.containerNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setIndentAttr" scope="instance">
        <description>0 for top level nodes, 1 for their children, 2 for their
	grandchildren, etc.</description>
        <parameters>
          <parameter name="indent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markProcessing" scope="instance"/>
      <method name="unmarkProcessing" scope="instance"/>
      <method name="_updateItemClasses" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyClassAndStyle" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required"/>
          <parameter name="lower" type="The" usage="required"/>
          <parameter name="upper" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_updateLayout" scope="instance"/>
      <method name="_setExpando" scope="instance">
        <parameters>
          <parameter name="processing" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="expand" scope="instance">
        <return-description>Deferred that fires when expansion is complete</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="collapse" scope="instance"/>
      <method name="setChildItems" scope="instance">
        <parameters>
          <parameter name="items" type="Object[]" usage="required"/>
        </parameters>
        <return-description>Deferred object that fires after all previously opened children
	have been expanded again (or fires instantly if there are no such children).</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="getTreePath" scope="instance"/>
      <method name="getIdentity" scope="instance"/>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="node" type="treeNode" usage="required"/>
        </parameters>
      </method>
      <method name="makeExpandable" scope="instance"/>
      <method name="_onLabelFocus" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="instance">
        <description>In particular, setting a node as selected involves setting tabIndex
	so that when user tabs to the tree, focus will go to that node (only).</description>
        <parameters>
          <parameter name="selected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusable" scope="instance">
        <description>In particular, setting a node as selected involves setting tabIndex
	so that when user tabs to the tree, focus will go to that node (only).</description>
        <parameters>
          <parameter name="selected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEnter" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="item" scope="instance" type="dojo.data.Item"/>
      <property name="isTreeNode" scope="instance" type="Boolean"/>
      <property name="label" scope="instance" type="String"/>
      <property name="isExpandable" scope="instance" type="Boolean"/>
      <property name="isExpanded" scope="instance" type="Boolean"/>
      <property name="state" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_expandDeferred" scope="instance" type="Object"/>
      <property name="_wipeOut" scope="instance" type="Object"/>
      <property name="indent" scope="instance" type="Integer"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.cssStateNodes">
    <properties>
      <property name="rowNode" scope="instance" type="String"/>
      <property name="labelNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.tree">
    <properties>
      <property name="model" scope="instance" type="Object"/>
      <property name="lastFocused" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.expandoNodeText">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Tree" superclass="dijit._Widget">
    <methods>
      <method name="onDndDrop" scope="instance"/>
      <method name="itemCreator" scope="instance">
        <description>For each node in nodes[], which came from source, create a hash of name/value
	pairs to be passed to Tree.model.newItem().  Returns array of those hashes.</description>
        <parameters>
          <parameter name="nodes" type="DomNode[]" usage="required"/>
          <parameter name="target" type="DomNode" usage="required"/>
          <parameter name="source" type="dojo.dnd.Source" usage="required"/>
        </parameters>
        <return-description>Object[]
	Array of name/value hashes for each new item to be added to the Tree, like:
		[
			{ id: 123, label: "apple", foo: "bar" },
			{ id: 456, label: "pear", zaz: "bam" }
		]</return-description>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="dijit.tree._dndSource" usage="required"/>
          <parameter name="nodes" type="DOMNode[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="checkItemAcceptance" scope="instance">
        <description>In the base case, this is called to check if target can become a child of source.
	When betweenThreshold is set, position="before" or "after" means that we
	are asking if the source node can be dropped before/after the target node.</description>
        <parameters>
          <parameter name="target" type="DOMNode" usage="required"/>
          <parameter name="source" type="dijit.tree.dndSource" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_publish" scope="instance">
        <parameters>
          <parameter name="topicName" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_store2model" scope="instance"/>
      <method name="onLoad" scope="instance">
        <description>If persist == true the loading may encompass many levels of fetches
	from the data store, each asynchronous.   Waits for all to finish.</description>
      </method>
      <method name="_load" scope="instance"/>
      <method name="getNodesByItem" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-description>Array of tree nodes that refer to passed item</return-description>
      </method>
      <method name="_setSelectedItemAttr" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="dojo.data.Items" usage="required"/>
        </parameters>
      </method>
      <method name="_setPathAttr" scope="instance">
        <parameters>
          <parameter name="path" type="Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="_setPathsAttr" scope="instance">
        <parameters>
          <parameter name="paths" type="Item[][]" usage="required"/>
        </parameters>
        <return-description>Deferred to indicate when the set is complete</return-description>
      </method>
      <method name="_setSelectedNodeAttr" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedNodesAttr" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getItemChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIconClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getRowClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getIconStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}</return-description>
      </method>
      <method name="getLabelStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object suitable for input to dojo.style() like {color: "red", background: "green"}</return-description>
      </method>
      <method name="getRowStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object suitable for input to dojo.style() like {background-color: "#bbb"}</return-description>
      </method>
      <method name="getTooltip" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onEnterKey" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDownArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRightArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLeftArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHomeKey" scope="instance"/>
      <method name="_onEndKey" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLetterKeyNav" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isExpandoNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="nodeWidget" type="TreeNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="nodeWidget" type="TreeNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onExpandoClick" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_TreeNode"/>
        </return-types>
      </method>
      <method name="_getRootOrFirstNode" scope="instance"/>
      <method name="_collapseNode" scope="instance">
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="_expandNode" scope="instance">
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
          <parameter name="recursive" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>Deferred that fires when the node is loaded and opened and (if persist=true) all it's descendants
	that were previously opened too</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="focusNode" scope="instance">
        <parameters>
          <parameter name="node" type="_tree.Node" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeFocus" scope="instance">
        <description>It marks that the current node is the selected one, and the previously
	selected node no longer is.</description>
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeMouseEnter" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeMouseLeave" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_initState" scope="instance"/>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="expanded" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveState" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="destroyRecursive" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createTreeNode" scope="instance">
        <description>Developers can override this method to define their own TreeNode class;
	However it will probably be removed in a future release in favor of a way
	of just specifying a widget for the label, rather than one that contains
	the children too.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="String||dojo.data.Store"/>
      <property name="model" scope="instance" type="dijit.Tree.model"/>
      <property name="query" scope="instance" type="anything"/>
      <property name="label" scope="instance" type="String"/>
      <property name="showRoot" scope="instance" type="Boolean"/>
      <property name="childrenAttr" scope="instance" type="String[]"/>
      <property name="paths" scope="instance" type="String[][]"/>
      <property name="path" scope="instance" type="String[]"/>
      <property name="selectedItems" scope="instance" type="Item[]"/>
      <property name="selectedItem" scope="instance" type="Item"/>
      <property name="openOnClick" scope="instance" type="Boolean"/>
      <property name="openOnDblClick" scope="instance" type="Boolean"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="persist" scope="instance" type="Boolean"/>
      <property name="autoExpand" scope="instance" type="Boolean"/>
      <property name="dndController" scope="instance" type="String"/>
      <property name="dndParams" scope="instance" type="Array"/>
      <property name="dragThreshold" scope="instance" type="Integer"/>
      <property name="betweenThreshold" scope="instance" type="Integer"/>
      <property name="_nodePixelIndent" scope="instance" type="Integer"/>
      <property name="tree" scope="instance" type="Object"/>
      <property name="_itemNodesMap" scope="instance" type="Object"/>
      <property name="cookieName" scope="instance" type="String"/>
      <property name="_loadDeferred" scope="instance" type="Object"/>
      <property name="_v10Compat" scope="instance" type="Object"/>
      <property name="_keyHandlerMap" scope="instance" type="Object"/>
      <property name="multiCharSearchDuration" scope="instance" type="Number"/>
      <property name="_curSearch" scope="instance" type="Object"/>
      <property name="lastFocused" scope="instance" type="Object"/>
      <property name="_openedItemIds" scope="instance" type="Object"/>
      <property name="rootNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Contained">
    <methods>
      <method name="getParent" scope="instance"/>
      <method name="_getSibling" scope="instance">
        <parameters>
          <parameter name="which" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getPreviousSibling" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getNextSibling" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getIndexInParent" scope="instance">
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dijit._Container">
    <description>Use this mixin for widgets that needs to know about and
	keep track of their widget children. Suitable for widgets like BorderContainer
	and TabContainer which contain (only) a set of child widgets.
	It's not suitable for widgets like ContentPane
	which contains mixed HTML (plain DOM nodes in addition to widgets),
	and where contained widgets are not necessarily directly below
	this.containerNode.   In that case calls like addChild(node, position)
	wouldn't make sense.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <description>Inserts specified child widget's dom node as a child of this widget's
	container node, and possibly does other processing (such as layout).</description>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="hasChildren" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getSiblingOfChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="dir" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getIndexOfChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="startup" scope="instance"/>
    </methods>
    <properties>
      <property name="isContainer" scope="instance" type="Boolean"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._CssStateMixin">
    <description>By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	maintain CSS classes on the widget root node (this.domNode) depending on hover,
	active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	It also sets CSS like dijitButtonDisabled based on widget semantic state.
	By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	within the widget).</description>
    <methods>
      <method name="_applyAttributes" scope="instance"/>
      <method name="_cssMouseEvent" scope="instance">
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance">
        <description>In the case where a widget has multiple
	states, it sets the class based on all possible
	combinations.  For example, an invalid form widget that is being hovered
	will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
	The widget may have one or more of the following states, determined
	by this.state, this.checked, this.valid, and this.selected:
	- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
	- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
	- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
	- Selected - ex: currently selected tab will have this.selected==true
	In addition, it may have one or more of the following states,
	based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
	- Disabled	- if the widget is disabled
	- Active		- if the mouse (or space/enter key?) is being pressed down
	- Focused		- if the widget has focus
	- Hover		- if the mouse is over the widget</description>
      </method>
      <method name="_trackMouseState" scope="instance">
        <description>Given class=foo, will set the following CSS class on the node
	- fooActive: if the user is currently pressing down the mouse button while over the node
	- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
	- fooFocus: if the node is focused
	Note that it won't set any classes if the widget is disabled.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="clazz" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cssStateNodes" scope="instance" type="Object"/>
      <property name="hovering" scope="instance" type="Boolean"/>
      <property name="active" scope="instance" type="Boolean"/>
      <property name="_mouseDown" scope="instance" type="Object"/>
      <property name="_stateClasses" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._CssStateMixin.stateNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._DialogMixin">
    <methods>
      <method name="execute" scope="instance">
        <description>After the user has pressed the submit button, the Dialog
	first calls onExecute() to notify the container to hide the
	dialog and restore focus to wherever it used to be.
	*Then* this method is called.
	type:
	callback</description>
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <description>Developer shouldn't override or connect to this method;
	it's a private communication device between the TooltipDialog
	and the thing that opened it (ex: `dijit.form.DropDownButton`)
	type:
	protected</description>
      </method>
      <method name="onExecute" scope="instance">
        <description>Developer shouldn't override or connect to this method;
	it's a private communication device between the TooltipDialog
	and the thing that opened it (ex: `dijit.form.DropDownButton`)
	type:
	protected</description>
      </method>
      <method name="_onSubmit" scope="instance"/>
      <method name="_getFocusItems" scope="instance"/>
    </methods>
    <properties>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_firstFocusItem" scope="instance" type="Object"/>
      <property name="_lastFocusItem" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._HasDropDown">
    <methods>
      <method name="_onDropDownMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDropDownClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="isLoaded" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="toggleDropDown" scope="instance"/>
      <method name="openDropDown" scope="instance">
        <return-description>return value of dijit.popup.open()</return-description>
      </method>
      <method name="closeDropDown" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_buttonNode" scope="instance" type="DomNode"/>
      <property name="_arrowWrapperNode" scope="instance" type="DomNode"/>
      <property name="_popupStateNode" scope="instance" type="DomNode"/>
      <property name="_aroundNode" scope="instance" type="DomNode"/>
      <property name="autoWidth" scope="instance" type="Boolean"/>
      <property name="forceWidth" scope="instance" type="Boolean"/>
      <property name="maxHeight" scope="instance" type="Integer"/>
      <property name="_stopClickEvents" scope="instance" type="Boolean"/>
      <property name="_docHandler" scope="instance" type="Object"/>
      <property name="_preparedNode" scope="instance" type="Object"/>
      <property name="_explicitDDWidth" scope="instance" type="Object"/>
      <property name="_explicitDDHeight" scope="instance" type="Object"/>
      <property name="_opened" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._HasDropDown.dropDownPosition">
    <properties>
      <property name="0" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._HasDropDown.dropDown">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._KeyNavContainer" superclass="dijit._Container">
    <description>To use this mixin, call connectKeyNavHandlers() in
	postCreate() and call startupKeyNavChildren() in startup().
	It provides normalized keyboard and focusing code for Container
	widgets.</description>
    <methods>
      <method name="connectKeyNavHandlers" scope="instance">
        <parameters>
          <parameter name="prevKeyCodes" type="dojo.keys[]" usage="required"/>
          <parameter name="nextKeyCodes" type="dojo.keys[]" usage="required"/>
        </parameters>
      </method>
      <method name="startupKeyNavChildren" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="focusFirstChild" scope="instance"/>
      <method name="focusLastChild" scope="instance"/>
      <method name="focusNext" scope="instance"/>
      <method name="focusPrev" scope="instance"/>
      <method name="focusChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="last" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_startupChild" scope="instance">
        <description>Sets tabIndex=-1 on each child, so that the tab key will
	leave the container rather than visiting each child.</description>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerFocus" scope="instance">
        <description>Initially the container itself has a tabIndex, but when it gets
	focus, switch focus to first child...</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerKeypress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getFirstFocusableChild" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="_getLastFocusableChild" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="_getNextFocusableChild" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
          <parameter name="dir" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="focusedChild" scope="instance" type="Widget"/>
      <property name="tabIndex" scope="instance" type="Integer"/>
      <property name="_keyNavCodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._PaletteMixin" superclass="dijit._CssStateMixin">
    <description>A mixin for a grid showing various entities, so the user can pick a certain entity.</description>
    <methods>
      <method name="_preparePalette" scope="instance">
        <parameters>
          <parameter name="choices" type="String[][]" usage="required"/>
          <parameter name="titles" type="String[]" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_onCellClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setCurrent" scope="instance">
        <description>At any point in time there's exactly one
	cell with tabIndex != -1.   If focus is inside the palette then
	focus is on that cell.
	After calling this method, arrow key handlers and mouse click handlers
	should focus the cell in a setTimeout().</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Optional" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_navigateByKey" scope="instance">
        <parameters>
          <parameter name="increment" type="How" usage="required"/>
          <parameter name="typeCount" type="How" usage="required"/>
        </parameters>
      </method>
      <method name="_getDye" scope="instance">
        <parameters>
          <parameter name="cell" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultTimeout" scope="instance" type="Number"/>
      <property name="timeoutChangeRate" scope="instance" type="Number"/>
      <property name="value" scope="instance" type="String"/>
      <property name="_selectedCell" scope="instance" type="Integer"/>
      <property name="_currentFocus" scope="instance" type="DomNode"/>
      <property name="_xDim" scope="instance" type="Integer"/>
      <property name="_yDim" scope="instance" type="Integer"/>
      <property name="tabIndex" scope="instance" type="String"/>
      <property name="cellClass" scope="instance" type="String"/>
      <property name="dyeClass" scope="instance" type="String"/>
      <property name="_cells" scope="instance" type="Array"/>
      <property name="_blankGif" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Dye">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>For example color hex value, emoticon ascii value etc, entity hex value.</description>
      </method>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DomNode" usage="required"/>
          <parameter name="blankGif" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._Widget" superclass="dijit._WidgetBase">
    <methods>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseLeave" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseEnter" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="optional"/>
        </parameters>
      </method>
      <method name="_onConnect" scope="instance">
        <parameters>
          <parameter name="event" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="onFocus" scope="instance"/>
      <method name="onBlur" scope="instance"/>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="setAttribute" scope="instance">
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <description>This method is deprecated, use get() or set() directly.</description>
        <parameters>
          <parameter name="name" type="String|Object" usage="required"/>
          <parameter name="value" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <description>Provide widget-specific analog to dojo.connect, except with the
	implicit use of this widget as the target object.
	This version of connect also provides a special "ondijitclick"
	event which triggers on a click or space or enter keyup.
	Events connected with `this.connect` are disconnected upon
	destruction.</description>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String|Function" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
        <return-description>A handle that can be passed to `disconnect` in order to disconnect before
	the widget is destroyed.</return-description>
        <return-types>
          <return-type type="_Widget.Handle"/>
        </return-types>
      </method>
      <method name="_onShow" scope="instance"/>
      <method name="onShow" scope="instance"/>
      <method name="onHide" scope="instance"/>
      <method name="onClose" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="dojoAttachEvent" scope="instance" type="String"/>
      <property name="dojoAttachPoint" scope="instance" type="String"/>
      <property name="waiRole" scope="instance" type="String"/>
      <property name="waiState" scope="instance" type="String"/>
      <property name="focused" scope="instance" type="Boolean"/>
      <property name="nodesWithKeyClick" scope="instance" type="String[]"/>
      <property name="region" scope="instance" type="String"/>
      <property name="layoutPriority" scope="instance" type="Number"/>
      <property name="splitter" scope="instance" type="Boolean"/>
      <property name="minSize" scope="instance" type="Number"/>
      <property name="maxSize" scope="instance" type="Number"/>
      <property name="layoutAlign" scope="instance" type="String"/>
      <property name="sizeMin" scope="instance" type="Integer"/>
      <property name="sizeShare" scope="instance" type="Integer"/>
      <property name="selected" scope="instance" type="Boolean"/>
      <property name="closable" scope="instance" type="Boolean"/>
      <property name="iconClass" scope="instance" type="String"/>
      <property name="showTitle" scope="instance" type="Boolean"/>
      <property name="observer" scope="instance" type="String"/>
      <property name="column" scope="instance" type="String"/>
      <property name="dragRestriction" scope="instance" type="Boolean"/>
      <property name="slideFrom" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
      <property name="spanLabel" scope="instance" type="Boolean"/>
      <property name="colspan" scope="instance" type="Number"/>
      <property name="toggleSplitterOpen" scope="instance" type="Boolean"/>
      <property name="toggleSplitterClosedThreshold" scope="instance" type="String"/>
      <property name="toggleSplitterOpenSize" scope="instance" type="String"/>
      <property name="dndType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._Templated">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_stringRepl" scope="instance">
        <parameters>
          <parameter name="tmpl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_attachTemplateNodes" scope="instance">
        <description>Map widget properties and functions to the handlers specified in
	the dom node and it's descendants. This function iterates over all
	nodes and looks for these properties:
	* dojoAttachPoint
	* dojoAttachEvent
	* waiRole
	* waiState</description>
        <parameters>
          <parameter name="rootNode" type="DomNode|Array[Widgets]" usage="required"/>
          <parameter name="getAttrFunc" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="destroyRendering" scope="instance"/>
      <method name="getCachedTemplate" scope="instance">
        <parameters>
          <parameter name="templatePath" type="String||dojo.uri.Uri" usage="required"/>
          <parameter name="templateString" type="String" usage="optional"/>
          <parameter name="alwaysUseString" type="Object" usage="required"/>
        </parameters>
        <return-description>Mixed
	Either string (if there are ${} variables that need to be replaced) or just
	a DOM tree (if the node can be cloned directly)</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="Node"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="templatePath" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Boolean"/>
      <property name="_skipNodeCache" scope="instance" type="bool"/>
      <property name="_earlyTemplatedStartup" scope="instance" type="Boolean"/>
      <property name="_attachPoints" scope="instance-prototype" type="String[]"/>
      <property name="_attachEvents" scope="instance-prototype" type="Handle[]"/>
      <property name="declaredClass" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_startupWidgets" scope="instance" type="Object"/>
      <property name="_supportingWidgets" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_templateCache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TimePicker" superclass="dijit._Widget">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="Date" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Set the value of the TimePicker.
	Redraws the TimePicker around the new date.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setFilterStringAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getFilteredNodes" scope="instance">
        <parameters>
          <parameter name="start" type="number" usage="required"/>
          <parameter name="maxNum" type="number" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="lastNode" type="DOMnode" usage="required"/>
        </parameters>
      </method>
      <method name="_showText" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_buttonMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_createOption" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onOptionSelected" scope="instance">
        <parameters>
          <parameter name="tgt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="time" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightOption" scope="instance">
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="highlight" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onmouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onmouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowUp" scope="instance">
        <description>Removes the bottom time and add one to the top</description>
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="typematic end"/>
        </return-types>
      </method>
      <method name="_onArrowDown" scope="instance">
        <description>Remove the top time and add one to the bottom</description>
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="typematic end"/>
        </return-types>
      </method>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="true means don't call stopEvent()"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="clickableIncrement" scope="instance" type="String"/>
      <property name="visibleIncrement" scope="instance" type="String"/>
      <property name="visibleRange" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
      <property name="_visibleIncrement" scope="instance" type="Number"/>
      <property name="_clickableIncrement" scope="instance" type="Number"/>
      <property name="_totalIncrements" scope="instance" type="Number"/>
      <property name="constraints" scope="instance-prototype" type="dijit._TimePicker.__Constraints"/>
      <property name="filterString" scope="instance" type="string"/>
      <property name="_clickableIncrementDate" scope="instance" type="Object"/>
      <property name="_visibleIncrementDate" scope="instance" type="Object"/>
      <property name="_visibleRangeDate" scope="instance" type="Object"/>
      <property name="_refDate" scope="instance" type="Object"/>
      <property name="_maxIncrement" scope="instance" type="Number"/>
      <property name="_highlighted_option" scope="instance" type="Object"/>
      <property name="_keyboardSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TimePicker.__Constraints" superclass="dojo.date.locale.__FormatOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.date.locale.__FormatOptions" scope="instance"/>
    </mixins>
    <properties>
      <property name="clickableIncrement" scope="instance" type="String"/>
      <property name="visibleIncrement" scope="instance" type="String"/>
      <property name="visibleRange" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._TimePicker.timeMenu">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._TimePicker.timeMenu.childNodes.0">
    <properties>
      <property name="index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Widget._deferredConnects">
    <properties>
      <property name="onClick" scope="instance" type="String"/>
      <property name="onDblClick" scope="instance" type="String"/>
      <property name="onKeyDown" scope="instance" type="String"/>
      <property name="onKeyPress" scope="instance" type="String"/>
      <property name="onKeyUp" scope="instance" type="String"/>
      <property name="onMouseMove" scope="instance" type="String"/>
      <property name="onMouseDown" scope="instance" type="String"/>
      <property name="onMouseOut" scope="instance" type="String"/>
      <property name="onMouseOver" scope="instance" type="String"/>
      <property name="onMouseLeave" scope="instance" type="String"/>
      <property name="onMouseEnter" scope="instance" type="String"/>
      <property name="onMouseUp" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._WidgetBase" superclass="dojo.Stateful">
    <methods>
      <method name="create" scope="instance">
        <description>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
	etc.), some of which of you'll want to override. See http://docs.dojocampus.org/dijit/_Widget
	for a discussion of the widget creation lifecycle.
	Of course, adventurous developers could override create entirely, but this should
	only be done as a last resort.</description>
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="optional"/>
        </parameters>
      </method>
      <method name="_applyAttributes" scope="instance">
        <description>Skips over blank/false attribute values, unless they were explicitly specified
	as parameters to the widget, since those are the default anyway,
	and setting tabIndex="" is different than not setting tabIndex at all.
	It processes the attributes in the attribute map first, and then
	it goes through and processes the attributes for the _setXXXAttr
	functions that have been specified</description>
      </method>
      <method name="_getSetterAttributes" scope="instance">
        <return-types>
          <return-type type="String[]"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance">
        <description>Most widgets will mixin `dijit._Templated`, which implements this
	method.</description>
      </method>
      <method name="postCreate" scope="instance">
        <description>Called after the DOM fragment has been created, but not necessarily
	added to the document.  Do not include any operations which rely on
	node dimensions or placement.</description>
      </method>
      <method name="startup" scope="instance">
        <description>Called after a widget and its children have been created and added to the page,
	and all related widgets have finished their create() cycle, up through postCreate().
	This is useful for composite widgets that need to control or layout sub-widgets.
	Many layout widgets can use this as a wiring phase.</description>
      </method>
      <method name="destroyRecursive" scope="instance">
        <description>This is the generic "destructor" function that all widget users
	should call to cleanly discard with a widget. Once a widget is
	destroyed, it is removed from the manager object.</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroyRendering" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
      <method name="_setClassAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setStyleAttr" scope="instance">
        <description>Determines which node to set the style on based on style setting
	in attributeMap.</description>
        <parameters>
          <parameter name="value" type="String||Object" usage="required"/>
        </parameters>
      </method>
      <method name="_attrToDom" scope="instance">
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <description>Get a named property from a widget. The property may
	potentially be retrieved via a getter method. If no getter is defined, this
	just retrieves the object's property.
	For example, if the widget has a properties "foo"
	and "bar" and a method named "_getFooAttr", calling:
		myWidget.get("foo");
	would be equivalent to writing:
		widget._getFooAttr();
	and:
		myWidget.get("bar");
	would be equivalent to writing:
		widget.bar;</description>
        <parameters>
          <parameter name="name" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a widget which may potentially be handled by a
	setter in the widget.
	For example, if the widget has a properties "foo"
	and "bar" and a method named "_setFooAttr", calling:
		myWidget.set("foo", "Howdy!");
	would be equivalent to writing:
		widget._setFooAttr("Howdy!");
	and:
		myWidget.set("bar", 3);
	would be equivalent to writing:
		widget.bar = 3;
	set() may also be called with a hash of name/value pairs, ex:
		myWidget.set({
			foo: "Howdy",
			bar: 3
		})
	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)</description>
        <parameters>
          <parameter name="name" type="The" usage="required"/>
          <parameter name="value" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttrNames" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>When a widget is cast to a string, this method will be used to generate the
	output. Currently, it does not implement any sort of reversible
	serialization.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDescendants" scope="instance">
        <return-types>
          <return-type type="dijit._Widget[]"/>
        </return-types>
      </method>
      <method name="getChildren" scope="instance">
        <return-types>
          <return-type type="dijit._Widget[]"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>Provide widget-specific analog to dojo.connect, except with the
	implicit use of this widget as the target object.
	Events connected with `this.connect` are disconnected upon
	destruction.</description>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String|Function" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
        <return-description>A handle that can be passed to `disconnect` in order to disconnect before
	the widget is destroyed.</return-description>
        <return-types>
          <return-type type="_Widget.Handle"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="handles" type="_Widget.Handle" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <description>Provide widget-specific analog to dojo.subscribe, except with the
	implicit use of this widget as the target object.</description>
        <parameters>
          <parameter name="topic" type="String" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLeftToRight" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="placeAt" scope="instance">
        <description>A convenience function provided in all _Widgets, providing a simple
	shorthand mechanism to put an existing (or newly created) Widget
	somewhere in the dom, and allow chaining.</description>
        <parameters>
          <parameter name="reference" type="String|DomNode|_Widget" usage="required"/>
          <parameter name="position" type="String|Int" usage="optional"/>
        </parameters>
        <return-description>dijit._Widget
	Provides a useful return of the newly created dijit._Widget instance so you
	can "chain" this function by instantiating, placing, then saving the return value
	to a variable.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.Stateful" scope="instance"/>
    </mixins>
    <properties>
      <property name="id" scope="instance" type="String"/>
      <property name="lang" scope="instance" type="String"/>
      <property name="dir" scope="instance" type="String"/>
      <property name="class" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String||Object"/>
      <property name="title" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="srcNodeRef" scope="instance" type="DomNode"/>
      <property name="domNode" scope="instance" type="DomNode"/>
      <property name="containerNode" scope="instance" type="DomNode"/>
      <property name="_started" scope="instance" type="Boolean"/>
      <property name="_blankGif" scope="instance" type="String"/>
      <property name="_connects" scope="instance" type="Array"/>
      <property name="_subscribes" scope="instance" type="Array"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="_created" scope="instance" type="Object"/>
      <property name="_beingDestroyed" scope="instance" type="Object"/>
      <property name="_destroyed" scope="instance" type="Object"/>
      <property name="_attrPairNames" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._WidgetBase.attributeMap">
    <properties>
      <property name="id" scope="instance" type="String"/>
      <property name="dir" scope="instance" type="String"/>
      <property name="lang" scope="instance" type="String"/>
      <property name="class" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._WidgetBase.constructor">
    <properties>
      <property name="_setterAttrs" scope="instance" type="Array"/>
      <property name="prototype" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._base">
    <properties>
      <property name="focus" scope="instance" type="Object"/>
      <property name="manager" scope="instance" type="Object"/>
      <property name="place" scope="instance" type="Object"/>
      <property name="popup" scope="instance" type="Object"/>
      <property name="scroll" scope="instance" type="Object"/>
      <property name="sniff" scope="instance" type="Object"/>
      <property name="typematic" scope="instance" type="Object"/>
      <property name="wai" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.WidgetSet">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="optional"/>
        </parameters>
        <return-description>Returns self, in order to allow for further chaining.</return-description>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="filter" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="byClass" scope="instance">
        <parameters>
          <parameter name="cls" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="toArray" scope="instance">
        <return-types>
          <return-type type="dijit._Widget[]"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="optional"/>
        </parameters>
        <return-description>A new array of the returned values.</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_hash" scope="instance" type="Object"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.registry">
    <description>Is an instance of `dijit.WidgetSet`</description>
    <properties>
      <property name="_hash" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.__Position">
    <methods/>
    <properties>
      <property name="y" scope="instance" type="Integer"/>
    </properties>
  </class>
  <class type="thix">
    <properties>
      <property name="x" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.__Rectangle">
    <methods/>
    <properties>
      <property name="x" scope="instance" type="Integer"/>
      <property name="y" scope="instance" type="Integer"/>
      <property name="width" scope="instance" type="Integer"/>
      <property name="height" scope="instance" type="Integer"/>
    </properties>
  </class>
  <class type="dijit.BackgroundIframe">
    <description>new dijit.BackgroundIframe(node)
	Makes a background iframe as a child of node, that fills
	area (and position) of node</description>
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="iframe" scope="instance" type="Object"/>
      <property name="_conn" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.BackgroundIframe.destroy">
    <methods/>
    <properties>
      <property name="_conn" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.popup">
    <methods>
      <method name="_createWrapper" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="moveOffScreen" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_stack" scope="instance" type="dijit._Widget[]"/>
      <property name="_beginZIndex" scope="instance" type="Number"/>
      <property name="_idGen" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.popup.__OpenArgs">
    <methods>
      <method name="onCancel" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onExecute" scope="instance"/>
    </methods>
    <properties>
      <property name="popup" scope="instance" type="Widget"/>
      <property name="parent" scope="instance" type="Widget"/>
      <property name="around" scope="instance" type="DomNode"/>
      <property name="x" scope="instance" type="Integer"/>
      <property name="y" scope="instance" type="Integer"/>
      <property name="orient" scope="instance" type="Object|String"/>
      <property name="padding" scope="instance" type="dijit.__Position"/>
    </properties>
  </class>
  <class type="dijit.popup.getTopPopup">
    <methods/>
    <properties>
      <property name="_stack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.popup.open">
    <methods/>
    <properties>
      <property name="_stack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.popup.close">
    <methods/>
    <properties>
      <property name="_stack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.typematic">
    <methods>
      <method name="addKeyListener" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="keyObject" type="Object" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>an array of dojo.connect handles</return-description>
      </method>
      <method name="addMouseListener" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>an array of dojo.connect handles</return-description>
      </method>
      <method name="addListener" scope="instance">
        <parameters>
          <parameter name="mouseNode" type="Node" usage="required"/>
          <parameter name="keyNode" type="Node" usage="required"/>
          <parameter name="keyObject" type="Object" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>an array of dojo.connect handles</return-description>
      </method>
    </methods>
  </class>
  <class type="dijit.typematic._fireEventAndReload">
    <methods/>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_currentTimeout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.typematic.trigger">
    <methods/>
    <properties>
      <property name="_initialDelay" scope="instance" type="Number"/>
      <property name="_subsequentDelay" scope="instance" type="Number"/>
      <property name="_minDelay" scope="instance" type="Number"/>
      <property name="_obj" scope="instance" type="Object"/>
      <property name="_evt" scope="instance" type="Object"/>
      <property name="_node" scope="instance" type="Object"/>
      <property name="_currentTimeout" scope="instance" type="Number"/>
      <property name="_count" scope="instance" type="Number"/>
      <property name="_callback" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.typematic.stop">
    <methods/>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_obj" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.wai">
    <methods>
      <method name="onload" scope="instance"/>
    </methods>
  </class>
  <class type="dijit._editor.RichText" superclass="dijit._Widget">
    <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features. It also encapsulates the differences
	of different js engines for various browsers.  Do not use this widget
	with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
	like &amp;lt;.  This can have unexpected behavior and lead to security issues
	such as scripting attacks.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features. It also encapsulates the differences
	of different js engines for various browsers.  Do not use this widget
	with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
	like &amp;lt;.  This can have unexpected behavior and lead to security issues
	such as scripting attacks.</description>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="setupDefaultShortcuts" scope="instance">
        <description>Overwrite this to setup your own handlers. The default
	implementation does not use Editor commands, but directly
	executes the builtin commands within the underlying browser
	support.</description>
      </method>
      <method name="_localizeEditorCommands" scope="instance"/>
      <method name="open" scope="instance">
        <description>Sets up the editing area asynchronously. This will result in
	the creation and replacement with an iframe.</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_getIframeDocTxt" scope="instance"/>
      <method name="_applyEditingAreaStyleSheets" scope="instance"/>
      <method name="addStyleSheet" scope="instance">
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="removeStyleSheet" scope="instance">
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="this method requires init to be complete"/>
          <return-type type="! _disabledOK"/>
        </return-types>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisableSpellCheckAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addKeyHandler" scope="instance">
        <description>The key argument should be in lowercase if it is a letter character</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="ctrl" type="Boolean" usage="required"/>
          <parameter name="shift" type="Boolean" usage="required"/>
          <parameter name="handler" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onIEMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="blur" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="onDisplayChanged" scope="instance">
        <description>If you don't want to have update too often,
	onNormalizedDisplayChanged should be used instead</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onNormalizedDisplayChanged" scope="instance">
        <description>If something needs to happen immediately after a
	user change, please use onDisplayChanged instead.</description>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeCommand" scope="instance">
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="argument" type="Anything" usage="optional"/>
        </parameters>
      </method>
      <method name="queryCommandAvailable" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_queryCommandAvailable" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="execCommand" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required"/>
          <parameter name="argument" type="An" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandState" scope="instance">
        <parameters>
          <parameter name="command" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandValue" scope="instance">
        <parameters>
          <parameter name="command" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sCall" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeCursorAtStart" scope="instance"/>
      <method name="placeCursorAtEnd" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="nonDestructive" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="replaceValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFilterContent" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preDomFilterContent" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_postFilterContent" scope="instance">
        <description>post-filtering allows plug-ins and users to specify any number
	of transforms over the editor's content, enabling many common
	use-cases such as transforming absolute to relative URLs (and
	vice-versa), ensuring conformance with a particular DTD, etc.
	The filters are registered in the contentDomPostFilters and
	contentPostFilters arrays. Each item in the
	contentDomPostFilters array is a function which takes a DOM
	Node or array of nodes as its only argument and returns the
	same. It is then passed down the chain for further filtering.
	The contentPostFilters array behaves the same way, except each
	member operates on strings. Together, the DOM and string-based
	filtering allow the full range of post-processing that should
	be necessaray to enable even the most agressive of post-editing
	conversions to take place.
	If nonDestructive is set to "true", the nodes are cloned before
	filtering proceeds to avoid potentially destructive transforms
	to the content which may still needed to be edited further.
	Once DOM filtering has taken place, the serialized version of
	the DOM which is passed is run through each of the
	contentPostFilters functions.</description>
        <parameters>
          <parameter name="dom" type="DomNode|DomNode[]|String" usage="optional"/>
          <parameter name="nonDestructive" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_saveContent" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="escapeXml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getNodeHtml" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getNodeChildrenHtml" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="save" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_removeMozBogus" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_removeWebkitBogus" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_normalizeFontStyle" scope="instance">
        <description>Moz can not handle strong/em tags correctly, so to help
	mozilla and also to normalize output, convert them to 'b' and 'i'.
	Note the IE generates 'strong' and 'em' rather than 'b' and 'i'</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFixUrlAttributes" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_inserthorizontalruleImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required"/>
        </parameters>
      </method>
      <method name="_unlinkImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required"/>
        </parameters>
      </method>
      <method name="_hilitecolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required"/>
        </parameters>
      </method>
      <method name="_backcolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required"/>
        </parameters>
      </method>
      <method name="_forecolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required"/>
        </parameters>
      </method>
      <method name="_inserthtmlImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_boldImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required"/>
        </parameters>
      </method>
      <method name="_italicImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required"/>
        </parameters>
      </method>
      <method name="_underlineImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required"/>
        </parameters>
      </method>
      <method name="_strikethroughImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required"/>
        </parameters>
      </method>
      <method name="getHeaderHeight" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getFooterHeight" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getNodeChildrenHeight" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_isNodeEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
          <parameter name="startOffset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeStartingRangeFromRange" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
          <parameter name="range" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_adaptIESelection" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="inheritWidth" scope="instance" type="Boolean"/>
      <property name="focusOnLoad" scope="instance" type="Boolean"/>
      <property name="name" scope="instance" type="String"/>
      <property name="styleSheets" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
      <property name="minHeight" scope="instance" type="String"/>
      <property name="isClosed" scope="instance" type="Boolean"/>
      <property name="isLoaded" scope="instance" type="Boolean"/>
      <property name="_SEPARATOR" scope="instance" type="String"/>
      <property name="_NAME_CONTENT_SEP" scope="instance" type="String"/>
      <property name="onLoadDeferred" scope="instance-prototype" type="dojo.Deferred"/>
      <property name="isTabIndent" scope="instance" type="Boolean"/>
      <property name="disableSpellCheck" scope="instance" type="Boolean"/>
      <property name="contentPreFilters" scope="instance-prototype" type="Function(String)[]"/>
      <property name="contentPostFilters" scope="instance-prototype" type="Array"/>
      <property name="events" scope="instance-prototype" type="String[]"/>
      <property name="captureEvents" scope="instance" type="String[]"/>
      <property name="_editorCommandsLocalized" scope="instance" type="Object"/>
      <property name="_oldHeight" scope="instance" type="Object"/>
      <property name="_oldWidth" scope="instance" type="Object"/>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
      <property name="editingArea" scope="instance" type="Object"/>
      <property name="footer" scope="instance" type="Object"/>
      <property name="editorObject" scope="instance" type="Object"/>
      <property name="_iframeSrc" scope="instance" type="Object"/>
      <property name="_local2NativeFormatNames" scope="instance" type="Object"/>
      <property name="_native2LocalFormatNames" scope="instance" type="Object"/>
      <property name="_cursorToStart" scope="instance" type="Object"/>
      <property name="editingAreaStyleSheets" scope="instance-prototype" type="Array"/>
      <property name="disabled" scope="instance" type="Boolean"/>
      <property name="_disabledOK" scope="instance" type="Object"/>
      <property name="_iframeRegHandle" scope="instance" type="Object"/>
      <property name="tabStop" scope="instance" type="Object"/>
      <property name="focusNode" scope="instance" type="Object"/>
      <property name="_webkitListener" scope="instance" type="Object"/>
      <property name="_onKeyHitch" scope="instance" type="Object"/>
      <property name="updateInterval" scope="instance" type="Number"/>
      <property name="_updateTimer" scope="instance" type="Object"/>
      <property name="_updateHandler" scope="instance" type="Object"/>
      <property name="_qcaCache" scope="instance" type="Object"/>
      <property name="__overflow" scope="instance" type="Object"/>
      <property name="contentDomPreFilters" scope="instance" type="Array"/>
      <property name="contentDomPostFilters" scope="instance" type="Array"/>
      <property name="_keyHandlers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText._mozSettingProps">
    <properties>
      <property name="styleWithCSS" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.editNode">
    <properties>
      <property name="unselectable" scope="instance" type="String"/>
      <property name="contentEditable" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.document">
    <properties>
      <property name="designMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.window">
    <properties>
      <property name="__registeredWindow" scope="instance" type="Object"/>
      <property name="_frameElement" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.iframe">
    <properties>
      <property name="onfocus" scope="instance" type="Object"/>
      <property name="_loadFunc" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.editNode.style">
    <properties>
      <property name="zoom" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.textarea">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.textarea.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="overflow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor._Plugin.button.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins"/>
  <class type="dijit._editor.plugins.AlwaysShowToolbar" superclass="dijit._editor._Plugin">
    <description>Specify this in extraPlugins (or plugins) parameter and also set
	height to "".</description>
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateHeight" scope="instance">
        <return-types>
          <return-type type="prevent setting height to 0"/>
        </return-types>
      </method>
      <method name="globalOnScrollHandler" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_handleScroll" scope="instance" type="Boolean"/>
      <property name="_lastHeight" scope="instance" type="Integer"/>
      <property name="_scrollSetUp" scope="instance" type="Object"/>
      <property name="_scrollThreshold" scope="instance" type="Object"/>
      <property name="_IEOriginalPos" scope="instance" type="Object"/>
      <property name="_fixEnabled" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor"/>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.header"/>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.iframe.style">
    <properties>
      <property name="marginTop" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.header.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="position" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="zIndex" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.EnterKeyHandling" superclass="dijit._editor._Plugin">
    <description>This plugin has three modes:
	* blockModeForEnter=BR
	* blockModeForEnter=DIV
	* blockModeForEnter=P
	In blockModeForEnter=P, the ENTER key starts a new
	paragraph, and shift-ENTER starts a new line in the current paragraph.
	For example, the input:
		first paragraph &lt;shift-ENTER&gt;
		second line of first paragraph &lt;ENTER&gt;
		second paragraph
	will generate:
		&lt;p&gt;
			first paragraph
			&lt;br/&gt;
			second line of first paragraph
		&lt;/p&gt;
		&lt;p&gt;
			second paragraph
		&lt;/p&gt;
	In BR and DIV mode, the ENTER key conceptually goes to a new line in the
	current paragraph, and users conceptually create a new paragraph by pressing ENTER twice.
	For example, if the user enters text into an editor like this:
			one &lt;ENTER&gt;
			two &lt;ENTER&gt;
			three &lt;ENTER&gt;
			&lt;ENTER&gt;
			four &lt;ENTER&gt;
			five &lt;ENTER&gt;
			six &lt;ENTER&gt;
	It will appear on the screen as two 'paragraphs' of three lines each.  Markupwise, this generates:
	BR:
			one&lt;br/&gt;
			two&lt;br/&gt;
			three&lt;br/&gt;
			&lt;br/&gt;
			four&lt;br/&gt;
			five&lt;br/&gt;
			six&lt;br/&gt;
	DIV:
			&lt;div&gt;one&lt;/div&gt;
			&lt;div&gt;two&lt;/div&gt;
			&lt;div&gt;three&lt;/div&gt;
			&lt;div&gt;&amp;nbsp;&lt;/div&gt;
			&lt;div&gt;four&lt;/div&gt;
			&lt;div&gt;five&lt;/div&gt;
			&lt;div&gt;six&lt;/div&gt;</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleEnterKey" scope="instance">
        <description>Manually handle enter key event to make the behavior consistent across
	all supported browsers. See class description for details.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="let browser handle"/>
        </return-types>
      </method>
      <method name="_adjustNodeAndOffset" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="removeTrailingBr" scope="instance">
        <parameters>
          <parameter name="container" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="blockNodeForEnter" scope="instance" type="String"/>
      <property name="_checkListLater" scope="instance" type="bool"/>
      <property name="bogusHtmlContent" scope="instance" type="String"/>
      <property name="blockNodes" scope="instance" type="Regex"/>
      <property name="_pressedEnterInBlock" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.EnterKeyHandling.editor">
    <properties>
      <property name="customUndo" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontDropDown" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object|String" usage="required"/>
          <parameter name="priorityChange" type="Optional" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="boolean"/>
      <property name="plainText" scope="instance" type="boolean"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="strings" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="selectId" scope="instance" type="String"/>
      <property name="disabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontDropDown.select">
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontNameDropDown" superclass="dijit._editor.plugins._FontDropDown">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins._FontDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="generic" scope="instance" type="Boolean"/>
      <property name="command" scope="instance" type="String"/>
      <property name="values" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontSizeDropDown" superclass="dijit._editor.plugins._FontDropDown">
    <methods>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins._FontDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="command" scope="instance" type="String"/>
      <property name="values" scope="instance" type="Number[]"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FormatBlockDropDown" superclass="dijit._editor.plugins._FontDropDown">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_execCommand" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
          <parameter name="command" type="Object" usage="required"/>
          <parameter name="choice" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeFormat" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins._FontDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="command" scope="instance" type="String"/>
      <property name="values" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FontChoice" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* fontName
			Provides a drop down to select from a list of font names
	* fontSize
			Provides a drop down to select from a list of font sizes
	* formatBlock
			Provides a drop down to select from a list of block styles
	which can easily be added to an editor by including one or more of the above commands
	in the `plugins` attribute as follows:
		plugins="['fontName','fontSize',...]"
	It is possible to override the default dropdown list by providing an Array for the `custom` property when
	instantiating this plugin, e.g.
		plugins="[{name:'dijit._editor.plugins.FontChoice', command:'fontName', custom:['Verdana','Myriad','Garamond']},...]"
	Alternatively, for `fontName` only, `generic:true` may be specified to provide a dropdown with
	[CSS generic font families](http://www.w3.org/TR/REC-CSS2/fonts.html#generic-font-families)
	Note that the editor is often unable to properly handle font styling information defined outside
	the context of the current editor instance, such as pre-populated HTML.</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="booleam"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FontChoice.params">
    <properties>
      <property name="values" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen" superclass="dijit._editor._Plugin">
    <methods>
      <method name="toggle" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_containFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_resizeEditor" scope="instance"/>
      <method name="_getAltViewNode" scope="instance"/>
      <method name="_setFullScreen" scope="instance">
        <parameters>
          <parameter name="full" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="zIndex" scope="instance" type="Number"/>
      <property name="_origState" scope="instance" type="Object"/>
      <property name="_origiFrameState" scope="instance" type="Object"/>
      <property name="_resizeHandle" scope="instance" type="Object"/>
      <property name="isFullscreen" scope="instance" type="boolean"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_editorResizeHolder" scope="instance" type="Object"/>
      <property name="_oldOverflow" scope="instance" type="String"/>
      <property name="_oldBodyParentOverflow" scope="instance" type="String"/>
      <property name="_resizeHandle2" scope="instance" type="Object"/>
      <property name="_rst" scope="instance" type="Object"/>
      <property name="_resizer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen.editor">
    <methods>
      <method name="resize" scope="instance"/>
    </methods>
    <properties>
      <property name="_fullscreen_oldOnKeyDown" scope="instance" type="Object"/>
      <property name="onKeyDown" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="iframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen.editor.toolbar">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.LinkDialog" superclass="dijit._editor._Plugin">
    <description>The command provided by this plugin is:
	* createLink</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="_checkAndFixInput" scope="instance"/>
      <method name="_connectTagEvents" scope="instance"/>
      <method name="_isValid" scope="instance"/>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="staticPanel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseDialog" scope="instance"/>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="a" type="The" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object;"/>
        </return-types>
      </method>
      <method name="_onOpenDialog" scope="instance"/>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="urlRegExp" scope="instance" type="String"/>
      <property name="emailRegExp" scope="instance" type="String"/>
      <property name="htmlTemplate" scope="instance" type="String"/>
      <property name="tag" scope="instance" type="String"/>
      <property name="_hostRxp" scope="instance" type="Object"/>
      <property name="_userAtRxp" scope="instance" type="Object"/>
      <property name="linkDialogTemplate" scope="instance" type="String"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Object"/>
      <property name="_textInput" scope="instance" type="Object"/>
      <property name="_setButton" scope="instance" type="Object"/>
      <property name="_urlRegExp" scope="instance" type="Object"/>
      <property name="_emailRegExp" scope="instance" type="Object"/>
      <property name="_delayedCheck" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.LinkDialog._urlInput">
    <properties>
      <property name="isValid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ImgLinkDialog" superclass="dijit._editor.plugins.LinkDialog">
    <description>The command provided by this plugin is:
	* insertImage</description>
    <methods>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="img" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object;"/>
        </return-types>
      </method>
      <method name="_isValid" scope="instance"/>
      <method name="_connectTagEvents" scope="instance"/>
      <method name="_selectTag" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins.LinkDialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="linkDialogTemplate" scope="instance" type="String"/>
      <property name="htmlTemplate" scope="instance" type="String"/>
      <property name="tag" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.NewPage" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_newPage" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="content" scope="instance" type="String"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.Print" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_print" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.Print.editor">
    <properties>
      <property name="iframe" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TabIndent" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="String"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TextColor" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="updateState" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="useDefaultCommand" scope="instance" type="Boolean"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ToggleDir" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="_setRtl" scope="instance">
        <parameters>
          <parameter name="rtl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="command" scope="instance" type="String"/>
      <property name="buttonClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource" superclass="dijit._editor._Plugin">
    <methods>
      <method name="toggle" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="_showSource" scope="instance">
        <parameters>
          <parameter name="source" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_resize" scope="instance"/>
      <method name="_createSourceView" scope="instance"/>
      <method name="_stripScripts" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_stripComments" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_stripIFrames" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_filter" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setSourceAreaCaret" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="stripScripts" scope="instance" type="Boolean"/>
      <property name="stripComments" scope="instance" type="Boolean"/>
      <property name="stripIFrames" scope="instance" type="Object"/>
      <property name="readOnly" scope="instance" type="Boolean"/>
      <property name="_vsFocused" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_ieFixNode" scope="instance" type="Object"/>
      <property name="_sourceShown" scope="instance" type="Object"/>
      <property name="_pluginList" scope="instance" type="Array"/>
      <property name="_resizeHandle" scope="instance" type="Object"/>
      <property name="_readOnly" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource.editor">
    <methods>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
    </methods>
    <properties>
      <property name="_plugins" scope="instance" type="Object"/>
      <property name="_sourceQueryCommandEnabled" scope="instance" type="Object"/>
      <property name="__oldGetValue" scope="instance" type="Object"/>
      <property name="getValue" scope="instance" type="Object"/>
      <property name="_viewsource_oldFocus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource._fsPlugin">
    <methods>
      <method name="_getAltViewNode" scope="instance"/>
    </methods>
    <properties>
      <property name="_viewsource_getAltViewNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource.sourceArea">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range">
    <methods>
      <method name="getIndex" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="index" type="Array" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="terminate dojo.every"/>
          <return-type type="carry on the every loop"/>
        </return-types>
      </method>
      <method name="getCommonAncestor" scope="instance">
        <parameters>
          <parameter name="n1" type="Object" usage="required"/>
          <parameter name="n2" type="Object" usage="required"/>
          <parameter name="root" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAncestor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getBlockAncestor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="atBeginningOfContainer" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="atEndOfContainer" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="adjacentNoneTextNode" scope="instance">
        <parameters>
          <parameter name="startnode" type="Object" usage="required"/>
          <parameter name="next" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="win" type="Window" usage="optional"/>
        </parameters>
      </method>
      <method name="getSelection" scope="instance">
        <parameters>
          <parameter name="win" type="Window" usage="required"/>
          <parameter name="ignoreUpdate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="BlockTagNames" scope="instance" type="RegExp"/>
      <property name="_w3c" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.W3CRange">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_updateInternal" scope="instance"/>
      <method name="setStart" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEnd" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartAfter" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartBefore" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndAfter" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndBefore" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="instance">
        <parameters>
          <parameter name="what" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="ext" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIERange" scope="instance"/>
      <method name="getBookmark" scope="instance">
        <parameters>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_select" scope="instance"/>
      <method name="deleteContents" scope="instance"/>
      <method name="cloneRange" scope="instance"/>
      <method name="detach" scope="instance"/>
    </methods>
    <properties>
      <property name="commonAncestorContainer" scope="instance-prototype" type="Object"/>
      <property name="collapsed" scope="instance-prototype" type="Object"/>
      <property name="startContainer" scope="instance-prototype" type="Object"/>
      <property name="startOffset" scope="instance-prototype" type="Number"/>
      <property name="endContainer" scope="instance-prototype" type="Object"/>
      <property name="endOffset" scope="instance-prototype" type="Number"/>
      <property name="_body" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.ie">
    <methods>
      <method name="decomposeControlRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEndPoint" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndPoint" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="container" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decomposeTextRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="startContainer" type="Object" usage="required"/>
          <parameter name="startOffset" type="Object" usage="required"/>
          <parameter name="endContainer" type="Object" usage="required"/>
          <parameter name="endOffset" type="Object" usage="required"/>
          <parameter name="collapsed" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cachedSelection" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.ie.selection">
    <methods>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="internal" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="removeAllRanges" scope="instance"/>
      <method name="getRangeAt" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentSelection" scope="instance"/>
    </methods>
    <properties>
      <property name="_ranges" scope="instance" type="Array"/>
      <property name="rangeCount" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit._editor.selection">
    <methods>
      <method name="getType" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedText" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedHtml" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedElement" scope="instance"/>
      <method name="getParentElement" scope="instance"/>
      <method name="hasAncestorElement" scope="instance">
        <parameters>
          <parameter name="tagName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getAncestorElement" scope="instance">
        <parameters>
          <parameter name="tagName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="isTag" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="tags" type="String[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getParentOfType" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="tags" type="String[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="collapse" scope="instance">
        <parameters>
          <parameter name="beginning" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <return-types>
          <return-type type="Selection"/>
        </return-types>
      </method>
      <method name="selectElementChildren" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="nochangefocus" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="selectElement" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="nochangefocus" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="inSelection" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dijit._tree">
    <properties>
      <property name="dndSource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form">
    <properties>
      <property name="Slider" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button" superclass="dijit.form._FormWidget">
    <description>Buttons can display a label, an icon, or both.
	A label should always be specified (through innerHTML) or the label
	attribute.  It can be hidden via showLabel=false.</description>
    <methods>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="user click actions"/>
        </return-types>
      </method>
      <method name="_onButtonClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setShowLabelAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_clicked" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <description>Set the label (text) of the button; takes an HTML string.</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setIconClassAttr" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="HTML"/>
      <property name="showLabel" scope="instance" type="Boolean"/>
      <property name="iconClass" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.DropDownButton" superclass="dijit.form.Button">
    <methods>
      <method name="_fillContent" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="isLoaded" scope="instance"/>
      <method name="loadDropDown" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="dropDownContainer" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboButton" superclass="dijit.form.DropDownButton">
    <methods>
      <method name="_onButtonKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.DropDownButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="optionsTitle" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_focusedNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboButton.cssStateNodes">
    <properties>
      <property name="buttonNode" scope="instance" type="String"/>
      <property name="titleNode" scope="instance" type="String"/>
      <property name="_popupStateNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.ToggleButton" superclass="dijit.form.Button">
    <methods>
      <method name="_clicked" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="setChecked" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="checked" scope="instance" type="Boolean"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form.CheckBox" superclass="dijit.form.ToggleButton">
    <description>User interacts with real html inputs.
	On onclick (which occurs by mouse click, space-bar, or
	using the arrow keys to switch the selected radio button),
	we update the state of the checkbox/radio.
	There are two modes:
	1. High contrast mode
	2. Normal mode
	In case 1, the regular html inputs are shown and used by the user.
	In case 2, the regular html inputs are invisible but still used by
	the user. They are turned quasi-invisible and overlay the background-image.</description>
    <methods>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>During initialization, just saves as attribute to the &lt;input type=checkbox&gt;.
	After initialization,
	when passed a boolean, controls whether or not the CheckBox is checked.
	If passed a string, changes the value attribute of the CheckBox (the one
	specified as "value" when the CheckBox was constructed (ex: &lt;input
	dojoType="dijit.CheckBox" value="chicken"&gt;)</description>
        <parameters>
          <parameter name="newValue" type="String|Boolean" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance">
        <description>If the CheckBox is checked, returns the value attribute.
	Otherwise returns false.</description>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_onFocus" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ToggleButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
      <property name="readOnly" scope="instance" type="Boolean"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_setLabelAttr" scope="instance" type="Object"/>
      <property name="checkedAttrSetting" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form.RadioButton" superclass="dijit.form.CheckBox">
    <methods>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.CheckBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxDataStore" superclass="dojo.data.util.simpleFetch">
    <description>Provides a store for inlined data like:
		&lt;select&gt;
			&lt;option value="AL"&gt;Alabama&lt;/option&gt;
			...
	Actually. just implements the subset of dojo.data.Read/Notification
	needed for ComboBox and FilteringSelect to work.
	Note that an item is just a pointer to the &lt;option&gt; DomNode.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="root" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <description>Given arguments like:
			{identity: "CA", onItem: function(item){...}
	Call `onItem()` with the DOM node `&lt;option value="CA"&gt;California&lt;/option&gt;`</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchSelectedItem" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.form.ComboBoxMixin" superclass="dijit._HasDropDown">
    <description>All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.</description>
    <methods>
      <method name="_getCaretPos" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setCaretPos" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="location" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_abortQuery" scope="instance"/>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="throw out weird key combinations and spurious events"/>
        </return-types>
      </method>
      <method name="_autoCompleteText" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_openResultList" scope="instance">
        <description>1. generates drop-down list and calls _showResultList() to display it
	2. if this result list is from user pressing "more choices"/"previous choices"
	then tell screen reader to announce new option</description>
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showResultList" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="closeDropDown" scope="instance"/>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_setItemAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('item', value)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_announceOption" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_selectOption" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearchAll" scope="instance"/>
      <method name="_startSearchFromInput" scope="instance"/>
      <method name="_getQueryString" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearch" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setMaxOptions" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueField" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setHasDownArrowAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenuLabelFromItem" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="doHighlight" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="find" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_escapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="reset" scope="instance"/>
      <method name="labelFunc" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="store" type="dojo.data.store" usage="required"/>
        </parameters>
        <return-description>The label that the ComboBox should display</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="item" scope="instance" type="Object"/>
      <property name="pageSize" scope="instance" type="Integer"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="fetchProperties" scope="instance-prototype" type="Object"/>
      <property name="query" scope="instance-prototype" type="Object"/>
      <property name="autoComplete" scope="instance" type="Boolean"/>
      <property name="highlightMatch" scope="instance" type="String"/>
      <property name="searchDelay" scope="instance" type="Integer"/>
      <property name="searchAttr" scope="instance" type="String"/>
      <property name="labelAttr" scope="instance" type="String"/>
      <property name="labelType" scope="instance" type="String"/>
      <property name="queryExpr" scope="instance" type="String"/>
      <property name="ignoreCase" scope="instance" type="Boolean"/>
      <property name="hasDownArrow" scope="instance" type="Boolean"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="dropDownClass" scope="instance" type="String"/>
      <property name="maxHeight" scope="instance" type="Number"/>
      <property name="searchTimer" scope="instance" type="Object"/>
      <property name="_fetchHandle" scope="instance" type="Object"/>
      <property name="_prev_key_backspace" scope="instance" type="Object"/>
      <property name="_lastQuery" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="String"/>
      <property name="_lastInput" scope="instance" type="Object"/>
      <property name="_maxOptions" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin.cssStateNodes">
    <properties>
      <property name="_buttonNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin.focusNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin.dropDown">
    <properties>
      <property name="_highlighted_option" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin._helperSpan">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin._buttonNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPage" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance"/>
      <method name="_createOption" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="labelFunc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOptions" scope="instance">
        <parameters>
          <parameter name="results" type="Array" usage="required"/>
          <parameter name="dataObject" type="dojo.data" usage="required"/>
          <parameter name="labelFunc" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="clearResultList" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOut" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusOptionNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_blurOptionNode" scope="instance"/>
      <method name="_highlightNextOption" scope="instance"/>
      <method name="highlightFirstOption" scope="instance"/>
      <method name="highlightLastOption" scope="instance"/>
      <method name="_highlightPrevOption" scope="instance"/>
      <method name="_page" scope="instance">
        <parameters>
          <parameter name="up" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="pageUp" scope="instance"/>
      <method name="pageDown" scope="instance"/>
      <method name="getHighlightedOption" scope="instance"/>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_messages" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.previousButton">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.nextButton">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.previousButton.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.nextButton.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.domNode">
    <properties>
      <property name="lastChild" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu._highlighted_option">
    <properties>
      <property name="nextSibling" scope="instance" type="Object"/>
      <property name="previousSibling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.domNode.firstChild">
    <properties>
      <property name="nextSibling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBox" superclass="dijit.form.ValidationTextBox">
    <description>The drop down box's values are populated from an class called
	a data provider, which returns a list of values based on the characters
	that the user has typed into the input box.
	If OPTION tags are used as the data provider via markup,
	then the OPTION tag's child text node is used as the widget value
	when selected.  The OPTION tag's value attribute is ignored.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	Some of the options to the ComboBox are actually arguments to the data
	provider.</description>
    <methods>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the select.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._ComboBoxDataStore.root">
    <properties>
      <property name="selectedIndex" scope="instance" type="Object"/>
      <property name="firstChild" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.CurrencyTextBox" superclass="dijit.form.NumberTextBox">
    <description>CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
	extra features related to currency:
	1. After specifying the currency type (american dollars, euros, etc.) it automatically
	sets parse/format options such as how many decimal places to show.
	2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
	but erased during editing, so that the user can just enter a plain number.</description>
    <methods>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="currency" scope="instance" type="String"/>
      <property name="constraints" scope="instance" type="dijit.form.CurrencyTextBox.__Constraints"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_formatter" scope="instance" type="Object"/>
      <property name="_parser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.CurrencyTextBox.__Constraints" superclass="dijit.form.NumberTextBox.__Constraints">
    <description>Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	In general developers won't need to set this parameter</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.currency.__FormatOptions.prototype" scope="instance"/>
      <mixin type="dojo.currency.__ParseOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBox.__Constraints" scope="instance"/>
      <mixin type="dojo.currency.__FormatOptions" scope="instance"/>
      <mixin type="dojo.currency.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.DateTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="popupClass" scope="instance" type="String"/>
      <property name="_selector" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Date"/>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect" superclass="dijit.form.MappedTextBox">
    <description>An enhanced version of the HTML SELECT tag, populated dynamically. It works
	very nicely with very large data sets because it can load and page data as needed.
	It also resembles ComboBox, but does not allow values outside of the provided ones.
	If OPTION tags are used as the data provider via markup, then the
	OPTION tag's child text node is used as the displayed value when selected
	while the OPTION tag's value attribute is used as the widget value on form submit.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	Similar features:
	- There is a drop down list of possible values.
	- You can only enter a value from the drop down list.  (You can't
	enter an arbitrary value.)
	- The value submitted with the form is the hidden value (ex: CA),
	not the displayed value a.k.a. label (ex: California)
	Enhancements over plain HTML version:
	- If you type in some text then it will filter down the list of
	possible values in the drop down list.
	- List can be specified either as a static list or via a javascript
	function (that can get the list from a server)</description>
    <methods>
      <method name="_isValidSubset" scope="instance"/>
      <method name="isValid" scope="instance">
        <return-types>
          <return-type type="#5974"/>
        </return-types>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_callbackSetLabel" scope="instance">
        <parameters>
          <parameter name="result" type="Array" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_openResultList" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_getValueField" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the select.
	Also sets the label to the corresponding value by reverse lookup.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setItemAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('item', value)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getDisplayQueryString" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <description>Sets textbox to display label. Also performs reverse lookup
	to set the hidden value.
	Doesn't work as expected when the FilteringSelect has a custom labelFunc(), since in that case
	it's impossible to do a reverse lookup (from label --&gt; item) without a full data store scan.
	App must call set("displayedValue", ...) with the intended item.searchAttr, rather than
	labelFunc(item).</description>
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="undo" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.MappedTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="Boolean"/>
      <property name="_lastDisplayedValue" scope="instance" type="String"/>
      <property name="_lastQuery" scope="instance" type="Object"/>
      <property name="_fetchHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect.valueNode">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Form" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="execute" scope="instance">
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onExecute" scope="instance"/>
      <method name="_setEncTypeAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
      <method name="onReset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_onReset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSubmit" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSubmit" scope="instance">
        <description>This method is intended to be over-ridden, but by default it checks and
	returns the validity of form elements. When the `submit`
	method is called programmatically, the return value from
	`onSubmit` is used to compute whether or not submission
	should proceed</description>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="submit" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="action" scope="instance" type="String"/>
      <property name="method" scope="instance" type="String"/>
      <property name="encType" scope="instance" type="String"/>
      <property name="accept-charset" scope="instance" type="String"/>
      <property name="accept" scope="instance" type="String"/>
      <property name="target" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="nameAttrSetting" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Form.domNode">
    <properties>
      <property name="encoding" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRule" superclass="dijit._Widget">
    <methods>
      <method name="_genHTML" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="ndx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="count" scope="instance" type="Integer"/>
      <property name="container" scope="instance" type="String"/>
      <property name="ruleStyle" scope="instance" type="String"/>
      <property name="_positionPrefix" scope="instance" type="String"/>
      <property name="_positionSuffix" scope="instance" type="String"/>
      <property name="_suffix" scope="instance" type="String"/>
      <property name="_isHorizontal" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRule.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels" superclass="dijit.form.HorizontalRule">
    <methods>
      <method name="_calcPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_genHTML" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="ndx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabels" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRule" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="labelStyle" scope="instance" type="String"/>
      <property name="labels" scope="instance" type="String[]"/>
      <property name="numericMargin" scope="instance" type="Integer"/>
      <property name="minimum" scope="instance" type="Number"/>
      <property name="maximum" scope="instance" type="Number"/>
      <property name="_positionPrefix" scope="instance" type="String"/>
      <property name="_labelPrefix" scope="instance" type="String"/>
      <property name="_suffix" scope="instance" type="String"/>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels.constraints">
    <properties>
      <property name="pattern" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels.srcNodeRef">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="_onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isReversed" scope="instance"/>
      <method name="_onBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_bumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_onClkBumper" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="instance"/>
      <method name="_onClkDecBumper" scope="instance"/>
      <method name="decrement" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="increment" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="_typematicCallback" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="button" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Number"/>
      <property name="showButtons" scope="instance" type="Boolean"/>
      <property name="minimum" scope="instance" type="Integer"/>
      <property name="maximum" scope="instance" type="Integer"/>
      <property name="discreteValues" scope="instance" type="Integer"/>
      <property name="pageIncrement" scope="instance" type="Integer"/>
      <property name="clickSelect" scope="instance" type="Boolean"/>
      <property name="slideDuration" scope="instance" type="Number"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_mousePixelCoord" scope="instance" type="String"/>
      <property name="_pixelCount" scope="instance" type="String"/>
      <property name="_startingPixelCoord" scope="instance" type="String"/>
      <property name="_startingPixelCount" scope="instance" type="String"/>
      <property name="_handleOffsetCoord" scope="instance" type="String"/>
      <property name="_progressPixelSize" scope="instance" type="String"/>
      <property name="_inProgressAnim" scope="instance" type="Object"/>
      <property name="_movable" scope="instance" type="Object"/>
      <property name="_supportingWidgets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.cssStateNodes">
    <properties>
      <property name="incrementButton" scope="instance" type="String"/>
      <property name="decrementButton" scope="instance" type="String"/>
      <property name="focusNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.incrementButton.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.decrementButton.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form._SliderMover" superclass="dojo.dnd.Mover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Mover" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._SliderMover.widget">
    <properties>
      <property name="_abspos" scope="instance" type="Object"/>
      <property name="_setPixelValue_" scope="instance" type="Object"/>
      <property name="_isReversed_" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.MappedTextBox" superclass="dijit.form.ValidationTextBox">
    <description>The visible display may
	be locale-dependent and interactive.  The value sent to the server is stored in a hidden
	input field which uses the `name` attribute declared by the original widget.  That value sent
	to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
	locale-neutral.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="validate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="nameAttrSetting" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.MultiSelect" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="addSelected" scope="instance">
        <parameters>
          <parameter name="select" type="dijit.form.MultiSelect" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getValueAttr" scope="instance">
        <description>Returns an array of the selected options' values.</description>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Set the value(s) of this Select based on passed values</description>
        <parameters>
          <parameter name="values" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="invertSelection" scope="instance">
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onChange" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="size" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
      <property name="multiple" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.NumberSpinner" superclass="dijit.form._Spinner">
    <description>A `dijit.form.NumberTextBox` extension to provide keyboard accessible value selection
	as well as icons for spinning direction. When using the keyboard, the typematic rules
	apply, meaning holding the key will gradually increase or decrease the value and
	accelerate.</description>
    <methods>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._Spinner" scope="instance"/>
      <mixin type="dijit.form.NumberTextBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberSpinner.constraints">
    <properties>
      <property name="min" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBox" superclass="dijit.form.RangeBoundTextBox">
    <description>NumberTextBox is a textbox for entering and displaying numbers, supporting
	the following main features:
	1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
	a number rather than a random string)
	2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
	depending on locale).
	3. Separate modes for editing the value and displaying it, specifically that
	the thousands separator character (typically comma) disappears when editing
	but reappears after the field is blurred.
	4. Formatting and constraints regarding the number of places (digits after the decimal point)
	allowed on input, and number of places displayed when blurred (see `constraints` parameter).</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
      <mixin type="dijit.form.NumberTextBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBox.__Constraints" superclass="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.number.__FormatOptions.prototype" scope="instance"/>
      <mixin type="dojo.number.__ParseOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox.__Constraints" scope="instance"/>
      <mixin type="dojo.number.__FormatOptions" scope="instance"/>
      <mixin type="dojo.number.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberTextBoxMixin">
    <methods>
      <method name="_formatter" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="constraints" type="dojo.number.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="_parser" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.number.__ParseOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.number.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="set('value', null"/>
          <return-type type="Object"/>
          <return-type type="''"/>
          <return-type type="undefined) should fire onChange(NaN)"/>
        </return-types>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance">
        <return-types>
          <return-type type="return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)"/>
          <return-type type="gibberish"/>
          <return-type type="Number or NaN for ''"/>
        </return-types>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="valid exponential number in range"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="regExpGen" scope="instance" type="Object"/>
      <property name="constraints" scope="instance" type="dijit.form.NumberTextBox.__Constraints"/>
      <property name="value" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBoxMixin.editOptions">
    <properties>
      <property name="pattern" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBoxMixin.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.RangeBoundTextBox" superclass="dijit.form.MappedTextBox">
    <methods>
      <method name="rangeCheck" scope="instance">
        <parameters>
          <parameter name="primitive" type="Number" usage="required"/>
          <parameter name="constraints" type="dijit.form.RangeBoundTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="isInRange" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isDefinitelyOutOfRange" scope="instance"/>
      <method name="_isValidSubset" scope="instance"/>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.MappedTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="rangeMessage" scope="instance" type="String"/>
      <property name="constraints" scope="instance" type="dijit.form.RangeBoundTextBox.__Constraints"/>
      <property name="messages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SelectMenu" superclass="dijit.Menu">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="mb" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Menu" scope="instance"/>
    </mixins>
    <properties>
      <property name="menuTableNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SelectMenu.menuTableNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.Select" superclass="dijit.form._FormSelectWidget">
    <methods>
      <method name="_fillContent" scope="instance"/>
      <method name="_getMenuItemForOption" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildren" scope="instance"/>
      <method name="_loadChildren" scope="instance">
        <parameters>
          <parameter name="loadMenuItems" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="instance">
        <parameters>
          <parameter name="newDisplay" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="instance">
        <description>Show missing or invalid messages if appropriate, and highlight textbox field.
	Used when a select is initially set to no value and the user is required to
	set the value.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="handle value is null or undefined"/>
        </return-types>
      </method>
      <method name="reset" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setStyleAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String||Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="closeDropDown" scope="instance"/>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._FormSelectWidget" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="required" scope="instance" type="Boolean"/>
      <property name="state" scope="instance" type="String"/>
      <property name="message" scope="instance" type="String"/>
      <property name="tooltipPosition" scope="instance" type="String[]"/>
      <property name="emptyLabel" scope="instance" type="string"/>
      <property name="_isLoaded" scope="instance" type="Boolean"/>
      <property name="_childrenLoaded" scope="instance" type="Boolean"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="_missingMsg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Select.srcNodeRef">
    <properties>
      <property name="selectedIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.form.Select.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.Select.dropDown.menuTableNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.SimpleTextarea" superclass="dijit.form.TextBox">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.TextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="rows" scope="instance" type="Number"/>
      <property name="cols" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="_previousValue" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.SimpleTextarea.textbox">
    <properties>
      <property name="selectionStart" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setPlaceHolderAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePlaceHolder" scope="instance"/>
      <method name="_getValueAttr" scope="instance">
        <description>For `dijit.form.TextBox` this basically returns the value of the &lt;input&gt;.
	For `dijit.form.MappedTextBox` subclasses, which have both
	a "displayed value" and a separate "submit value",
	This treats the "displayed value" as the master value, computing the
	submit value from it via this.parse().</description>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget to "value" which can be of
	any type as determined by the widget.</description>
        <parameters>
          <parameter name="value" type="The" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getDisplayedValue" scope="instance"/>
      <method name="_getDisplayedValueAttr" scope="instance">
        <description>Returns the displayed value (what the user sees on the screen),
	after filtering (ie, trimming spaces etc.).
	For some subclasses of TextBox (like ComboBox), the displayed value
	is different from the serialized value that's actually
	sent to the server (see dijit.form.ValidationTextBox.serialize)</description>
      </method>
      <method name="setDisplayedValue" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <description>Sets the value of the visual element to the string "value".
	The widget value is also set to a corresponding,
	but not necessarily the same, value.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="filter" scope="instance">
        <description>For MappedTextBox subclasses, this is called twice
	- once with the display value
	- once the value as set/returned by set('value', ...)
	and get('value'), ex: a Number for NumberTextBox.
	In the latter case it does corrections like converting null to NaN.  In
	the former case the NumberTextBox.filter() method calls this.inherited()
	to execute standard trimming code in TextBox.filter().
	TODO: break this into two methods in 2.0</description>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="trim" scope="instance" type="Boolean"/>
      <property name="uppercase" scope="instance" type="Boolean"/>
      <property name="lowercase" scope="instance" type="Boolean"/>
      <property name="propercase" scope="instance" type="Boolean"/>
      <property name="maxLength" scope="instance" type="String"/>
      <property name="selectOnClick" scope="instance" type="Boolean"/>
      <property name="placeHolder" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_singleNodeTemplate" scope="instance" type="String"/>
      <property name="_buttonInputDisabled" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="displayedValue" scope="instance" type="String"/>
      <property name="_blankValue" scope="instance" type="String"/>
      <property name="_selectOnClickHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox._phspan">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox._phspan.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox.textbox">
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="selectionStart" scope="instance" type="Object"/>
      <property name="selectionEnd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea" superclass="dijit.form.SimpleTextarea">
    <description>A textarea that dynamically expands/contracts (changing it's height) as
	the user types, to display all the text without requiring a scroll bar.
	Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
	Rows is not supported since this widget adjusts the height.</description>
    <methods>
      <method name="_getHeight" scope="instance">
        <parameters>
          <parameter name="textarea" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_estimateHeight" scope="instance">
        <parameters>
          <parameter name="textarea" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onInput" scope="instance"/>
      <method name="_shrink" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="_setValueAttr" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.SimpleTextarea" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="cols" scope="instance" type="String"/>
      <property name="_previousNewlines" scope="instance" type="Number"/>
      <property name="_strictMode" scope="instance" type="bool"/>
      <property name="_needsHelpShrinking" scope="instance" type="Object"/>
      <property name="_busyResizing" scope="instance" type="bool"/>
      <property name="_setTimeoutHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.textbox.style">
    <properties>
      <property name="maxHeight" scope="instance" type="String"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="paddingBottom" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.textbox">
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="scrollHeight" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.form.TimeTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="popupClass" scope="instance" type="String"/>
      <property name="_selector" scope="instance" type="String"/>
      <property name="constraints" scope="instance" type="dijit.form.TimeTextBox.__Constraints"/>
      <property name="value" scope="instance" type="Date"/>
    </properties>
  </class>
  <class type="dijit.form.TimeTextBox.__Constraints" superclass="dijit.form._DateTimeTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._TimePicker.__Constraints.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox.__Constraints" scope="instance"/>
      <mixin type="dijit._TimePicker.__Constraints" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.ValidationTextBox" superclass="dijit.form.TextBox">
    <methods>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setValueAttr" scope="instance"/>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidSubset" scope="instance"/>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getPromptMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="validate" scope="instance">
        <description>Show missing or invalid messages if appropriate, and highlight textbox field.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_computePartialRE" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setMessageAttr" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.TextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="required" scope="instance" type="Boolean"/>
      <property name="promptMessage" scope="instance" type="String"/>
      <property name="invalidMessage" scope="instance" type="String"/>
      <property name="missingMessage" scope="instance" type="String"/>
      <property name="message" scope="instance" type="String"/>
      <property name="constraints" scope="instance-prototype" type="dijit.form.ValidationTextBox.__Constraints"/>
      <property name="regExp" scope="instance" type="String"/>
      <property name="state" scope="instance" type="String"/>
      <property name="tooltipPosition" scope="instance" type="String[]"/>
      <property name="_maskValidSubsetError" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="Object"/>
      <property name="_partialre" scope="instance" type="String"/>
      <property name="messages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.MappedTextBox.valueNode">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.ValidationTextBox.__Constraints">
    <methods/>
    <properties>
      <property name="locale" scope="instance" type="String"/>
      <property name="_flags_" scope="instance" type="anything"/>
    </properties>
  </class>
  <class type="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
    <properties>
      <property name="min" scope="instance" type="Number"/>
      <property name="max" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.form.VerticalRule" superclass="dijit.form.HorizontalRule">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRule" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_positionPrefix" scope="instance" type="String"/>
      <property name="container" scope="instance" type="String"/>
      <property name="_isHorizontal" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form.VerticalRuleLabels" superclass="dijit.form.HorizontalRuleLabels">
    <methods>
      <method name="_calcPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRuleLabels" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_positionPrefix" scope="instance" type="String"/>
      <property name="_labelPrefix" scope="instance" type="String"/>
      <property name="_isHorizontal" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form.VerticalSlider" superclass="dijit.form.HorizontalSlider">
    <methods>
      <method name="_isReversed" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalSlider" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_mousePixelCoord" scope="instance" type="String"/>
      <property name="_pixelCount" scope="instance" type="String"/>
      <property name="_startingPixelCoord" scope="instance" type="String"/>
      <property name="_startingPixelCount" scope="instance" type="String"/>
      <property name="_handleOffsetCoord" scope="instance" type="String"/>
      <property name="_progressPixelSize" scope="instance" type="String"/>
      <property name="_descending" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dijit.form._DateTimeTextBox" superclass="dijit.form.RangeBoundTextBox">
    <methods>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="Date" usage="required"/>
          <parameter name="val2" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInvalidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Date|String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="attr" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDropDownDefaultValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="_setDisplayedValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="hasDownArrow" scope="instance" type="Boolean"/>
      <property name="openOnClick" scope="instance" type="Boolean"/>
      <property name="constraints" scope="instance" type="dijit.form._DateTimeTextBox.__Constraints"/>
      <property name="regExpGen" scope="instance" type="Object"/>
      <property name="datePackage" scope="instance-prototype" type="String"/>
      <property name="forceWidth" scope="instance" type="Object"/>
      <property name="dropDownDefaultValue" scope="instance" type="Date"/>
      <property name="value" scope="instance-prototype" type="Date"/>
      <property name="_blankValue" scope="instance" type="Object"/>
      <property name="popupClass" scope="instance" type="String"/>
      <property name="_selector" scope="instance" type="String"/>
      <property name="_buttonNode" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="dateClassObj" scope="instance" type="Object"/>
      <property name="dateLocaleModule" scope="instance" type="Object"/>
      <property name="_invalidDate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._DateTimeTextBox.__Constraints" superclass="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.date.locale.__FormatOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox.__Constraints" scope="instance"/>
      <mixin type="dojo.date.locale.__FormatOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._DateTimeTextBox._buttonNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form._FormMixin">
    <description>Can extract all the form widgets
	values and combine them into a single javascript object, or alternately
	take such an object and set the values for all the contained
	form widgets</description>
    <methods>
      <method name="reset" scope="instance"/>
      <method name="validate" scope="instance"/>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance"/>
      <method name="_getValueAttr" scope="instance"/>
      <method name="isValid" scope="instance"/>
      <method name="onValidStateChange" scope="instance">
        <parameters>
          <parameter name="isValid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getState" scope="instance"/>
      <method name="disconnectChildren" scope="instance"/>
      <method name="connectChildren" scope="instance">
        <parameters>
          <parameter name="inStartup" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="state" scope="instance" type="String"/>
      <property name="_descendants" scope="instance" type="Object"/>
      <property name="_childConnections" scope="instance" type="Array"/>
      <property name="_childWatches" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.form._FormSelectWidget" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="onFetch" scope="instance"/>
      <method name="getOptions" scope="instance">
        <parameters>
          <parameter name="valueOrIdx" type="anything" usage="required"/>
        </parameters>
        <return-description>The option corresponding with the given value or index.  null
	is returned if any of the following are true:
	- A string value is passed in which doesn't exist
	- An index is passed in which is outside the bounds of the array of options
	- A dijit.form.__SelectOption is passed in which is not a part of the select</return-description>
        <return-types>
          <return-type type="dijit.form.__SelectOption[]"/>
          <return-type type="dijit.form.__SelectOption"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="addOption" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption|dijit.form.__SelectOption[]" usage="required"/>
        </parameters>
      </method>
      <method name="removeOption" scope="instance">
        <parameters>
          <parameter name="valueOrIdx" type="String|dijit.form.__SelectOption|Number|Array" usage="required"/>
        </parameters>
      </method>
      <method name="updateOption" scope="instance">
        <parameters>
          <parameter name="newOption" type="dijit.form.__SelectOption|dijit.form.__SelectOption[]" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="dojo.data.api.Identity" usage="required"/>
          <parameter name="selectedValue" type="anything" usage="optional"/>
          <parameter name="fetchArgs" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.data.api.Identity"/>
        </return-types>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="_loadChildren" scope="instance"/>
      <method name="_updateSelection" scope="instance"/>
      <method name="_getValueFromOpts" scope="instance"/>
      <method name="_onNewItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_getOptionObjForItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.form.__SelectOption"/>
        </return-types>
      </method>
      <method name="_addOptionForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_fillContent" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_removeOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="instance">
        <parameters>
          <parameter name="newDisplay" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildren" scope="instance"/>
      <method name="_getSelectedOptionsAttr" scope="instance"/>
      <method name="_pseudoLoadChildren" scope="instance">
        <parameters>
          <parameter name="items" type="item[]" usage="required"/>
        </parameters>
      </method>
      <method name="onSetStore" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="multiple" scope="instance" type="Boolean"/>
      <property name="store" scope="instance" type="dojo.data.api.Identity"/>
      <property name="query" scope="instance" type="object"/>
      <property name="queryOptions" scope="instance" type="object"/>
      <property name="sortByLabel" scope="instance" type="Boolean"/>
      <property name="loadChildrenOnOpen" scope="instance" type="Boolean"/>
      <property name="_notifyConnections" scope="instance" type="Array"/>
      <property name="_onChangeActive" scope="instance" type="bool"/>
      <property name="_loadingStore" scope="instance" type="Object"/>
      <property name="_pendingValue" scope="instance" type="Object"/>
      <property name="_oValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormSelectWidget.options">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.__SelectOption">
    <methods/>
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="selected" scope="instance" type="Boolean"/>
      <property name="disabled" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dijit.form._FormWidget" superclass="dijit._Widget">
    <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	They also share some common methods.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="anything" usage="required"/>
          <parameter name="val2" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="create" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="alt" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="tabIndex" scope="instance" type="Integer"/>
      <property name="disabled" scope="instance" type="Boolean"/>
      <property name="intermediateChanges" scope="instance" type="Boolean"/>
      <property name="scrollOnFocus" scope="instance" type="Boolean"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="nameAttrSetting" scope="instance" type="Object"/>
      <property name="_onChangeActive" scope="instance" type="Boolean"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
      <property name="_pendingOnChange" scope="instance" type="bool"/>
      <property name="_onChangeHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormValueWidget" superclass="dijit.form._FormWidget">
    <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
    <methods>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="undo" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutHackIE7" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="readOnly" scope="instance" type="Boolean"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form._FormValueWidget.domNode">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormValueWidget.domNode.firstChild.style">
    <properties>
      <property name="filter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._Spinner" superclass="dijit.form.RangeBoundTextBox">
    <description>This class basically (conceptually) extends `dijit.form.ValidationTextBox`.
	It modifies the template to have up/down arrows, and provides related handling code.</description>
    <methods>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowPressed" scope="instance">
        <parameters>
          <parameter name="nodePressed" type="Node" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="increment" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowReleased" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_typematicCallback" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultTimeout" scope="instance" type="Number"/>
      <property name="minimumTimeout" scope="instance" type="Number"/>
      <property name="timeoutChangeRate" scope="instance" type="Number"/>
      <property name="smallDelta" scope="instance" type="Number"/>
      <property name="largeDelta" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_wheelTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._Spinner.cssStateNodes">
    <properties>
      <property name="upArrowNode" scope="instance" type="String"/>
      <property name="downArrowNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout">
    <methods>
      <method name="marginBox2contentBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="mb" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layoutChildren" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="children" type="Widget[]" usage="required"/>
          <parameter name="changedRegionId" type="String" usage="optional"/>
          <parameter name="changedRegionSize" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.layout.AccordionContainer" superclass="dijit.layout.StackContainer">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="optional"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="optional"/>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the widget has finished loading"/>
        </return-types>
      </method>
      <method name="_onKeyPress" scope="instance">
        <description>This is called from a handler on AccordionContainer.domNode
	(setup in StackContainer), and is also called directly from
	the click handler for accordion labels</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="fromTitle" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="buttonWidget" scope="instance" type="String"/>
      <property name="_verticalSpace" scope="instance" type="Number"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="selectedChildWidget" scope="instance" type="Object"/>
      <property name="_contentBox" scope="instance" type="Object"/>
      <property name="_containerContentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.domNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget.containerNode"/>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget.containerNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget._wrapperWidget">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer._animation">
    <properties>
      <property name="onStop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._AccordionInnerContainer" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setSelectedAttr" scope="instance">
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="destroyDescendants" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonWidget" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="isContainer" scope="instance" type="Object"/>
      <property name="isLayoutContainer" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_contentWidgetWatches" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.layout._AccordionInnerContainer.contentWidget">
    <properties>
      <property name="_buttonWidget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._AccordionButton" superclass="dijit._Widget">
    <methods>
      <method name="getParent" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="getTitleHeight" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_onTitleClick" scope="instance"/>
      <method name="_onTitleKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedAttr" scope="instance">
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionPane" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onSelected" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._Widget.prototype">
    <properties>
      <property name="maxSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.BorderContainer" superclass="dijit.layout._LayoutWidget">
    <description>A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	that contains a child widget marked region="center" and optionally children widgets marked
	region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	Children along the edges will be laid out according to width or height dimensions and may
	include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	space is designated for the center region.
	The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	"left" and "right" except that they will be reversed in right-to-left environments.
	For complex layouts, multiple children can be specified for a single region.   In this case, the
	layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
	and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
	instead of the design attribute to conrol layout precedence of horizontal vs. vertical panes.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance"/>
      <method name="getSplitter" scope="instance">
        <parameters>
          <parameter name="region" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="newSize" type="Object" usage="required"/>
          <parameter name="currentSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutChildren" scope="instance">
        <description>With no arguments, measures the height of top/bottom panes, the width
	of left/right panes, and then sizes all panes accordingly.
	With changedRegion specified (as "left", "top", "bottom", or "right"),
	it changes that region's width/height to changedRegionSize and
	then resizes other regions that were affected.</description>
        <parameters>
          <parameter name="changedChildId" type="String" usage="optional"/>
          <parameter name="changedChildSize" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="destroyRecursive" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="design" scope="instance" type="String"/>
      <property name="gutters" scope="instance" type="Boolean"/>
      <property name="liveSplitters" scope="instance" type="Boolean"/>
      <property name="persist" scope="instance" type="Boolean"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_splitterClass" scope="instance" type="String"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="cs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.BorderContainer.pe">
    <properties>
      <property name="r" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter" superclass="dijit._Widget">
    <description>This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	create it directly.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_computeMaxSize" scope="instance"/>
      <method name="_startDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_drag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="forceResize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stopDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupHandlers" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="container" scope="instance" type="dijit.layout.BorderContainer"/>
      <property name="region" scope="instance" type="String"/>
      <property name="live" scope="instance" type="Boolean"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="_factor" scope="instance" type="Object"/>
      <property name="_cookieName" scope="instance" type="String"/>
      <property name="cover" scope="instance" type="Object"/>
      <property name="_resize" scope="instance" type="Object"/>
      <property name="fake" scope="instance" type="Object"/>
      <property name="_handlers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter.child">
    <properties>
      <property name="minSize" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout._Gutter" superclass="dijit._Widget">
    <description>Instantiated by `dijit.layout.BorderContainer`.  Users should not
	create directly.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="horizontal" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ContentPane" superclass="dijit._Widget">
    <description>This widget embeds a document fragment in the page, specified
	either by uri, javascript generated markup or DOM reference.
	Any widgets within this content are instantiated and managed,
	but laid out according to the HTML structure.  Unlike IFRAME,
	ContentPane embeds a document fragment as would be found
	inside the BODY tag of a full HTML document.  It should not
	contain the HTML, HEAD, or BODY tags.
	For more advanced functionality with scripts and
	stylesheets, see dojox.layout.ContentPane.  This widget may be
	used stand alone or as a base class for other widgets.
	ContentPane is useful as a child of other layout containers
	such as BorderContainer or TabContainer, but note that those
	widgets can contain any widget as a child.</description>
    <methods>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="srcNodeRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="setHref" scope="instance">
        <parameters>
          <parameter name="href" type="String|Uri" usage="required"/>
        </parameters>
      </method>
      <method name="_setHrefAttr" scope="instance">
        <description>Reset the (external defined) content of this pane and replace with new url
	Note: It delays the download until widget is shown if preload is false.</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="setContent" scope="instance">
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="instance">
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_getContentAttr" scope="instance"/>
      <method name="cancel" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="destroyRecursive" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isShown" scope="instance">
        <description>If I am a child of a layout widget then it actually returns true if I've ever been visible,
	not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
	tree every call, and at least solves the performance problem on page load by deferring loading
	hidden ContentPanes until they are first shown</description>
        <return-types>
          <return-type type="for TitlePane, etc."/>
        </return-types>
      </method>
      <method name="_onShow" scope="instance">
        <description>For a plain ContentPane, this is called on initialization, from startup().
	If the ContentPane is a hidden pane of a TabContainer etc., then it's
	called whenever the pane is made visible.
	Does necessary processing, including href download and layout/resize of
	child widget(s)</description>
        <return-types>
          <return-type type="If child has an href, promise that fires when the load is complete"/>
        </return-types>
      </method>
      <method name="refresh" scope="instance">
        <description>1. cancels any currently in-flight requests
	2. posts "loading..." message
	3. sends XHR to download new data</description>
        <return-types>
          <return-type type="If child has an href, promise that fires when refresh is complete"/>
        </return-types>
      </method>
      <method name="_load" scope="instance"/>
      <method name="_onLoadHandler" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnloadHandler" scope="instance"/>
      <method name="destroyDescendants" scope="instance"/>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DocumentFragment" usage="required"/>
          <parameter name="isFakeContent" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onError" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="consoleText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scheduleLayout" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onUnload" scope="instance"/>
      <method name="onDownloadStart" scope="instance">
        <description>The string returned by this function will be the html
	that tells the user we are loading something.
	Override with your own function if you want to change text.</description>
      </method>
      <method name="onContentError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadEnd" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._ContentPaneResizeMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="href" scope="instance" type="String"/>
      <property name="content" scope="instance" type="String"/>
      <property name="extractContent" scope="instance" type="Boolean"/>
      <property name="parseOnLoad" scope="instance" type="Boolean"/>
      <property name="parserScope" scope="instance" type="String"/>
      <property name="preventCache" scope="instance" type="Boolean"/>
      <property name="preload" scope="instance" type="Boolean"/>
      <property name="refreshOnShow" scope="instance" type="Boolean"/>
      <property name="loadingMessage" scope="instance" type="String"/>
      <property name="errorMessage" scope="instance" type="String"/>
      <property name="isLoaded" scope="instance" type="Boolean"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="ioArgs" scope="instance" type="Object"/>
      <property name="isContainer" scope="instance" type="Boolean"/>
      <property name="onLoadDeferred" scope="instance" type="dojo.Deferred"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="stopParser" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Boolean"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_hrefChanged" scope="instance" type="Object"/>
      <property name="_isDownloaded" scope="instance" type="bool"/>
      <property name="_resizeCalled" scope="instance" type="Object"/>
      <property name="_wasShown" scope="instance" type="Object"/>
      <property name="_xhrDfd" scope="instance" type="Object"/>
      <property name="_contentSetter" scope="instance" type="Object"/>
      <property name="_needLayout" scope="instance" type="Object"/>
      <property name="_changeSize" scope="instance" type="Object"/>
      <property name="_resultSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ContentPane.domNode">
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.LayoutContainer" superclass="dijit.layout._LayoutWidget">
    <description>Provides Delphi-style panel layout semantics.
	A LayoutContainer is a box with a specified size (like style="width: 500px; height: 500px;"),
	that contains children widgets marked with "layoutAlign" of "left", "right", "bottom", "top", and "client".
	It takes it's children marked as left/top/bottom/right, and lays them out along the edges of the box,
	and then it takes the child marked "client" and puts it into the remaining space in the middle.
	Left/right positioning is similar to CSS's "float: left" and "float: right",
	and top/bottom positioning would be similar to "float: top" and "float: bottom", if there were such
	CSS.
	Note that there can only be one client element, but there can be multiple left, right, top,
	or bottom elements.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.LinkPane" superclass="dijit.layout.ContentPane">
    <description>LinkPane is just a ContentPane that is declared in markup similarly
	to an anchor.  The anchor's body (the words between `&lt;a&gt;` and `&lt;/a&gt;`)
	become the title of the widget (used for TabContainer, AccordionContainer, etc.)</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController" superclass="dijit.layout.TabController">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="onStartup" scope="instance"/>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButtons" scope="instance"/>
      <method name="_getTabsWidth" scope="instance"/>
      <method name="_enableBtn" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getScroll" scope="instance"/>
      <method name="_convertToScrollLeft" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getScrollBounds" scope="instance"/>
      <method name="_getScrollForSelectedTab" scope="instance"/>
      <method name="createSmoothScroll" scope="instance">
        <description>If an number argument is passed to the function, that horizontal
	pixel position is scrolled to.  Otherwise the currently selected
	tab is scrolled to.</description>
        <parameters>
          <parameter name="x" type="Integer" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="_getBtnNode" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="doSlideRight" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="doSlideLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="doSlide" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setButtonClass" scope="instance">
        <parameters>
          <parameter name="scroll" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.TabController" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="useMenu" scope="instance" type="Boolean"/>
      <property name="useSlider" scope="instance" type="Boolean"/>
      <property name="tabStripClass" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_minScroll" scope="instance" type="Number"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_postStartup" scope="instance" type="Object"/>
      <property name="_selectedTab" scope="instance" type="Object"/>
      <property name="_btnWidth" scope="instance" type="Number"/>
      <property name="_buttons" scope="instance" type="Object"/>
      <property name="_dim" scope="instance" type="Object"/>
      <property name="_postResize" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController.scrollNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._contentBox">
    <properties>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._leftBtn">
    <properties>
      <property name="layoutAlign" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._rightBtn">
    <properties>
      <property name="layoutAlign" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._menuBtn">
    <properties>
      <property name="layoutAlign" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController.scrollNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._ScrollingTabControllerButtonMixin">
    <methods>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="tabIndex" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout._ScrollingTabControllerButton" superclass="dijit.form.Button">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout._ScrollingTabControllerMenuButton" superclass="dijit.form.Button">
    <methods>
      <method name="isLoaded" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeDropDown" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerId" scope="instance" type="String"/>
      <property name="tabIndex" scope="instance" type="String"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer" superclass="dijit.layout._LayoutWidget">
    <description>A Container widget with sizing handles in-between each child.
	Contains multiple children widgets, all of which are displayed side by side
	(either horizontally or vertically); there's a bar between each of the children,
	and you can adjust the relative size of each child by dragging the bars.
	You must specify a size (width and height) for the SplitContainer.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onSizerMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addSizer" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_movePanel" scope="instance">
        <parameters>
          <parameter name="panel" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveSlider" scope="instance">
        <parameters>
          <parameter name="slider" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_growPane" scope="instance">
        <parameters>
          <parameter name="growth" type="Object" usage="required"/>
          <parameter name="pane" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkSizes" scope="instance"/>
      <method name="beginSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changeSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="movePoint" scope="instance"/>
      <method name="legaliseSplitPoint" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSize" scope="instance"/>
      <method name="_showSizingLine" scope="instance"/>
      <method name="_hideSizingLine" scope="instance"/>
      <method name="_moveSizingLine" scope="instance"/>
      <method name="_getCookieName" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_restoreState" scope="instance"/>
      <method name="_saveState" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="activeSizing" scope="instance" type="Boolean"/>
      <property name="sizerWidth" scope="instance" type="Integer"/>
      <property name="orientation" scope="instance" type="String"/>
      <property name="persist" scope="instance" type="Boolean"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="isHorizontal" scope="instance" type="bool"/>
      <property name="sizers" scope="instance" type="Array"/>
      <property name="virtualSizer" scope="instance" type="Object"/>
      <property name="paneWidth" scope="instance" type="Object"/>
      <property name="paneHeight" scope="instance" type="Object"/>
      <property name="isSizing" scope="instance" type="bool"/>
      <property name="sizingSplitter" scope="instance" type="Object"/>
      <property name="cover" scope="instance" type="Object"/>
      <property name="originPos" scope="instance" type="Object"/>
      <property name="startPoint" scope="instance" type="Object"/>
      <property name="lastPoint" scope="instance" type="String"/>
      <property name="screenToClientOffset" scope="instance" type="Number"/>
      <property name="dragOffset" scope="instance" type="Number"/>
      <property name="_ownconnects" scope="instance" type="Array"/>
      <property name="isDraggingLeft" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.domNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.cover.style">
    <properties>
      <property name="zIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.sizingSplitter.style">
    <properties>
      <property name="zIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.paneBefore">
    <properties>
      <property name="position" scope="instance" type="Object"/>
      <property name="sizeActual" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.paneAfter">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="sizeActual" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.virtualSizer.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.StackContainer" superclass="dijit.layout._LayoutWidget">
    <description>A container for widgets (ContentPanes, for example) That displays
	only one Widget at a time.
	Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	Can be base class for container, Wizard, Show, etc.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget|String" usage="required"/>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the child's href finishes loading"/>
        </return-types>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="required"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="required"/>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the child's href finishes loading"/>
        </return-types>
      </method>
      <method name="_adjacent" scope="instance">
        <parameters>
          <parameter name="forward" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="forward" scope="instance"/>
      <method name="back" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
        <return-description>Promise that fires when page has finished showing, or true if there's no href</return-description>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="closeChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="doLayout" scope="instance" type="Boolean"/>
      <property name="persist" scope="instance" type="Boolean"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="selectedChildWidget" scope="instance" type="dijit._Widget"/>
      <property name="_hasBeenShown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.StackController" superclass="dijit._Widget">
    <description>Monitors the specified StackContainer, and whenever a page is
	added, deleted, or selected, updates itself accordingly.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onStartup" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onButtonClick" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onCloseButtonClick" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="adjacent" scope="instance">
        <parameters>
          <parameter name="forward" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="onkeypress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onContainerKeyPress" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="containerId" scope="instance" type="String"/>
      <property name="buttonWidget" scope="instance" type="String"/>
      <property name="_currentChild" scope="instance" type="Object"/>
      <property name="pane2button" scope="instance" type="Object"/>
      <property name="pane2connects" scope="instance" type="Object"/>
      <property name="pane2watches" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._StackButton" superclass="dijit.form.ToggleButton">
    <description>The button-like or tab-like object you click to select or delete a page</description>
    <methods>
      <method name="buildRendering" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClickCloseButton" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ToggleButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="tabIndex" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.TabContainer" superclass="dijit.layout._TabContainerBase">
    <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
    <methods>
      <method name="_makeController" scope="instance">
        <parameters>
          <parameter name="srcNode" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._TabContainerBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="useMenu" scope="instance" type="Boolean"/>
      <property name="useSlider" scope="instance" type="Boolean"/>
      <property name="controllerWidget" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.TabController" superclass="dijit.layout.StackController">
    <description>Lets the user select the currently shown pane in a TabContainer or StackContainer.
	TabController also monitors the TabContainer, and whenever a pane is
	added or deleted updates itself accordingly.</description>
    <methods>
      <method name="_rectifyRtlTabList" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackController" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="tabPosition" scope="instance" type="String"/>
      <property name="buttonWidget" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton" superclass="dijit.layout._StackButton">
    <description>Contains the title of the pane, and optionally a close-button to destroy the pane.
	This is an internal widget and should not be instantiated directly.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setCloseButtonAttr" scope="instance">
        <parameters>
          <parameter name="disp" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <description>takes an HTML string.
	Inherited ToggleButton implementation will Set the label (text) of the button;
	Need to set the alt attribute of icon on tab buttons if no label displayed</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._StackButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="scrollOnFocus" scope="instance" type="bool"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_closeMenu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton.cssStateNodes">
    <properties>
      <property name="closeNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton.closeNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton.iconNode">
    <properties>
      <property name="alt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._ContentPaneResizeMixin">
    <methods>
      <method name="_startChildren" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_checkIfSingleChild" scope="instance">
        <return-types>
          <return-type type="or a regexp for hidden elements like script"/>
          <return-type type="area"/>
          <return-type type="map"/>
          <return-type type="etc.."/>
        </return-types>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layout" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutChildren" scope="instance"/>
    </methods>
    <properties>
      <property name="doLayout" scope="instance" type="Boolean"/>
      <property name="isLayoutContainer" scope="instance" type="Boolean"/>
      <property name="_childOfLayoutWidget" scope="instance" type="Object"/>
      <property name="_needLayout" scope="instance" type="bool"/>
      <property name="_singleChild" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_contentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._LayoutWidget" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <description>Change size mode:
	When changeSize is specified, changes the marginBox of this widget
	and forces it to relayout its contents accordingly.
	changeSize may specify height, width, or both.
	If resultSize is specified it indicates the size the widget will
	become after changeSize has been applied.
	Notification mode:
	When changeSize is null, indicates that the caller has already changed
	the size of the widget, or perhaps it changed because the browser
	window was resized.  Tells widget to relayout its contents accordingly.
	If resultSize is also specified it indicates the size the widget has
	become.
	In either mode, this method also:
	1. Sets this._borderBox and this._contentBox to the new size of
	the widget.  Queries the current domNode size if necessary.
	2. Calls layout() to resize contents (and maybe adjust child widgets).</description>
        <parameters>
          <parameter name="changeSize" type="Object" usage="optional"/>
          <parameter name="resultSize" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="isLayoutContainer" scope="instance" type="Boolean"/>
      <property name="getParent" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_borderBox" scope="instance" type="Object"/>
      <property name="_contentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._LayoutWidget.domNode.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout._TabContainerBase" superclass="dijit.layout.StackContainer">
    <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="tab" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="tabPosition" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="tabStrip" scope="instance" type="Boolean"/>
      <property name="nested" scope="instance" type="Boolean"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="selectedChildWidget" scope="instance" type="Object"/>
      <property name="_containerContentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabContainerBase.tablist">
    <properties>
      <property name="layoutAlign" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabContainerBase.tablist.domNode"/>
  <class type="dijit.layout._TabContainerBase.tablist.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="doh.robot">
    <methods>
      <method name="_updateDocument" scope="instance"/>
      <method name="_resolveNode" scope="instance">
        <parameters>
          <parameter name="n" type="String||DOMNode||Function" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollIntoView" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_position" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_getWindowChain" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="String||DOMNode||Function" usage="required"/>
          <parameter name="delay" type="Number," usage="required"/>
        </parameters>
      </method>
      <method name="mouseMoveAt" scope="instance">
        <description>Moves the mouse over the specified node at the specified relative x,y offset.
	If you do not specify an offset, mouseMove will default to move to the middle of the node.
	Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);</description>
        <parameters>
          <parameter name="node" type="String||DOMNode||Function" usage="required"/>
          <parameter name="delay" type="Integer," usage="required"/>
          <parameter name="duration" type="Integer," usage="required"/>
          <parameter name="offsetX" type="Number," usage="required"/>
          <parameter name="offsetY" type="Number," usage="required"/>
        </parameters>
      </method>
      <method name="initRobot" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="waitForPageToLoad" scope="instance">
        <description>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
	returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.
	Example:
	runTest:function(){
	return waitForPageLoad(function(){ doh.robot.keyPress(dojo.keys.ENTER, 500); });
	}</description>
        <parameters>
          <parameter name="submitActions" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_run" scope="instance">
        <parameters>
          <parameter name="frame" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="options">
    <properties>
      <property name="compress" scope="instance" type="bool"/>
      <property name="optimization" scope="instance" type="Number"/>
      <property name="silent" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.tree">
    <methods>
      <method name="_compareNodes" scope="instance">
        <parameters>
          <parameter name="n1" type="Object" usage="required"/>
          <parameter name="n2" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.tree.ForestStoreModel" superclass="dijit.tree.TreeStoreModel">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="callback" type="function(items)" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onNewRootItem" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onAddToRoot" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onLeaveRoot" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_requeryTop" scope="instance"/>
      <method name="onNewItem" scope="instance">
        <description>Note that the default implementation requeries the top level items every time
	a new item is created, since any new item could be a top level item (even in
	addition to being a child of another item, since items can have multiple parents).
	If developers can detect which items are possible top level items (based on the item and the
	parentInfo parameters), they should override this method to only call _requeryTop() for top
	level items.  Often all top level items have parentInfo==null, but
	that will depend on which store you use and what your data is like.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetItem" scope="instance">
        <description>Handles updates to an item's children by calling onChildrenChange(), and
	other updates to an item by calling onChange().
	Also, any change to any item re-executes the query for the tree's top-level items,
	since this modified item may have started/stopped matching the query for top level items.
	If possible, developers should override this function to only call _requeryTop() when
	the change to the item has caused it to stop/start being a top level item in the tree.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required"/>
          <parameter name="newValue" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree.TreeStoreModel" scope="instance"/>
    </mixins>
    <properties>
      <property name="rootId" scope="instance" type="String"/>
      <property name="rootLabel" scope="instance" type="String"/>
      <property name="query" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.tree.ForestStoreModel.root">
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.tree.TreeStoreModel">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="getRoot" scope="instance">
        <parameters>
          <parameter name="onItem" type="Object" usage="required"/>
          <parameter name="onError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="newItem" scope="instance">
        <description>Developers will need to override this method if new items get added
	to parents with multiple children attributes, in order to define which
	children attribute points to the new item.</description>
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <description>Note that there will also be an onChildrenChange() callback for the parent
	of this item.</description>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="onNewItem" scope="instance">
        <description>If the new item is a child of an existing item,
	calls onChildrenChange() with the new list of children
	for that existing item.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetItem" scope="instance">
        <description>Handles updates to an item's children by calling onChildrenChange(), and
	other updates to an item by calling onChange().
	See `onNewItem` for more details on handling updates to an item's children.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required"/>
          <parameter name="newValue" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="store" scope="instance-prototype" type="dojo.data.Store"/>
      <property name="childrenAttrs" scope="instance" type="String[]"/>
      <property name="newItemIdAttr" scope="instance" type="String"/>
      <property name="labelAttr" scope="instance" type="String"/>
      <property name="root" scope="instance" type="dojo.data.Item"/>
      <property name="query" scope="instance" type="anything"/>
      <property name="deferItemLoadingUntilExpand" scope="instance" type="Boolean"/>
      <property name="connects" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree._dndContainer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tree" type="Node" usage="required"/>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.dnd.Item"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="widget" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="widget" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="newState" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_addItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
    </methods>
    <properties>
      <property name="current" scope="instance-prototype" type="DomNode"/>
      <property name="node" scope="instance-prototype" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="tree" scope="instance" type="Node"/>
      <property name="map" scope="instance" type="Object"/>
      <property name="containerState" scope="instance" type="String"/>
      <property name="events" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.tree._dndSelector" superclass="dijit.tree._dndContainer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tree" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedTreeNodes" scope="instance"/>
      <method name="selectNone" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="addTreeNode" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required"/>
          <parameter name="isAnchor" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="removeTreeNode" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="isTreeNodeSelected" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="setSelection" scope="instance">
        <parameters>
          <parameter name="newSelection" type="dijit._treeNode[]" usage="required"/>
        </parameters>
      </method>
      <method name="_setDifference" scope="instance">
        <parameters>
          <parameter name="xs" type="Object" usage="required"/>
          <parameter name="ys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelectionProperties" scope="instance"/>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="ignore right-click"/>
        </return-types>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="userSelect" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="multi" type="Boolean" usage="required"/>
          <parameter name="range" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="forInSelectedItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree._dndContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="selection" scope="instance-prototype" type="Hash&lt;String,"/>
      <property name="singular" scope="instance" type="Boolean"/>
      <property name="anchor" scope="instance-prototype" type="Object"/>
      <property name="_doDeselect" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.tree._dndSelector.current">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree.dndSource" superclass="dijit.tree._dndSelector">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tree" type="dijit.Tree" usage="required"/>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="dijit.tree.dndSource" usage="required"/>
          <parameter name="nodes" type="DOMNode[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_onDragMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance"/>
      <method name="checkItemAcceptance" scope="instance">
        <description>In the base case, this is called to check if target can become a child of source.
	When betweenThreshold is set, position="before" or "after" means that we
	are asking if the source node can be dropped before/after the target node.</description>
        <parameters>
          <parameter name="target" type="DOMNode" usage="required"/>
          <parameter name="source" type="dijit.tree.dndSource" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="DomNode[]" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="itemCreator" scope="instance">
        <description>For each node in nodes[], which came from source, create a hash of name/value
	pairs to be passed to Tree.model.newItem().  Returns array of those hashes.</description>
        <parameters>
          <parameter name="nodes" type="DomNode[]" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="source" type="dojo.dnd.Source" usage="required"/>
        </parameters>
        <return-description>Object[]
	Array of name/value hashes for each new item to be added to the Tree, like:
		[
			{ id: 123, label: "apple", foo: "bar" },
			{ id: 456, label: "pear", zaz: "bam" }
		]</return-description>
      </method>
      <method name="onDndDrop" scope="instance">
        <description>Updates data store items according to where node was dragged from and dropped
	to.   The tree will then respond to those data store updates and redraw itself.</description>
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="DomNode[]" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_isParentChildDrop" scope="instance">
        <parameters>
          <parameter name="source" type="The" usage="required"/>
          <parameter name="targetRow" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree._dndSelector" scope="instance"/>
    </mixins>
    <properties>
      <property name="isSource" scope="instance-prototype" type="Boolean"/>
      <property name="accept" scope="instance-prototype" type="String[]"/>
      <property name="copyOnly" scope="instance" type="Boolean"/>
      <property name="dragThreshold" scope="instance" type="Number"/>
      <property name="betweenThreshold" scope="instance" type="Integer"/>
      <property name="targetAnchor" scope="instance-prototype" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
      <property name="dropPosition" scope="instance-prototype" type="String"/>
      <property name="targetBox" scope="instance-prototype" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="mouseDown" scope="instance-prototype" type="bool"/>
      <property name="mouseButton" scope="instance" type="Object"/>
      <property name="_lastX" scope="instance-prototype" type="Number"/>
      <property name="_lastY" scope="instance-prototype" type="Number"/>
      <property name="isDragging" scope="instance-prototype" type="bool"/>
      <property name="sourceState" scope="instance" type="String"/>
      <property name="targetState" scope="instance" type="String"/>
      <property name="topics" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.tree.dndSource.tree">
    <properties>
      <property name="model" scope="instance" type="Object"/>
      <property name="item" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree.__SourceArgs">
    <methods/>
    <properties>
      <property name="isSource" scope="instance" type="Boolean"/>
      <property name="accept" scope="instance" type="String[]"/>
      <property name="autoSync" scope="instance" type="Object"/>
      <property name="copyOnly" scope="instance" type="Boolean"/>
      <property name="dragThreshold" scope="instance" type="Number"/>
      <property name="betweenThreshold" scope="instance" type="Integer"/>
    </properties>
  </class>
  <class type="dijit.tree.model">
    <description>Tree passes in values to the constructor to specify the callbacks.
	"item" is typically a dojo.data.Item but it's just a black box so
	it could be anything.
	This (like `dojo.data.api.Read`) is just documentation, and not meant to be used.</description>
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="getRoot" scope="instance">
        <parameters>
          <parameter name="onItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.AdapterRegistry">
    <description>Objects of this class keep list of arrays in the form [name, check,
	wrap, directReturn] that are used to determine what the contextual
	result of a set of checked arguments is. All check/wrap functions
	in this registry should be of the same arity.</description>
    <methods>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="check" type="Function" usage="required"/>
          <parameter name="wrap" type="Function" usage="required"/>
          <parameter name="directReturn" type="Boolean" usage="optional"/>
          <parameter name="override" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="match" scope="instance"/>
      <method name="unregister" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="pairs" scope="instance" type="Array"/>
      <property name="returnWrappers" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.DeferredList">
    <description>DeferredList takes an array of existing deferreds and returns a new deferred of its own
	this new deferred will typically have its callback fired when all of the deferreds in
	the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	fireOnOneErrback, will fire before all the deferreds as appropriate</description>
    <methods>
      <method name="gatherResults" scope="instance">
        <parameters>
          <parameter name="deferredList" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList">
    <description>dojo.NodeList instances provide many utilities that reflect
	core Dojo APIs for Array iteration and manipulation, DOM
	manipulation, and event handling. Instead of needing to dig up
	functions in the dojo.* namespace, NodeLists generally make the
	full power of Dojo available for DOM manipulation tasks in a
	simple, chainable way.</description>
    <methods>
      <method name="data" scope="instance">
        <description>Stash or get some arbirtrary data on/from these nodes. This private _data function is
	exposed publicly on `dojo.NodeList`, eg: as the result of a `dojo.query` call.
	DIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS
	returned. EVEN WHEN THE LIST IS length == 1.
	A single-node version of this function is provided as `dojo._nodeData`, which follows
	the same signature, though expects a String ID or DomNode reference in the first
	position, before key/value arguments.
	node: String|DomNode
	The node to associate data with</description>
        <parameters>
          <parameter name="key" type="Object|String" usage="optional"/>
          <parameter name="value" type="Anything" usage="optional"/>
        </parameters>
        <return-description>Object|Anything|Nothing
	When used as a setter via `dojo.NodeList`, a NodeList instance is returned
	for further chaning. When used as a getter via `dojo.NodeList` an ARRAY
	of items is returned. The items in the array correspond to the elements
	in the original list. This is true even when the list length is 1, eg:
	when looking up a node by ID (#foo)</return-description>
      </method>
      <method name="removeData" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_anim" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wipeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="slideTo" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="animateProperty" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="anim" scope="instance">
        <parameters>
          <parameter name="properties" type="Object" usage="required"/>
          <parameter name="duration" type="Integer" usage="optional"/>
          <parameter name="easing" type="Function" usage="optional"/>
          <parameter name="onEnd" type="Function" usage="optional"/>
          <parameter name="delay" type="Integer" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="html" scope="instance">
        <description>An alias for the "innerHTML" method, but only defined if there is not an existing
	"html" method on dojo.NodeList. Be careful if you are working in an environment
	where it is possible that dojo.NodeList-html could have been loaded, since its
	definition of "html" will take precedence. If you are not sure if dojo.NodeList-html
	could be loaded, use the "innerHTML" method.</description>
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
        <return-description>if no value is passed, the result is String, the innerHTML of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="innerHTML" scope="instance">
        <description>This method is simpler than the dojo.NodeList.html() method provided by
	`dojo.NodeList-html`. This method just does proper innerHTML insertion of HTML fragments,
	and it allows for the innerHTML to be read for the first node in the node list.
	Since dojo.NodeList-html already took the "html" name, this method is called
	"innerHTML". However, if dojo.NodeList-html has not been loaded yet, this
	module will define an "html" method that can be used instead. Be careful if you
	are working in an environment where it is possible that dojo.NodeList-html could
	have been loaded, since its definition of "html" will take precedence.
	The nodes represented by the value argument will be cloned if more than one
	node is in this NodeList. The nodes in this NodeList are returned in the "set"
	usage of this method, not the HTML that was inserted.</description>
        <parameters>
          <parameter name="value" type="String||DOMNode|NodeList" usage="optional"/>
        </parameters>
        <return-description>if no value is passed, the result is String, the innerHTML of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="text" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-description>if no value is passed, the result is String, the text value of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="append" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="content" type="String||DOMNode||NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="appendTo" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="prepend" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="content" type="String||DOMNode||NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.
	assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").prepend("&lt;span&gt;prepend&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;span&gt;prepend&lt;/span&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;span&gt;prepend&lt;/span&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="prependTo" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="after" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="content" type="String||Element||NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="insertAfter" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="before" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="content" type="String||DOMNode||NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="insertBefore" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="simpleFilter" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrap" scope="instance">
        <description>html will be cloned if the NodeList has more than one
	element. Only DOM nodes are cloned, not any attached
	event handlers.</description>
        <parameters>
          <parameter name="html" type="String||DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrapAll" scope="instance">
        <parameters>
          <parameter name="html" type="String||DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrapInner" scope="instance">
        <description>html will be cloned if the NodeList has more than one
	element. Only DOM nodes are cloned, not any attached
	event handlers.</description>
        <parameters>
          <parameter name="html" type="String||DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="replaceWith" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="content" type="String||DOMNode||NodeList" usage="required"/>
        </parameters>
        <return-description>The nodes currently in this NodeList will be returned, not the replacing content.
	Note that the returned nodes have been removed from the DOM.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="replaceAll" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>The nodes currently in this NodeList will be returned, not the matched nodes
	from the query. The nodes currently in this NodeLIst could have
	been cloned, so the returned NodeList will include the cloned nodes.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <description>Only the DOM nodes are cloned, not any attached event handlers.</description>
        <return-description>dojo.NodeList, a cloned set of the original nodes.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_buildArrayFromCallback" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_getUniqueAsNodeList" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getUniqueNodeListWithParent" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getRelatedUniqueNodes" scope="instance">
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="children" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, all immediate child elements for the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="closest" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
          <parameter name="root" type="String|DOMNode" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, the closest parent that matches the query, including the current
	node in this dojo.NodeList if it matches the query.</return-description>
        <return-types>
          <return-type type="To make rhino strict checking happy."/>
        </return-types>
      </method>
      <method name="parent" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, immediate parent elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="parents" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, all parent elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="siblings" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="next" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, the next element for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="nextAll" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements that come after the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="prev" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, the previous element for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="prevAll" scope="instance">
        <description>The returned nodes will be in reverse DOM order -- the first node in the list will
	be the node closest to the original node/NodeList.
	.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements that come before the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="andSelf" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList</return-description>
      </method>
      <method name="first" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, with the first node in this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="last" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, with the last node in this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="even" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, with the even nodes in this dojo.NodeList</return-description>
      </method>
      <method name="odd" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, with the odd nodes in this dojo.NodeList</return-description>
      </method>
      <method name="_normalize" scope="instance">
        <description>If content is an object, it can have special properties "template" and
	"parse". If "template" is defined, then the template value is run through
	dojo.string.substitute (if dojo.string.substitute has been dojo.required elsewhere),
	or if templateFunc is a function on the content, that function will be used to
	transform the template into a final string to be used for for passing to dojo._toDom.
	If content.parse is true, then it is remembered for later, for when the content
	nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
	(if dojo.parser has been dojo.required elsewhere).</description>
        <parameters>
          <parameter name="content" type="String||Element||Object||NodeList" usage="required"/>
          <parameter name="refNode" type="DOMNode" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_cloneNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_place" scope="instance">
        <description>Allows for cloning the nodes in the array, and for
	optionally parsing widgets, if ary._runParse is true.</description>
        <parameters>
          <parameter name="ary" type="Array" usage="required"/>
          <parameter name="refNode" type="DOMNode" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
          <parameter name="useClone" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="end" scope="instance">
        <description>Returns the `dojo.NodeList` that generated the current `dojo.NodeList`. If there
	is no parent dojo.NodeList, an empty dojo.NodeList is returned.</description>
      </method>
      <method name="slice" scope="instance">
        <description>This method behaves exactly like the Array.slice method
	with the caveat that it returns a dojo.NodeList and not a
	raw Array. For more details, see Mozilla's (slice
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:slice]</description>
        <parameters>
          <parameter name="begin" type="Integer" usage="required"/>
          <parameter name="end" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="splice" scope="instance">
        <description>This method behaves exactly like the Array.splice method
	with the caveat that it returns a dojo.NodeList and not a
	raw Array. For more details, see Mozilla's (splice
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:splice]
	For backwards compatibility, calling .end() on the spliced NodeList
	does not return the original NodeList -- splice alters the NodeList in place.</description>
        <parameters>
          <parameter name="index" type="Integer" usage="required"/>
          <parameter name="howmany" type="Integer" usage="optional"/>
          <parameter name="item" type="Object" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList</return-description>
      </method>
      <method name="indexOf" scope="instance">
        <description>For more details on the behavior of indexOf, see Mozilla's
	(indexOf
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf]</description>
        <parameters>
          <parameter name="value" type="Object:" usage="required"/>
          <parameter name="fromIndex" type="Integer:" usage="optional"/>
        </parameters>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="instance">
        <description>For more details on the behavior of lastIndexOf, see
	Mozilla's (lastIndexOf
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:lastIndexOf]</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
        </parameters>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="callback" type="Function:" usage="required"/>
          <parameter name="thisObject" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="callback" type="Function:" usage="required"/>
          <parameter name="thisObject" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="concat" scope="instance">
        <description>This method behaves exactly like the Array.concat method
	with the caveat that it returns a `dojo.NodeList` and not a
	raw Array. For more details, see the (Array.concat
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:concat]</description>
        <parameters>
          <parameter name="item" type="Object" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="obj" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="thisObj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="coords" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="position" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <parameters>
          <parameter name="className" type="String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="removeClass" scope="instance">
        <parameters>
          <parameter name="className" type="String|Array" usage="optional"/>
        </parameters>
        <return-description>dojo.NodeList, this list</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="toggleClass" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required"/>
          <parameter name="condition" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="methodName" type="String" usage="required"/>
          <parameter name="objOrFunc" type="Object|Function|String" usage="required"/>
          <parameter name="funcName" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="empty" scope="instance">
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="queryOrNode" type="String||Node" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="orphan" scope="instance">
        <parameters>
          <parameter name="filter" type="String" usage="optional"/>
        </parameters>
        <return-description>`dojo.NodeList` containing the orphaned elements</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="adopt" scope="instance">
        <parameters>
          <parameter name="queryOrListOrNode" type="String||Array||DomNode" usage="required"/>
          <parameter name="position" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="queryStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="filter" type="String|Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="instantiate" scope="instance">
        <parameters>
          <parameter name="declaredClass" type="String|Object" usage="required"/>
          <parameter name="properties" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="at" scope="instance">
        <parameters>
          <parameter name="index" type="Integer" usage="one-or-more"/>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="delegate" scope="instance">
        <description>Sets up event handlers that can catch events on any subnodes matching a given selector,
	including nodes created after delegate() has been called.
	This allows an app to setup a single event handler on a high level node, rather than many
	event handlers on subnodes. For example, one onclick handler for a Tree widget, rather than separate
	handlers for each node in the tree.
	Since setting up many event handlers is expensive, this can increase performance.
	Note that delegate() will not work for events that don't bubble, like focus.
	onmouseenter/onmouseleave also don't currently work.</description>
        <parameters>
          <parameter name="selector" type="String" usage="required"/>
          <parameter name="eventName" type="String" usage="required"/>
          <parameter name="fn" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="dtl" scope="instance">
        <parameters>
          <parameter name="template" type="dojox.dtl.__StringArgs|String" usage="required"/>
          <parameter name="context" type="dojox.dtl.__ObjectArgs|Object" usage="required"/>
        </parameters>
      </method>
      <method name="addClassFx" scope="instance">
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="removeClassFx" scope="instance">
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="toggleClassFx" scope="instance">
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="sizeTo" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="highlight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeTo" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeTo" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_wrap" scope="instance" type="Object"/>
      <property name="_adaptAsMap" scope="instance" type="Object"/>
      <property name="_adaptAsForEach" scope="instance" type="Object"/>
      <property name="_adaptAsFilter" scope="instance" type="Object"/>
      <property name="_adaptWithCondition" scope="instance" type="Object"/>
      <property name="events" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.NodeList._placeMultiple">
    <methods/>
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList.val">
    <methods/>
  </class>
  <class type="dojo.NodeList.val.0">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="options" scope="instance" type="Object"/>
      <property name="checked" scope="instance" type="bool"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList.prototype">
    <properties>
      <property name="remove" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Stateful">
    <methods>
      <method name="get" scope="instance">
        <description>Get a named property on a Stateful object. The property may
	potentially be retrieved via a getter method in subclasses. In the base class
	this just retrieves the object's property.
	For example:
		stateful = new dojo.Stateful({foo: 3});
		stateful.get("foo") // returns 3
		stateful.foo // returns 3</description>
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a stateful object and notifies any watchers of
	the property. A programmatic setter may be defined in subclasses.
	For example:
		stateful = new dojo.Stateful();
		stateful.watch(function(name, oldValue, value){
			// this will be called on the set below
		}
		stateful.set(foo, 5);
	set() may also be called with a hash of name/value pairs, ex:
		myObj.set({
			foo: "Howdy",
			bar: 3
		})
	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)</description>
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="watch" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="optional"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
        <return-description>An object handle for the watch. The unwatch method of this object
	can be used to discontinue watching this property:
		var watchHandle = obj.watch("foo", callback);
		watchHandle.unwatch(); // callback won't be called now</return-description>
      </method>
      <method name="_watchCallbacks" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="ignoreCatchall" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.Color">
    <methods>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="g" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
          <parameter name="a" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColor" scope="instance">
        <parameters>
          <parameter name="color" type="Array|String|Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="sanitize" scope="instance">
        <description>the default implementation does nothing, include dojo.colors to
	augment it with real checks</description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="toRgb" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toRgba" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toHex" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toCss" scope="instance">
        <parameters>
          <parameter name="includeAlpha" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.Color.named">
    <properties>
      <property name="black" scope="instance" type="Array"/>
      <property name="silver" scope="instance" type="Array"/>
      <property name="gray" scope="instance" type="Array"/>
      <property name="white" scope="instance" type="Array"/>
      <property name="maroon" scope="instance" type="Array"/>
      <property name="red" scope="instance" type="Array"/>
      <property name="purple" scope="instance" type="Array"/>
      <property name="fuchsia" scope="instance" type="Array"/>
      <property name="green" scope="instance" type="Array"/>
      <property name="lime" scope="instance" type="Array"/>
      <property name="olive" scope="instance" type="Array"/>
      <property name="yellow" scope="instance" type="Array"/>
      <property name="navy" scope="instance" type="Array"/>
      <property name="blue" scope="instance" type="Array"/>
      <property name="teal" scope="instance" type="Array"/>
      <property name="aqua" scope="instance" type="Array"/>
      <property name="transparent" scope="instance" type="Array"/>
      <property name="aliceblue" scope="instance" type="Array"/>
      <property name="antiquewhite" scope="instance" type="Array"/>
      <property name="aquamarine" scope="instance" type="Array"/>
      <property name="azure" scope="instance" type="Array"/>
      <property name="beige" scope="instance" type="Array"/>
      <property name="bisque" scope="instance" type="Array"/>
      <property name="blanchedalmond" scope="instance" type="Array"/>
      <property name="blueviolet" scope="instance" type="Array"/>
      <property name="brown" scope="instance" type="Array"/>
      <property name="burlywood" scope="instance" type="Array"/>
      <property name="cadetblue" scope="instance" type="Array"/>
      <property name="chartreuse" scope="instance" type="Array"/>
      <property name="chocolate" scope="instance" type="Array"/>
      <property name="coral" scope="instance" type="Array"/>
      <property name="cornflowerblue" scope="instance" type="Array"/>
      <property name="cornsilk" scope="instance" type="Array"/>
      <property name="crimson" scope="instance" type="Array"/>
      <property name="cyan" scope="instance" type="Array"/>
      <property name="darkblue" scope="instance" type="Array"/>
      <property name="darkcyan" scope="instance" type="Array"/>
      <property name="darkgoldenrod" scope="instance" type="Array"/>
      <property name="darkgray" scope="instance" type="Array"/>
      <property name="darkgreen" scope="instance" type="Array"/>
      <property name="darkgrey" scope="instance" type="Array"/>
      <property name="darkkhaki" scope="instance" type="Array"/>
      <property name="darkmagenta" scope="instance" type="Array"/>
      <property name="darkolivegreen" scope="instance" type="Array"/>
      <property name="darkorange" scope="instance" type="Array"/>
      <property name="darkorchid" scope="instance" type="Array"/>
      <property name="darkred" scope="instance" type="Array"/>
      <property name="darksalmon" scope="instance" type="Array"/>
      <property name="darkseagreen" scope="instance" type="Array"/>
      <property name="darkslateblue" scope="instance" type="Array"/>
      <property name="darkslategray" scope="instance" type="Array"/>
      <property name="darkslategrey" scope="instance" type="Array"/>
      <property name="darkturquoise" scope="instance" type="Array"/>
      <property name="darkviolet" scope="instance" type="Array"/>
      <property name="deeppink" scope="instance" type="Array"/>
      <property name="deepskyblue" scope="instance" type="Array"/>
      <property name="dimgray" scope="instance" type="Array"/>
      <property name="dimgrey" scope="instance" type="Array"/>
      <property name="dodgerblue" scope="instance" type="Array"/>
      <property name="firebrick" scope="instance" type="Array"/>
      <property name="floralwhite" scope="instance" type="Array"/>
      <property name="forestgreen" scope="instance" type="Array"/>
      <property name="gainsboro" scope="instance" type="Array"/>
      <property name="ghostwhite" scope="instance" type="Array"/>
      <property name="gold" scope="instance" type="Array"/>
      <property name="goldenrod" scope="instance" type="Array"/>
      <property name="greenyellow" scope="instance" type="Array"/>
      <property name="grey" scope="instance" type="Array"/>
      <property name="honeydew" scope="instance" type="Array"/>
      <property name="hotpink" scope="instance" type="Array"/>
      <property name="indianred" scope="instance" type="Array"/>
      <property name="indigo" scope="instance" type="Array"/>
      <property name="ivory" scope="instance" type="Array"/>
      <property name="khaki" scope="instance" type="Array"/>
      <property name="lavender" scope="instance" type="Array"/>
      <property name="lavenderblush" scope="instance" type="Array"/>
      <property name="lawngreen" scope="instance" type="Array"/>
      <property name="lemonchiffon" scope="instance" type="Array"/>
      <property name="lightblue" scope="instance" type="Array"/>
      <property name="lightcoral" scope="instance" type="Array"/>
      <property name="lightcyan" scope="instance" type="Array"/>
      <property name="lightgoldenrodyellow" scope="instance" type="Array"/>
      <property name="lightgray" scope="instance" type="Array"/>
      <property name="lightgreen" scope="instance" type="Array"/>
      <property name="lightgrey" scope="instance" type="Array"/>
      <property name="lightpink" scope="instance" type="Array"/>
      <property name="lightsalmon" scope="instance" type="Array"/>
      <property name="lightseagreen" scope="instance" type="Array"/>
      <property name="lightskyblue" scope="instance" type="Array"/>
      <property name="lightslategray" scope="instance" type="Array"/>
      <property name="lightslategrey" scope="instance" type="Array"/>
      <property name="lightsteelblue" scope="instance" type="Array"/>
      <property name="lightyellow" scope="instance" type="Array"/>
      <property name="limegreen" scope="instance" type="Array"/>
      <property name="linen" scope="instance" type="Array"/>
      <property name="magenta" scope="instance" type="Array"/>
      <property name="mediumaquamarine" scope="instance" type="Array"/>
      <property name="mediumblue" scope="instance" type="Array"/>
      <property name="mediumorchid" scope="instance" type="Array"/>
      <property name="mediumpurple" scope="instance" type="Array"/>
      <property name="mediumseagreen" scope="instance" type="Array"/>
      <property name="mediumslateblue" scope="instance" type="Array"/>
      <property name="mediumspringgreen" scope="instance" type="Array"/>
      <property name="mediumturquoise" scope="instance" type="Array"/>
      <property name="mediumvioletred" scope="instance" type="Array"/>
      <property name="midnightblue" scope="instance" type="Array"/>
      <property name="mintcream" scope="instance" type="Array"/>
      <property name="mistyrose" scope="instance" type="Array"/>
      <property name="moccasin" scope="instance" type="Array"/>
      <property name="navajowhite" scope="instance" type="Array"/>
      <property name="oldlace" scope="instance" type="Array"/>
      <property name="olivedrab" scope="instance" type="Array"/>
      <property name="orange" scope="instance" type="Array"/>
      <property name="orangered" scope="instance" type="Array"/>
      <property name="orchid" scope="instance" type="Array"/>
      <property name="palegoldenrod" scope="instance" type="Array"/>
      <property name="palegreen" scope="instance" type="Array"/>
      <property name="paleturquoise" scope="instance" type="Array"/>
      <property name="palevioletred" scope="instance" type="Array"/>
      <property name="papayawhip" scope="instance" type="Array"/>
      <property name="peachpuff" scope="instance" type="Array"/>
      <property name="peru" scope="instance" type="Array"/>
      <property name="pink" scope="instance" type="Array"/>
      <property name="plum" scope="instance" type="Array"/>
      <property name="powderblue" scope="instance" type="Array"/>
      <property name="rosybrown" scope="instance" type="Array"/>
      <property name="royalblue" scope="instance" type="Array"/>
      <property name="saddlebrown" scope="instance" type="Array"/>
      <property name="salmon" scope="instance" type="Array"/>
      <property name="sandybrown" scope="instance" type="Array"/>
      <property name="seagreen" scope="instance" type="Array"/>
      <property name="seashell" scope="instance" type="Array"/>
      <property name="sienna" scope="instance" type="Array"/>
      <property name="skyblue" scope="instance" type="Array"/>
      <property name="slateblue" scope="instance" type="Array"/>
      <property name="slategray" scope="instance" type="Array"/>
      <property name="slategrey" scope="instance" type="Array"/>
      <property name="snow" scope="instance" type="Array"/>
      <property name="springgreen" scope="instance" type="Array"/>
      <property name="steelblue" scope="instance" type="Array"/>
      <property name="tan" scope="instance" type="Array"/>
      <property name="thistle" scope="instance" type="Array"/>
      <property name="tomato" scope="instance" type="Array"/>
      <property name="turquoise" scope="instance" type="Array"/>
      <property name="violet" scope="instance" type="Array"/>
      <property name="wheat" scope="instance" type="Array"/>
      <property name="whitesmoke" scope="instance" type="Array"/>
      <property name="yellowgreen" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo._base">
    <properties>
      <property name="Color" scope="instance" type="Object"/>
      <property name="Deferred" scope="instance" type="Object"/>
      <property name="NodeList" scope="instance" type="Object"/>
      <property name="array" scope="instance" type="Object"/>
      <property name="connect" scope="instance" type="Object"/>
      <property name="declare" scope="instance" type="Object"/>
      <property name="event" scope="instance" type="Object"/>
      <property name="fx" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
      <property name="json" scope="instance" type="Object"/>
      <property name="lang" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
      <property name="xhr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Deferred">
    <description>The dojo.Deferred API is based on the concept of promises that provide a
	generic interface into the eventual completion of an asynchronous action.
	The motivation for promises fundamentally is about creating a
	separation of concerns that allows one to achieve the same type of
	call patterns and logical data flow in asynchronous code as can be
	achieved in synchronous code. Promises allows one
	to be able to call a function purely with arguments needed for
	execution, without conflating the call with concerns of whether it is
	sync or async. One shouldn't need to alter a call's arguments if the
	implementation switches from sync to async (or vice versa). By having
	async functions return promises, the concerns of making the call are
	separated from the concerns of asynchronous interaction (which are
	handled by the promise).
	The dojo.Deferred is a type of promise that provides methods for fulfilling the
	promise with a successful result or an error. The most important method for
	working with Dojo's promises is the then() method, which follows the
	CommonJS proposed promise API. An example of using a Dojo promise:
	 	var resultingPromise = someAsyncOperation.then(function(result){
			... handle result ...
		},
		function(error){
			... handle error ...
		});
	The .then() call returns a new promise that represents the result of the
	execution of the callback. The callbacks will never affect the original promises value.
	The dojo.Deferred instances also provide the following functions for backwards compatibility:
	* addCallback(handler)
	* addErrback(handler)
	* callback(result)
	* errback(result)
	Callbacks are allowed to return promises themselves, so
	you can build complicated sequences of events with ease.
	The creator of the Deferred may specify a canceller.  The canceller
	is a function that will be called if Deferred.cancel is called
	before the Deferred fires. You can use this to implement clean
	aborting of an XMLHttpRequest, etc. Note that cancel will fire the
	deferred with a CancelledError (unless your canceller returns
	another kind of error), so the errbacks should be prepared to
	handle that error for cancellable Deferreds.</description>
    <methods>
      <method name="addCallback" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="addErrback" scope="instance">
        <parameters>
          <parameter name="errback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="addBoth" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="resolve" scope="instance"/>
      <method name="callback" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reject" scope="instance"/>
      <method name="errback" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="progress" scope="instance">
        <parameters>
          <parameter name="update" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCallbacks" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
          <parameter name="errback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="then" scope="instance"/>
      <method name="cancel" scope="instance"/>
    </methods>
    <properties>
      <property name="fired" scope="instance-prototype" type="Number"/>
      <property name="promise" scope="instance" type="Object"/>
      <property name="results" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="Object">
    <methods>
      <method name="freeze" scope="instance"/>
      <method name="inherited" scope="instance">
        <description>This method is used inside method of classes produced with
	dojo.declare to call a super method (next in the chain). It is
	used for manually controlled chaining. Consider using the regular
	chaining, because it is faster. Use "this.inherited()" only in
	complex cases.
	This method cannot me called from automatically chained
	constructors including the case of a special (legacy)
	constructor chaining. It cannot be called from chained methods.
	If "this.inherited()" cannot find the next-in-chain method, it
	does nothing and returns "undefined". The last method in chain
	can be a default method implemented in Object, which will be
	called last.
	If "name" is specified, it is assumed that the method that
	received "args" is the parent method for this call. It is looked
	up in the chain list and if it is found the next-in-chain method
	is called. If it is not found, the first-in-chain method is
	called.
	If "name" is not specified, it will be derived from the calling
	method (using a methoid property "nom").</description>
        <parameters>
          <parameter name="name" type="String" usage="optional"/>
          <parameter name="args" type="Arguments" usage="required"/>
          <parameter name="newArgs" type="Object" usage="optional"/>
        </parameters>
        <return-description>Whatever is returned by a super method, or a super method itself,
	if "true" was specified as newArgs.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getInherited" scope="instance">
        <description>This method is a convenience method for "this.inherited()".
	It uses the same algorithm but instead of executing a super
	method, it returns it, or "undefined" if not found.</description>
        <parameters>
          <parameter name="name" type="String" usage="optional"/>
          <parameter name="args" type="Arguments" usage="required"/>
        </parameters>
        <return-description>Returns a super method (Function) or "undefined".</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="isInstanceOf" scope="instance">
        <description>This method is used with instances of classes produced with
	dojo.declare to determine of they support a certain interface or
	not. It models "instanceof" operator.</description>
        <parameters>
          <parameter name="cls" type="Function" usage="required"/>
        </parameters>
        <return-description>"true", if this object is inherited from this class, "false"
	otherwise.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="extend" scope="instance">
        <description>Adds source properties to the constructor's prototype. It can
	override existing properties.
	This method is similar to dojo.extend function, but it is specific
	to constructors produced by dojo.declare. It is implemented
	using dojo.safeMixin, and it skips a constructor property,
	and properly decorates copied functions.</description>
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="toString" scope="instance" type="Object"/>
      <property name="hasOwnProperty" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList._stash">
    <methods/>
    <properties>
      <property name="_parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList.attr">
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList.style">
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList.addContent">
    <description>a copy of the HTML content is added to each item in the
	list, with an optional position argument. If no position
	argument is provided, the content is appended to the end of
	each item.</description>
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="Array">
    <properties>
      <property name="slice" scope="instance" type="Object"/>
      <property name="concat" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="navigator">
    <properties>
      <property name="userAgent" scope="instance" type="Object"/>
      <property name="appVersion" scope="instance" type="Object"/>
      <property name="cookieEnabled" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.config">
    <properties>
      <property name="modulePaths" scope="instance" type="Object"/>
      <property name="addOnLoad" scope="instance" type="Object"/>
      <property name="hashPollFrequency" scope="instance" type="Number"/>
      <property name="extraLocale" scope="instance" type="Array"/>
      <property name="dojoBlankHtmlUrl" scope="instance" type="Object"/>
      <property name="debugContainerId" scope="instance" type="String"/>
      <property name="debugHeight" scope="instance" type="Number"/>
      <property name="consoleLogFuncs" scope="instance" type="Array"/>
      <property name="timezoneFileBasePath" scope="instance" type="Object"/>
      <property name="timezoneLoadingScheme" scope="instance" type="String"/>
      <property name="ioPublish" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="console">
    <methods>
      <method name="log" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="debug" scope="instance"/>
    </methods>
    <properties>
      <property name="warn" scope="instance" type="Object"/>
      <property name="error" scope="instance" type="Object"/>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="e">
    <properties>
      <property name="stack" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo._modulePrefixes"/>
  <class type="dojo._modulePrefixes.dojo">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo._modulePrefixes.doh">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo._modulePrefixes.tests">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo._Url">
    <description>Each argument is evaluated in order relative to the next until
	a canonical uri is produced. To get an absolute Uri relative to
	the current document use:
	new dojo._Url(document.baseURI, url)</description>
    <methods>
      <method name="toString" scope="instance"/>
    </methods>
    <properties>
      <property name="uri" scope="instance" type="Object"/>
      <property name="scheme" scope="instance" type="Object"/>
      <property name="authority" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="fragment" scope="instance" type="Object"/>
      <property name="user" scope="instance" type="Object"/>
      <property name="password" scope="instance" type="Object"/>
      <property name="host" scope="instance" type="Object"/>
      <property name="port" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="define">
    <properties>
      <property name="vendor" scope="instance" type="String"/>
      <property name="version" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window">
    <properties>
      <property name="dojo" scope="instance" type="Object"/>
      <property name="dijit" scope="instance" type="Object"/>
      <property name="dojox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._xdDebugQueue">
    <properties>
      <property name="currentResourceName" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._base._loader">
    <properties>
      <property name="loader_debug" scope="instance" type="Object"/>
      <property name="loader_xd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._xdDefList">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._listener">
    <methods>
      <method name="getDispatcher" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo._event_listener">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="fp" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="event" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeEventName" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixCallback" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="fp" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fixEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setKeyChar" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo._event_listener._punctMap">
    <properties>
      <property name="106" scope="instance" type="Number"/>
      <property name="111" scope="instance" type="Number"/>
      <property name="186" scope="instance" type="Number"/>
      <property name="187" scope="instance" type="Number"/>
      <property name="188" scope="instance" type="Number"/>
      <property name="189" scope="instance" type="Number"/>
      <property name="190" scope="instance" type="Number"/>
      <property name="191" scope="instance" type="Number"/>
      <property name="192" scope="instance" type="Number"/>
      <property name="219" scope="instance" type="Number"/>
      <property name="220" scope="instance" type="Number"/>
      <property name="221" scope="instance" type="Number"/>
      <property name="222" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.keys">
    <properties>
      <property name="BACKSPACE" scope="instance" type="Number"/>
      <property name="TAB" scope="instance" type="Number"/>
      <property name="CLEAR" scope="instance" type="Number"/>
      <property name="ENTER" scope="instance" type="Number"/>
      <property name="SHIFT" scope="instance" type="Number"/>
      <property name="CTRL" scope="instance" type="Number"/>
      <property name="ALT" scope="instance" type="Number"/>
      <property name="META" scope="instance" type="Object"/>
      <property name="PAUSE" scope="instance" type="Number"/>
      <property name="CAPS_LOCK" scope="instance" type="Number"/>
      <property name="ESCAPE" scope="instance" type="Number"/>
      <property name="SPACE" scope="instance" type="Number"/>
      <property name="PAGE_UP" scope="instance" type="Number"/>
      <property name="PAGE_DOWN" scope="instance" type="Number"/>
      <property name="END" scope="instance" type="Number"/>
      <property name="HOME" scope="instance" type="Number"/>
      <property name="LEFT_ARROW" scope="instance" type="Number"/>
      <property name="UP_ARROW" scope="instance" type="Number"/>
      <property name="RIGHT_ARROW" scope="instance" type="Number"/>
      <property name="DOWN_ARROW" scope="instance" type="Number"/>
      <property name="INSERT" scope="instance" type="Number"/>
      <property name="DELETE" scope="instance" type="Number"/>
      <property name="HELP" scope="instance" type="Number"/>
      <property name="LEFT_WINDOW" scope="instance" type="Number"/>
      <property name="RIGHT_WINDOW" scope="instance" type="Number"/>
      <property name="SELECT" scope="instance" type="Number"/>
      <property name="NUMPAD_0" scope="instance" type="Number"/>
      <property name="NUMPAD_1" scope="instance" type="Number"/>
      <property name="NUMPAD_2" scope="instance" type="Number"/>
      <property name="NUMPAD_3" scope="instance" type="Number"/>
      <property name="NUMPAD_4" scope="instance" type="Number"/>
      <property name="NUMPAD_5" scope="instance" type="Number"/>
      <property name="NUMPAD_6" scope="instance" type="Number"/>
      <property name="NUMPAD_7" scope="instance" type="Number"/>
      <property name="NUMPAD_8" scope="instance" type="Number"/>
      <property name="NUMPAD_9" scope="instance" type="Number"/>
      <property name="NUMPAD_MULTIPLY" scope="instance" type="Number"/>
      <property name="NUMPAD_PLUS" scope="instance" type="Number"/>
      <property name="NUMPAD_ENTER" scope="instance" type="Number"/>
      <property name="NUMPAD_MINUS" scope="instance" type="Number"/>
      <property name="NUMPAD_PERIOD" scope="instance" type="Number"/>
      <property name="NUMPAD_DIVIDE" scope="instance" type="Number"/>
      <property name="F1" scope="instance" type="Number"/>
      <property name="F2" scope="instance" type="Number"/>
      <property name="F3" scope="instance" type="Number"/>
      <property name="F4" scope="instance" type="Number"/>
      <property name="F5" scope="instance" type="Number"/>
      <property name="F6" scope="instance" type="Number"/>
      <property name="F7" scope="instance" type="Number"/>
      <property name="F8" scope="instance" type="Number"/>
      <property name="F9" scope="instance" type="Number"/>
      <property name="F10" scope="instance" type="Number"/>
      <property name="F11" scope="instance" type="Number"/>
      <property name="F12" scope="instance" type="Number"/>
      <property name="F13" scope="instance" type="Number"/>
      <property name="F14" scope="instance" type="Number"/>
      <property name="F15" scope="instance" type="Number"/>
      <property name="NUM_LOCK" scope="instance" type="Number"/>
      <property name="SCROLL_LOCK" scope="instance" type="Number"/>
      <property name="copyKey" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.mouseButtons">
    <methods>
      <method name="isButton" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="button" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isMiddle" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isRight" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="LEFT" scope="instance" type="Number"/>
      <property name="MIDDLE" scope="instance" type="Number"/>
      <property name="RIGHT" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo._ie_listener">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handlers" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.Animation">
    <description>To use, simply require dojox.fx.ext-dojo.reverse and a reverse()
	method will be added to all dojo.Animations.
	It can be used at any time during the animation. It does not
	need to be called when it ends. It also reverses the easing -
	if dojo.fx.easing.quadIn is used, dojo.fx.easing.quadOut will
	be used when animating backwards.</description>
    <methods>
      <method name="easing" scope="instance"/>
      <method name="_fire" scope="instance">
        <description>Convenience function.  Fire event "evt" and pass it the
	arguments specified in "args".
	Fires the callback in the scope of the `dojo.Animation`
	instance.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
          <parameter name="args" type="Array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="delay" type="int" usage="optional"/>
          <parameter name="gotoStart" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>dojo.Animation
	The instance to allow chaining.</return-description>
      </method>
      <method name="_play" scope="instance">
        <parameters>
          <parameter name="gotoStart" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="pause" scope="instance">
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="gotoPercent" scope="instance">
        <parameters>
          <parameter name="percent" type="Decimal" usage="required"/>
          <parameter name="andPlay" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="stop" scope="instance">
        <parameters>
          <parameter name="gotoEnd" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="status" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cycle" scope="instance">
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_clearTimer" scope="instance"/>
    </methods>
    <properties>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="curve" scope="instance-prototype" type="dojo._Line|Array"/>
      <property name="repeat" scope="instance" type="Integer"/>
      <property name="rate" scope="instance" type="Integer"/>
      <property name="delay" scope="instance" type="Integer"/>
      <property name="beforeBegin" scope="instance" type="Event"/>
      <property name="onBegin" scope="instance" type="Event"/>
      <property name="onAnimate" scope="instance" type="Event"/>
      <property name="onEnd" scope="instance" type="Event"/>
      <property name="onPlay" scope="instance" type="Event"/>
      <property name="onPause" scope="instance" type="Event"/>
      <property name="onStop" scope="instance" type="Event"/>
      <property name="_percent" scope="instance" type="Number"/>
      <property name="_startRepeatCount" scope="instance" type="Number"/>
      <property name="_reversed" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.Animation._getStep">
    <methods/>
    <properties>
      <property name="_percent" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Animation._startTimer">
    <methods/>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Animation._stopTimer">
    <methods/>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__AnimArgs" superclass="dojo.__FadeArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.__FadeArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._Line">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="int"/>
      <property name="end" scope="instance" type="int"/>
    </properties>
  </class>
  <class type="dojo.__FadeArgs">
    <methods>
      <method name="easing" scope="instance"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="DOMNode|String"/>
      <property name="duration" scope="instance" type="Integer"/>
    </properties>
  </class>
  <class type="dojo._extraNames">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__XhrArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="handleAs" scope="instance" type="String"/>
      <property name="sync" scope="instance" type="Boolean"/>
      <property name="headers" scope="instance" type="Object"/>
      <property name="failOk" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.contentHandlers">
    <description>A map of availble XHR transport handle types. Name matches the
	`handleAs` attribute passed to XHR calls. Each contentHandler is
	called, passing the xhr object for manipulation. The return value
	from the contentHandler will be passed to the `load` or `handle`
	functions defined in the original xhr call.</description>
    <methods>
      <method name="text" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json-comment-filtered" scope="instance">
        <description>A contentHandler which expects comment-filtered JSON.
	the json-comment-filtered option was implemented to prevent
	"JavaScript Hijacking", but it is less secure than standard JSON. Use
	standard JSON instead. JSON prefixing can be used to subvert hijacking.
	Will throw a notice suggesting to use application/json mimetype, as
	json-commenting can introduce security issues. To decrease the chances of hijacking,
	use the standard `json` contentHandler, and prefix your "JSON" with: {}&amp;&amp;
	use djConfig.useCommentedJson = true to turn off the notice</description>
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="javascript" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="xml" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
        </return-types>
      </method>
      <method name="json-comment-optional" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.__IoArgs">
    <methods>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required"/>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required"/>
        </parameters>
      </method>
      <method name="error" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required"/>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required"/>
        </parameters>
      </method>
      <method name="handle" scope="instance">
        <parameters>
          <parameter name="loadOrError" type="String" usage="required"/>
          <parameter name="response" type="Object" usage="required"/>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="timeout" scope="instance" type="Integer"/>
      <property name="form" scope="instance" type="DOMNode"/>
      <property name="preventCache" scope="instance" type="Boolean"/>
      <property name="handleAs" scope="instance" type="String"/>
      <property name="ioPublish" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.__IoCallbackArgs">
    <methods/>
    <properties>
      <property name="args" scope="instance" type="Object"/>
      <property name="xhr" scope="instance" type="XMLHttpRequest"/>
      <property name="url" scope="instance" type="String"/>
      <property name="query" scope="instance" type="String"/>
      <property name="handleAs" scope="instance" type="String"/>
      <property name="id" scope="instance" type="String"/>
      <property name="canDelete" scope="instance" type="Boolean"/>
      <property name="json" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__IoPublish">
    <methods/>
    <properties>
      <property name="start" scope="instance" type="String"/>
      <property name="send" scope="instance" type="String"/>
      <property name="load" scope="instance" type="String"/>
      <property name="error" scope="instance" type="String"/>
      <property name="done" scope="instance" type="String"/>
      <property name="stop" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="window.console">
    <methods>
      <method name="log" scope="instance"/>
      <method name="debug" scope="instance"/>
      <method name="info" scope="instance"/>
      <method name="warn" scope="instance"/>
      <method name="error" scope="instance"/>
      <method name="assert" scope="instance">
        <parameters>
          <parameter name="truth" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dir" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dirxml" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="group" scope="instance"/>
      <method name="groupEnd" scope="instance"/>
      <method name="time" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timeEnd" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="count" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="trace" scope="instance">
        <parameters>
          <parameter name="_value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="profile" scope="instance"/>
      <method name="profileEnd" scope="instance"/>
      <method name="clear" scope="instance"/>
      <method name="open" scope="instance"/>
      <method name="close" scope="instance"/>
      <method name="_restoreBorder" scope="instance"/>
      <method name="openDomInspector" scope="instance"/>
      <method name="_closeDomInspector" scope="instance"/>
      <method name="openConsole" scope="instance"/>
      <method name="openObjectInspector" scope="instance"/>
      <method name="recss" scope="instance"/>
    </methods>
    <properties>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo._firebug">
    <properties>
      <property name="firebug" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.back">
    <methods>
      <method name="getHash" scope="instance"/>
      <method name="setHash" scope="instance">
        <parameters>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <description>Only call this method before the page's DOM is finished loading. Otherwise
	it will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,
	in order for this method to work, dojo.back will need to be part of a build layer.</description>
        <return-types>
          <return-type type="prevent reinit"/>
        </return-types>
      </method>
      <method name="setInitialState" scope="instance">
        <description>It is recommended that you call this method as part of an event
	listener that is registered via dojo.addOnLoad().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToHistory" scope="instance">
        <description>To support getting back button notifications, the object
	argument should implement a function called either "back",
	"backButton", or "handle". The string "back" will be passed as
	the first and only argument to this callback.
	To support getting forward button notifications, the object
	argument should implement a function called either "forward",
	"forwardButton", or "handle". The string "forward" will be
	passed as the first and only argument to this callback.
	If you want the browser location string to change, define "changeUrl" on the object. If the
	value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
	identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
	not evaluate to false, that value will be used as the fragment identifier. For example,
	if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
	There are problems with using dojo.back with semantically-named fragment identifiers
	("hash values" on an URL). In most browsers it will be hard for dojo.back to know
	distinguish a back from a forward event in those cases. For back/forward support to
	work best, the fragment ID should always be a unique value (something using new Date().getTime()
	for example). If you want to detect hash changes using semantic fragment IDs, then
	consider using dojo.hash instead (in Dojo 1.4+).</description>
        <parameters>
          <parameter name="args" type="dojo.__backArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeLoaded" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="ifrLoc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="goBack" scope="instance" type="Object"/>
      <property name="goForward" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window.frames">
    <properties>
      <property name="dj_history" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.behavior">
    <description>A very simple, lightweight mechanism for applying code to
	existing documents, based around `dojo.query` (CSS3 selectors) for node selection,
	and a simple two-command API: `dojo.behavior.add()` and `dojo.behavior.apply()`;
	Behaviors apply to a given page, and are registered following the syntax
	options described by `dojo.behavior.add` to match nodes to actions, or "behaviors".
	Added behaviors are applied to the current DOM when .apply() is called,
	matching only new nodes found since .apply() was last called.</description>
    <methods>
      <method name="add" scope="instance">
        <description>Add the specified behavior to the list of behaviors which will
	be applied the next time apply() is called. Calls to add() for
	an already existing behavior do not replace the previous rules,
	but are instead additive. New nodes which match the rule will
	have all add()-ed behaviors applied to them when matched.
	The "found" method is a generalized handler that's called as soon
	as the node matches the selector. Rules for values that follow also
	apply to the "found" key.
	The "on*" handlers are attached with `dojo.connect()`, using the
	matching node
	If the value corresponding to the ID key is a function and not a
	list, it's treated as though it was the value of "found".
	dojo.behavior.add() can be called any number of times before
	the DOM is ready. `dojo.behavior.apply()` is called automatically
	by `dojo.addOnLoad`, though can be called to re-apply previously added
	behaviors anytime the DOM changes.
	There are a variety of formats permitted in the behaviorObject</description>
        <parameters>
          <parameter name="behaviorObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <description>Applies all currently registered behaviors to the document,
	taking care to ensure that only incremental updates are made
	since the last time add() or apply() were called.
	If new matching nodes have been added, all rules in a behavior will be
	applied to that node. For previously matched nodes, only
	behaviors which have been added since the last call to apply()
	will be added to the nodes.
	apply() is called once automatically by `dojo.addOnLoad`, so
	registering behaviors with `dojo.behavior.add` before the DOM is
	ready is acceptable, provided the dojo.behavior module is ready.
	Calling appy() manually after manipulating the DOM is required
	to rescan the DOM and apply newly .add()ed behaviors, or to match
	nodes that match existing behaviors when those nodes are added to
	the DOM.</description>
      </method>
    </methods>
    <properties>
      <property name="_behaviors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.cache">
    <description>module and url are used to call `dojo.moduleUrl()` to generate a module URL.
	If value is specified, the cache value for the moduleUrl will be set to
	that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
	in its internal cache and return that cached value for the URL. To clear
	a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
	the URL contents, only modules on the same domain of the page can use this capability.
	The build system can inline the cache values though, to allow for xdomain hosting.</description>
    <methods>
      <method name="_sanitize" scope="instance">
        <description>Copied from dijit._Templated._sanitizeTemplateString.</description>
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.cldr.monetary">
    <methods>
      <method name="getData" scope="instance">
        <parameters>
          <parameter name="code" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.cldr"/>
  <class type="dojo.cldr.supplemental">
    <methods>
      <method name="getFirstDayOfWeek" scope="instance">
        <description>Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
	e.g. Sunday (returns 0), or Monday (returns 1)</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_region" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getWeekend" scope="instance">
        <description>Returns a hash containing the start and end days of the weekend according to local custom using locale,
	or by default in the user's locale.
	e.g. {start:6, end:0}</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.colors">
    <methods>
      <method name="makeGrey" scope="instance">
        <parameters>
          <parameter name="g" type="Number" usage="required"/>
          <parameter name="a" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.__cookieProps">
    <methods/>
    <properties>
      <property name="expires" scope="instance" type="Date|String|Number"/>
      <property name="path" scope="instance" type="String"/>
      <property name="domain" scope="instance" type="String"/>
      <property name="secure" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.cookie">
    <description>If one argument is passed, returns the value of the cookie
	For two or more arguments, acts as a setter.</description>
    <methods>
      <method name="isSupported" scope="instance"/>
    </methods>
  </class>
  <class type="document">
    <properties>
      <property name="cookie" scope="instance" type="Object"/>
      <property name="styleSheets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.currency">
    <description>extends dojo.number to provide culturally-appropriate formatting of values
	in various world currencies, including use of a currency symbol.  The currencies are specified
	by a three-letter international symbol in all uppercase, and support for the currencies is
	provided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which
	currency support is included.  A fixed number of decimal places is determined based
	on the currency type and is not determined by the 'pattern' argument.  The fractional
	portion is optional, by default, and variable length decimals are not supported.</description>
    <methods>
      <method name="_mixInDefaults" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <description>Create a string from a Number using a known, localized pattern.
	[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)
	appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
	as well as the appropriate symbols and delimiters and number of decimal places.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="options" type="dojo.currency.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="regexp" scope="instance">
        <description>Returns regular expression with positive and negative match, group and decimal separators
	Note: the options.places default, the number of decimal places to accept, is defined by the currency type.</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Number from a string using a known, localized pattern.
	[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	are chosen appropriate to the locale, as well as the appropriate symbols and delimiters
	and number of decimal places.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required"/>
          <parameter name="options" type="dojo.currency.__ParseOptions" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.currency.__FormatOptions" superclass="dojo.number.__FormatOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.number.__FormatOptions" scope="instance"/>
    </mixins>
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="symbol" scope="instance" type="String"/>
      <property name="currency" scope="instance" type="String"/>
      <property name="places" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.currency.__ParseOptions" superclass="dojo.number.__ParseOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.number.__ParseOptions" scope="instance"/>
    </mixins>
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="currency" scope="instance" type="String"/>
      <property name="symbol" scope="instance" type="String"/>
      <property name="places" scope="instance" type="Number"/>
      <property name="fractional" scope="instance" type="Boolean|Array"/>
    </properties>
  </class>
  <class type="dojo.data"/>
  <class type="dojo.data.ItemFileReadStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemsFromLoadedData" scope="instance">
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
        <return-description>array
	Array of items in store item format.</return-description>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required"/>
          <parameter name="parentItem" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="_ccUrl" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance-prototype" type="Object"/>
      <property name="typeMap" scope="instance" type="Object"/>
      <property name="clearOnClose" scope="instance-prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="failOk" scope="instance-prototype" type="bool"/>
      <property name="hierarchical" scope="instance-prototype" type="Object"/>
      <property name="_jsonFileUrl" scope="instance-prototype" type="Object"/>
      <property name="_jsonData" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance-prototype" type="Array"/>
      <property name="_itemsByIdentity" scope="instance-prototype" type="Object"/>
      <property name="_labelAttr" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_storeRefPropName" scope="instance" type="String"/>
      <property name="_itemNumPropName" scope="instance" type="String"/>
      <property name="_rootItemPropName" scope="instance" type="String"/>
      <property name="_reverseRefMap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileReadStore._features.dojo.data.api">
    <properties>
      <property name="Identity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileReadStore._datatypeMap">
    <properties>
      <property name="Date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileWriteStore" superclass="dojo.data.ItemFileReadStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_assert" scope="instance">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getIdentifierAttribute" scope="instance"/>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="_removeArrayElement" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="almost" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required"/>
          <parameter name="parentItem" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_removeReferenceFromMap" scope="instance">
        <description>Method to remove an reference map entry for an item and attribute.  This will
	also perform cleanup on the map such that if there are no more references at all to
	the item, its reference object and entry are removed.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required"/>
          <parameter name="parentItem" type="item" usage="required"/>
          <parameter name="attribute" type="strin" usage="required"/>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="instance">
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_getValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_flatten" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="instance"/>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="something" type="The" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required"/>
          <parameter name="newValue" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="onNew" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.
	If the store is still dirty (unsaved changes), then an error will be thrown instead of
	clearing the internal state for reload from the url.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.ItemFileReadStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="referenceIntegrity" scope="instance-prototype" type="bool"/>
      <property name="_saveInProgress" scope="instance-prototype" type="bool"/>
      <property name="_pending" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileWriteStore._features.dojo.data.api">
    <properties>
      <property name="Write" scope="instance" type="Object"/>
      <property name="Notification" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileWriteStore._datatypeMap.Date">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.data.ObjectStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="property" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="data" type="object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onNew" scope="instance"/>
      <method name="onDelete" scope="instance"/>
    </methods>
    <properties>
      <property name="objectStore" scope="instance" type="Object"/>
      <property name="labelProperty" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.data.ObjectStore._dirtyObjects">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.api"/>
  <class type="dojo.data.api.Identity" superclass="dojo.data.api.Read">
    <methods>
      <method name="getFeatures" scope="instance"/>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.api.Notification" superclass="dojo.data.api.Read">
    <description>This API defines a set of APIs that all datastores that conform to the
	Notifications API must implement.  In general, most stores will implement
	these APIs as no-op functions for users who wish to monitor them to be able
	to connect to then via dojo.connect().  For non-users of dojo.connect,
	they should be able to just replace the function on the store to obtain
	notifications.  Both read-only and read-write stores may implement
	this feature.  In the case of a read-only store, this feature makes sense if
	the store itself does internal polling to a back-end server and periodically updates
	its cache of items (deletes, adds, and updates).</description>
    <methods>
      <method name="getFeatures" scope="instance"/>
      <method name="onSet" scope="instance">
        <description>This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
	Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
	in a simple manner.  The general expected usage is to dojo.connect() to the store's
	implementation and be called after the store function is called.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required"/>
          <parameter name="newValue" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onNew" scope="instance">
        <description>This function is called any time a new item is created in the store.
	It is called immediately after the store newItem processing has completed.</description>
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onDelete" scope="instance">
        <description>This function is called any time an item is deleted from the store.
	It is called immediately after the store deleteItem processing has completed.</description>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.api.Read">
    <methods>
      <method name="getValue" scope="instance">
        <description>Saying that an "item x does not have a value for an attribute y"
	is identical to saying that an "item x does not have attribute y".
	It is an oxymoron to say "that attribute is present but has no values"
	or "the item has that attribute but does not have any attribute values".
	If store.hasAttribute(item, attribute) returns false, then
	store.getValue(item, attribute) will return undefined.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="a literal, an item, null, or undefined (never an array)"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="an array that may contain literals and items"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <description>A Request object will always be returned and is returned immediately.
	The basic request is nothing more than the keyword args passed to fetch and
	an additional function attached, abort().  The returned request object may then be used
	to cancel a fetch.  All data items returns are passed through the callbacks defined in the
	fetch parameters and are not present on the 'request' object.
	This does not mean that custom stores can not add methods and properties to the request object
	returned, only that the API does not require it.  For more info about the Request API,
	see dojo.data.api.Request</description>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
        <return-description>The fetch() method will return a javascript object conforming to the API
	defined in dojo.data.api.Request.  In general, it will be the keywordArgs
	object returned with the required functions in Request.js attached.
	Its general purpose is to provide a convenient way for a caller to abort an
	ongoing fetch.
	The Request object may also have additional properties when it is returned
	such as request.store property, which is a pointer to the datastore object that
	fetch() is a method of.</return-description>
        <return-types>
          <return-type type="an object conforming to the dojo.data.api.Request API"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <description>The close() method is intended for instructing the store to 'close' out
	any information associated with a particular request.  In general, this API
	expects to recieve as a parameter a request object returned from a fetch.
	It will then close out anything associated with that request, such as
	clearing any internal datastore caches and closing any 'open' connections.
	For some store implementations, this call may be a no-op.</description>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <description>Method to inspect the item and return a user-readable 'label' for the item
	that provides a general/adequate description of what the item is.  In general
	most labels will be a specific attribute value or collection of the attribute
	values that combine to label the item in some manner.  For example for an item
	that represents a person it may return the label as:  "firstname lastlame" where
	the firstname and lastname are attributes on the item.  If the store is unable
	to determine an adequate human readable label, it should return undefined.  Users that wish
	to customize how a store instance labels items should replace the getLabel() function on
	their instance of the store, or extend the store and replace the function in
	the extension class.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-description>A user-readable string representing the item or undefined if no user-readable label can
	be generated.</return-description>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <description>Method to inspect the item and return an array of what attributes of the item were used
	to generate its label, if any.  This function is to assist UI developers in knowing what
	attributes can be ignored out of the attributes an item has when displaying it, in cases
	where the UI is using the label as an overall identifer should they wish to hide
	redundant information.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-description>An array of attribute names that were used to generate the label, or null if public attributes
	were not used to generate the label.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Request">
    <methods>
      <method name="abort" scope="instance">
        <description>This function is a hook point for stores to provide as a way for
	a fetch to be halted mid-processing.  For more details on the fetch() api,
	please see dojo.data.api.Read.fetch().</description>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Write" superclass="dojo.data.api.Read">
    <methods>
      <method name="getFeatures" scope="instance"/>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="almost" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.  Since the saves are generally asynchronous, there is
	no need to return anything.  All results are passed via callbacks.</return-description>
      </method>
      <method name="revert" scope="instance">
        <description>Discards any unsaved changes.</description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.util.filter">
    <methods>
      <method name="patternToRegExp" scope="instance">
        <description>Returns a regular expression object that conforms to the defined conversion rules.
	For example:
	ca*   -&gt; /^ca.*$/
	*ca*  -&gt; /^.*ca.*$/
	*c\*a*  -&gt; /^.*c\*a.*$/
	*c\*a?*  -&gt; /^.*c\*a..*$/
	and so on.</description>
        <parameters>
          <parameter name="pattern" type="String" usage="required"/>
          <parameter name="ignoreCase" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="RegExp"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.data.util"/>
  <class type="dojo.data.util.simpleFetch">
    <methods>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.data.util.sorter">
    <methods>
      <method name="basicComparator" scope="instance">
        <description>returns 1 if a &gt; b, -1 if a &lt; b, 0 if equal.
	'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	And compared to each other, null is equivalent to undefined.</description>
        <parameters>
          <parameter name="a" type="anything" usage="required"/>
          <parameter name="b" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int {-1,0,1}"/>
        </return-types>
      </method>
      <method name="createSortFunction" scope="instance">
        <description>The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	Returns the sorting function for this particular list of attributes and sorting directions.</description>
        <parameters>
          <parameter name="sortSpec" type="attributes" usage="required"/>
          <parameter name="store" type="dojo.data.core.Read" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.date.locale">
    <methods>
      <method name="_getZone" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="getName" type="boolean" usage="required"/>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <description>Create a string from a Date object using a known localized pattern.
	By default, this method formats both date and time from dateObject.
	Formatting patterns are chosen appropriate to the locale.  Different
	formatting lengths may be chosen, with "full" used by default.
	Custom patterns may be used or registered with translations using
	the dojo.date.locale.addCustomFormats method.
	Formatting patterns are implemented using [the syntax described at
	unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Date object from a string using a known localized pattern.
	By default, this method parses looking for both date and time in the string.
	Formatting patterns are chosen appropriate to the locale.  Different
	formatting lengths may be chosen, with "full" used by default.
	Custom patterns may be used or registered with translations using
	the dojo.date.locale.addCustomFormats method.
	Formatting patterns are implemented using [the syntax described at
	unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	When two digit years are used, a century is chosen according to a sliding
	window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	year &lt; 100CE requires strict mode.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <description>The user may add custom localized formats where the bundle has properties following the
	same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	The pattern string should match the format used by the CLDR.
	See dojo.date.locale.format() for details.
	The resources must be loaded by dojo.requireLocalization() prior to use</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getGregorianBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="isWeekend" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getDayOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDayOfWeek" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.date.locale.__FormatOptions">
    <methods/>
    <properties>
      <property name="selector" scope="instance" type="String"/>
      <property name="formatLength" scope="instance" type="String"/>
      <property name="datePattern" scope="instance" type="String"/>
      <property name="timePattern" scope="instance" type="String"/>
      <property name="am" scope="instance" type="String"/>
      <property name="pm" scope="instance" type="String"/>
      <property name="locale" scope="instance" type="String"/>
      <property name="fullYear" scope="instance" type="Boolean"/>
      <property name="strict" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.date">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="isLeapYear" scope="instance">
        <description>Leap years are years with an additional day YYYY-02-29, where the
	year number is a multiple of four with the following exception: If
	a year is a multiple of 100, then it is only a leap year if it is
	also a multiple of 400. For example, 1900 was not a leap year, but
	2000 is one.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getTimezoneName" scope="instance">
        <description>Try to get time zone info from toString or toLocaleString method of
	the Date object -- UTC offset is not a time zone.  See
	http://www.twinsun.com/tz/tz-link.htm Note: results may be
	inconsistent across browsers.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.</description>
        <parameters>
          <parameter name="date1" type="Date" usage="required"/>
          <parameter name="date2" type="Date" usage="optional"/>
          <parameter name="portion" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="interval" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="Date" usage="required"/>
          <parameter name="date2" type="Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.date.stamp">
    <methods>
      <method name="fromISOString" scope="instance">
        <description>Accepts a string formatted according to a profile of ISO8601 as defined by
	[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	The following combinations are valid:
	* dates only
		* yyyy
		* yyyy-MM
		* yyyy-MM-dd
	* times only, with an optional time zone appended
		* THH:mm
		* THH:mm:ss
		* THH:mm:ss.SSS
	* and "datetimes" which could be any combination of the above
	timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	input may return null.  Arguments which are out of bounds will be handled
	by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	Only years between 100 and 9999 are supported.</description>
        <parameters>
          <parameter name="formattedString" type="String" usage="required"/>
          <parameter name="defaultTime" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Date or null"/>
        </return-types>
      </method>
      <method name="toISOString" scope="instance">
        <description>When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	Does not check bounds.  Only years between 100 and 9999 are supported.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="options" type="dojo.date.stamp.__Options" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_isoRegExp" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojo.date.stamp.__Options">
    <methods/>
    <properties>
      <property name="selector" scope="instance" type="String"/>
      <property name="zulu" scope="instance" type="Boolean"/>
      <property name="milliseconds" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.dnd">
    <methods>
      <method name="_createNode" scope="instance">
        <parameters>
          <parameter name="tag" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createTrTd" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createSpan" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_defaultCreator" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="manager" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="autoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="autoScrollNodes" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="getUniqueId" scope="instance"/>
      <method name="isFormElement" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_manager" scope="instance" type="Object"/>
      <property name="getViewport" scope="instance" type="Object"/>
      <property name="V_TRIGGER_AUTOSCROLL" scope="instance" type="Number"/>
      <property name="H_TRIGGER_AUTOSCROLL" scope="instance" type="Number"/>
      <property name="V_AUTOSCROLL_VALUE" scope="instance" type="Number"/>
      <property name="H_AUTOSCROLL_VALUE" scope="instance" type="Number"/>
      <property name="autoscroll" scope="instance" type="Object"/>
      <property name="getCopyKeyState" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Number"/>
      <property name="_empty" scope="instance" type="Object"/>
      <property name="common" scope="instance" type="Object"/>
      <property name="constrainedMover" scope="instance" type="Object"/>
      <property name="boxConstrainedMover" scope="instance" type="Object"/>
      <property name="parentConstrainedMover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Avatar">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="construct" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <properties>
      <property name="isA11y" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.dnd.Avatar.manager">
    <properties>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.__ContainerArgs">
    <methods>
      <method name="creator" scope="instance"/>
    </methods>
    <properties>
      <property name="skipForm" scope="instance" type="Boolean"/>
      <property name="dropParent" scope="instance" type="Node||String"/>
      <property name="_skipStartup" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.dnd.Container">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="dojo.dnd.__ContainerArgs" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.dnd.Item"/>
        </return-types>
      </method>
      <method name="setItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="data" type="dojo.dnd.Item" usage="required"/>
        </parameters>
      </method>
      <method name="delItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forInItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="clearItems" scope="instance"/>
      <method name="getAllNodes" scope="instance">
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="sync" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="anchor" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectStart" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="newState" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_addItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildByEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.dnd.Item" usage="required"/>
          <parameter name="hint" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="skipForm" scope="instance-prototype" type="bool"/>
      <property name="current" scope="instance-prototype" type="DomNode"/>
      <property name="map" scope="instance-prototype" type="Hash&lt;String,"/>
      <property name="creator" scope="instance-prototype" type="Object"/>
      <property name="node" scope="instance-prototype" type="Node"/>
      <property name="parent" scope="instance-prototype" type="Object"/>
      <property name="defaultCreator" scope="instance" type="Object"/>
      <property name="containerState" scope="instance" type="String"/>
      <property name="events" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.dnd.Item">
    <methods/>
    <properties>
      <property name="type" scope="instance" type="String[]"/>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd._defaultCreatorNodes">
    <properties>
      <property name="ul" scope="instance" type="String"/>
      <property name="ol" scope="instance" type="String"/>
      <property name="div" scope="instance" type="String"/>
      <property name="p" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="overSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="outSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="stopDrag" scope="instance"/>
      <method name="makeAvatar" scope="instance"/>
      <method name="updateAvatar" scope="instance"/>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setCopyStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="OFFSET_X" scope="instance" type="Number"/>
      <property name="OFFSET_Y" scope="instance" type="Number"/>
      <property name="target" scope="instance-prototype" type="Object"/>
      <property name="canDropFlag" scope="instance-prototype" type="bool"/>
      <property name="source" scope="instance-prototype" type="Object"/>
      <property name="nodes" scope="instance-prototype" type="Array"/>
      <property name="copy" scope="instance-prototype" type="Object"/>
      <property name="avatar" scope="instance-prototype" type="Object"/>
      <property name="events" scope="instance-prototype" type="Array"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager.canDrop">
    <methods/>
    <properties>
      <property name="target" scope="instance" type="Object"/>
      <property name="canDropFlag" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager.avatar.node"/>
  <class type="dojo.dnd.Manager.avatar.node.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.dnd.__MoveableArgs">
    <methods/>
    <properties>
      <property name="handle" scope="instance" type="Node||String"/>
      <property name="delay" scope="instance" type="Number"/>
      <property name="skip" scope="instance" type="Boolean"/>
      <property name="mover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Moveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="dojo.dnd.__MoveableArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectStart" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDragDetected" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStart" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMoving" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handle" scope="instance-prototype" type="Object"/>
      <property name="delay" scope="instance-prototype" type="Number"/>
      <property name="skip" scope="instance-prototype" type="bool"/>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="node" scope="instance-prototype" type="Node"/>
      <property name="_lastX" scope="instance" type="Object"/>
      <property name="_lastY" scope="instance" type="Object"/>
      <property name="mover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="host" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="host" scope="instance-prototype" type="Object"/>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="mouseButton" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover.node"/>
  <class type="dojo.dnd.Mover.node.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover.marginBox">
    <properties>
      <property name="l" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd.__SelectorArgs" superclass="dojo.dnd.__ContainerArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__ContainerArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="singular" scope="instance" type="Boolean"/>
      <property name="autoSync" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.dnd.Selector" superclass="dojo.dnd.Container">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node||String" usage="required"/>
          <parameter name="params" type="dojo.dnd.__SelectorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="getSelectedNodes" scope="instance">
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="selectNone" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectAll" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="deleteSelectedNodes" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="forInSelectedItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="sync" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required"/>
          <parameter name="data" type="Array" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="anchor" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_removeSelection" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_removeAnchor" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="selection" scope="instance-prototype" type="Set&lt;String&gt;"/>
      <property name="singular" scope="instance-prototype" type="bool"/>
      <property name="anchor" scope="instance-prototype" type="Object"/>
      <property name="simpleSelection" scope="instance-prototype" type="bool"/>
      <property name="onmousemoveEvent" scope="instance" type="Object"/>
      <property name="autoSync" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Source" superclass="dojo.dnd.Selector">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required"/>
          <parameter name="self" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onDropExternal" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropInternal" scope="instance">
        <parameters>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="isSource" scope="instance" type="Object"/>
      <property name="horizontal" scope="instance" type="bool"/>
      <property name="copyOnly" scope="instance" type="bool"/>
      <property name="selfCopy" scope="instance" type="bool"/>
      <property name="selfAccept" scope="instance" type="Object"/>
      <property name="skipForm" scope="instance" type="bool"/>
      <property name="withHandles" scope="instance" type="bool"/>
      <property name="autoSync" scope="instance" type="bool"/>
      <property name="delay" scope="instance" type="Number"/>
      <property name="accept" scope="instance-prototype" type="Object"/>
      <property name="generateText" scope="instance" type="Object"/>
      <property name="targetAnchor" scope="instance-prototype" type="Object"/>
      <property name="targetBox" scope="instance-prototype" type="Object"/>
      <property name="mouseDown" scope="instance-prototype" type="bool"/>
      <property name="_lastX" scope="instance-prototype" type="Number"/>
      <property name="_lastY" scope="instance-prototype" type="Number"/>
      <property name="isDragging" scope="instance-prototype" type="bool"/>
      <property name="before" scope="instance-prototype" type="Object"/>
      <property name="sourceState" scope="instance" type="String"/>
      <property name="targetState" scope="instance" type="String"/>
      <property name="topics" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.dnd.Target" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="isSource" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.dnd.AutoSource" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="autoSync" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.__SourceArgs">
    <methods/>
    <properties>
      <property name="isSource" scope="instance" type="Boolean"/>
      <property name="accept" scope="instance" type="Array"/>
      <property name="autoSync" scope="instance" type="Boolean"/>
      <property name="copyOnly" scope="instance" type="Boolean"/>
      <property name="delay" scope="instance" type="Number"/>
      <property name="horizontal" scope="instance" type="Boolean"/>
      <property name="selfCopy" scope="instance" type="Boolean"/>
      <property name="selfAccept" scope="instance" type="Boolean"/>
      <property name="withHandles" scope="instance" type="Boolean"/>
      <property name="generateText" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.dnd.__TimedMoveableArgs" superclass="dojo.dnd.__MoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__MoveableArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="timeout" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd.TimedMoveable" superclass="dojo.dnd.Moveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node||String" usage="required"/>
          <parameter name="params" type="dojo.dnd.__TimedMoveableArgs" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Moveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="timeout" scope="instance-prototype" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd._validNodes">
    <properties>
      <property name="div" scope="instance" type="Number"/>
      <property name="p" scope="instance" type="Number"/>
      <property name="td" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd._validOverflow">
    <properties>
      <property name="auto" scope="instance" type="Number"/>
      <property name="scroll" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd.move"/>
  <class type="dojo.dnd.move.__constrainedMoveableArgs" superclass="dojo.dnd.__MoveableArgs">
    <methods>
      <method name="constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__MoveableArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="within" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.constrainedMoveable" superclass="dojo.dnd.Moveable">
    <methods>
      <method name="constraints" scope="instance-prototype"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="dojo.dnd.move.__constrainedMoveableArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Moveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="within" scope="instance-prototype" type="bool"/>
      <property name="constraintBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.__boxConstrainedMoveableArgs" superclass="dojo.dnd.move.__constrainedMoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.__constrainedMoveableArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="box" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.boxConstrainedMoveable" superclass="dojo.dnd.move.constrainedMoveable">
    <methods>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="dojo.dnd.move.__boxConstrainedMoveableArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.constrainedMoveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="box" scope="instance" type="object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.__parentConstrainedMoveableArgs" superclass="dojo.dnd.move.__constrainedMoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.__constrainedMoveableArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="area" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.parentConstrainedMoveable" superclass="dojo.dnd.move.constrainedMoveable">
    <methods>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="dojo.dnd.move.__parentConstrainedMoveableArgs" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constraints" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.constrainedMoveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="area" scope="instance" type="object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.parentConstrainedMoveable.node">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojoConfig">
    <properties>
      <property name="baseUrl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.fx">
    <methods>
      <method name="chain" scope="instance">
        <description>Return a `dojo.Animation` which will play all passed
	`dojo.Animation` instances in sequence, firing its own
	synthesized events simulating a single animation. (eg:
	onEnd of this animation means the end of the chain,
	not the individual animations within)</description>
        <parameters>
          <parameter name="animations" type="dojo.Animation[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="combine" scope="instance">
        <description>Combine an array of `dojo.Animation`s to run in parallel,
	providing a new `dojo.Animation` instance encompasing each
	animation, firing standard animation events.</description>
        <parameters>
          <parameter name="animations" type="dojo.Animation[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeIn" scope="instance">
        <description>Returns an animation that will expand the
	node defined in 'args' object from it's current height to
	it's natural height (with no scrollbar).
	Node must have no margin/border/padding.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="instance">
        <description>Returns an animation that will shrink node defined in "args"
	from it's current height to 1px, and then hide it.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideTo" scope="instance">
        <description>Returns an animation that will slide "node"
	defined in args Object from its current position to
	the position defined by (args.left, args.top).</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.fx.Toggler">
    <description>class constructor for an animation toggler. It accepts a packed
	set of arguments about what type of animation to use in each
	direction, duration, etc. All available members are mixed into
	these animations from the constructor (for example, `node`,
	`showDuration`, `hideDuration`).</description>
    <methods>
      <method name="showFunc" scope="instance"/>
      <method name="hideFunc" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="delay" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="delay" type="Integer" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance" type="DomNode"/>
      <property name="showDuration" scope="instance" type="Time"/>
      <property name="hideDuration" scope="instance" type="Time"/>
      <property name="_showArgs" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideArgs" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_isShowing" scope="instance" type="bool"/>
      <property name="_isHiding" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.fx.easing">
    <description>Easing functions are used to manipulate the iteration through
	an `dojo.Animation`s _Line. _Line being the properties of an Animation,
	and the easing function progresses through that Line determing
	how quickly (or slowly) it should go. Or more accurately: modify
	the value of the _Line based on the percentage of animation completed.
	All functions follow a simple naming convention of "ease type" + "when".
	If the name of the function ends in Out, the easing described appears
	towards the end of the animation. "In" means during the beginning,
	and InOut means both ranges of the Animation will applied, both
	beginning and end.
	One does not call the easing function directly, it must be passed to
	the `easing` property of an animation.</description>
    <methods>
      <method name="linear" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backOut" scope="instance">
        <description>An easing function that pops past the range briefly, and slowly comes back.
	Use caution when the easing will cause values to become negative as some
	properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backInOut" scope="instance">
        <description>An easing function combining the effects of `backIn` and `backOut`.
	Use caution when the easing will cause values to become negative
	as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticIn" scope="instance">
        <description>An easing function the elastically snaps from the start value
	Use caution when the elasticity will cause values to become negative
	as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticOut" scope="instance">
        <description>An easing function that elasticly snaps around the target value,
	near the end of the Animation
	Use caution when the elasticity will cause values to become
	negative as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticInOut" scope="instance">
        <description>An easing function that elasticly snaps around the value, near
	the beginning and end of the Animation.
	Use caution when the elasticity will cause values to become
	negative as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
      <method name="bounceOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.gears">
    <methods>
      <method name="_gearsObject" scope="instance">
        <return-types>
          <return-type type="already defined elsewhere"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="available" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.html">
    <methods>
      <method name="_secureForInnerHtml" scope="instance">
        <parameters>
          <parameter name="cont" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_emptyNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setNodeContent" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Unless you need to use the params capabilities of this method, you should use
	dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
	an HTML string into the DOM, but it only handles inserting an HTML string as DOM
	elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
	or the other capabilities as defined by the params object for this method.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required"/>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.html._ContentSetter">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|NodeList" usage="optional"/>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setContent" scope="instance"/>
      <method name="empty" scope="instance"/>
      <method name="onBegin" scope="instance"/>
      <method name="onEnd" scope="instance"/>
      <method name="tearDown" scope="instance"/>
      <method name="onContentError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance"/>
      <method name="_onError" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="consoleText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance-prototype" type="DomNode|String"/>
      <property name="content" scope="instance" type="String|DomNode|DomNode[]"/>
      <property name="id" scope="instance-prototype" type="String"/>
      <property name="cleanContent" scope="instance" type="Boolean"/>
      <property name="extractContent" scope="instance" type="Boolean"/>
      <property name="parseContent" scope="instance" type="Boolean"/>
      <property name="parserScope" scope="instance" type="String"/>
      <property name="startup" scope="instance" type="Boolean"/>
      <property name="parseResults" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.i18n">
    <methods>
      <method name="getLocalization" scope="instance"/>
      <method name="normalizeLocale" scope="instance">
        <description>All variants are case-insensitive and are separated by '-' as specified in [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	If no locale is specified, the dojo.locale is returned.  dojo.locale is defined by
	the user agent's locale unless overridden by djConfig.</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_requireLocalization" scope="instance">
        <description>Called by the bootstrap, but factored out so that it is only
	included in the build when needed.</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="availableFlatLocales" type="String" usage="optional"/>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_searchLocalePath" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
          <parameter name="down" type="Boolean" usage="required"/>
          <parameter name="searchFunc" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_preloadLocalizations" scope="instance">
        <parameters>
          <parameter name="bundlePrefix" type="String" usage="required"/>
          <parameter name="localesGenerated" type="Array" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.io.iframe">
    <methods>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="fname" type="String" usage="required"/>
          <parameter name="onloadstr" type="String" usage="required"/>
          <parameter name="uri" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="setSrc" scope="instance">
        <parameters>
          <parameter name="iframe" type="DOMNode" usage="required"/>
          <parameter name="src" type="String" usage="required"/>
          <parameter name="replace" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="doc" scope="instance">
        <parameters>
          <parameter name="iframeNode" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_currentDfd" scope="instance" type="Object"/>
      <property name="_dfdQueue" scope="instance" type="Array"/>
      <property name="_iframeName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.io.iframe.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="method" scope="instance" type="String"/>
      <property name="handleAs" scope="instance" type="String"/>
      <property name="content" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io"/>
  <class type="dojo.io.iframe.send">
    <methods/>
    <properties>
      <property name="_frame" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.iframe._fireNextRequest">
    <methods/>
    <properties>
      <property name="_currentDfd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.iframe._iframeOnload">
    <methods/>
  </class>
  <class type="dojo.io.iframe._iframeOnload._currentDfd"/>
  <class type="dojo.io.iframe._iframeOnload._currentDfd.ioArgs">
    <properties>
      <property name="args" scope="instance" type="Object"/>
      <property name="_contentToClean" scope="instance" type="Object"/>
      <property name="_finished" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.script">
    <methods>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.io.script.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="attach" scope="instance">
        <description>Attaches the script element to the DOM.  Use this method if you
	just want to attach a script to the DOM and do not care when or
	if it loads.</description>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_deferredCancel" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_validCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_canAttach" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_deadScripts" scope="instance" type="Array"/>
      <property name="_counter" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.io.script.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="callbackParamName" scope="instance" type="String"/>
      <property name="jsonp" scope="instance" type="c&quot;."/>
      <property name="checkString" scope="instance" type="String"/>
      <property name="frameDoc" scope="instance" type="Document"/>
    </properties>
  </class>
  <class type="dojo.io.script._jsonpCallback">
    <methods/>
  </class>
  <class type="dojo.io.script._jsonpCallback.ioArgs">
    <properties>
      <property name="json" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.number">
    <methods>
      <method name="format" scope="instance">
        <description>Create a string from a Number using a known localized pattern.
	Formatting patterns appropriate to the locale are chosen from the
	[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and
	delimiters.
	If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_applyPattern" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="round" scope="instance">
        <description>Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	fractional increments also, such as the nearest quarter.
	NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="places" type="Number" usage="optional"/>
          <parameter name="increment" type="Number" usage="optional"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_formatAbsolute" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
          <parameter name="options" type="dojo.number.__FormatAbsoluteOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="regexp" scope="instance">
        <description>Returns regular expression with positive and negative match, group
	and decimal separators</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Number from a string using a known localized pattern.
	Formatting patterns are chosen appropriate to the locale
	and follow the syntax described by
	[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	Note that literal characters in patterns are not supported.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required"/>
          <parameter name="options" type="dojo.number.__ParseOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="NaN"/>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_realNumberRegexp" scope="instance">
        <parameters>
          <parameter name="flags" type="dojo.number.__RealNumberRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_integerRegexp" scope="instance">
        <parameters>
          <parameter name="flags" type="dojo.number.__IntegerRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_numberPatternRE" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojo.number.__FormatOptions">
    <methods/>
    <properties>
      <property name="pattern" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="places" scope="instance" type="Number"/>
      <property name="round" scope="instance" type="Number"/>
      <property name="locale" scope="instance" type="String"/>
      <property name="fractional" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.number.__FormatAbsoluteOptions">
    <methods/>
    <properties>
      <property name="decimal" scope="instance" type="String"/>
      <property name="group" scope="instance" type="String"/>
      <property name="places" scope="instance" type="Number|String"/>
      <property name="round" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.number.__RegexpOptions">
    <methods/>
    <properties>
      <property name="pattern" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="locale" scope="instance" type="String"/>
      <property name="strict" scope="instance" type="Boolean"/>
      <property name="places" scope="instance" type="Number|String"/>
    </properties>
  </class>
  <class type="dojo.number.__ParseOptions">
    <methods/>
    <properties>
      <property name="pattern" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="locale" scope="instance" type="String"/>
      <property name="strict" scope="instance" type="Boolean"/>
      <property name="fractional" scope="instance" type="Boolean|Array"/>
    </properties>
  </class>
  <class type="dojo.number.__RealNumberRegexpFlags">
    <methods/>
    <properties>
      <property name="places" scope="instance" type="Number"/>
      <property name="decimal" scope="instance" type="String"/>
      <property name="fractional" scope="instance" type="Boolean|Array"/>
      <property name="exponent" scope="instance" type="Boolean|Array"/>
      <property name="eSigned" scope="instance" type="Boolean|Array"/>
    </properties>
  </class>
  <class type="dojo.number.__IntegerRegexpFlags">
    <methods/>
    <properties>
      <property name="signed" scope="instance" type="Boolean"/>
      <property name="separator" scope="instance" type="String"/>
      <property name="groupSize" scope="instance" type="Number"/>
      <property name="groupSize2" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.regexp">
    <methods>
      <method name="escapeString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="except" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="buildGroupRE" scope="instance">
        <description>A utility function used by some of the RE generators. The
	subexpressions are constructed by the function, re, in the second
	parameter.  re builds one subexpression for each elem in the array
	a, in the first parameter. Returns a string for a regular
	expression that groups all the subexpressions.</description>
        <parameters>
          <parameter name="arr" type="Object|Array" usage="required"/>
          <parameter name="re" type="Function" usage="required"/>
          <parameter name="nonCapture" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="group" scope="instance">
        <parameters>
          <parameter name="expression" type="String" usage="required"/>
          <parameter name="nonCapture" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.rpc"/>
  <class type="dojo.rpc.JsonService" superclass="dojo.rpc.RpcService">
    <methods>
      <method name="callRemote" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required"/>
          <parameter name="params" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="bind" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required"/>
          <parameter name="parameters" type="array" usage="required"/>
          <parameter name="deferredRequestHandler" type="deferred" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRequest" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required"/>
          <parameter name="params" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="parseResults" scope="instance">
        <parameters>
          <parameter name="obj" type="anything" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.rpc.RpcService" scope="instance"/>
    </mixins>
    <properties>
      <property name="bustCache" scope="instance" type="bool"/>
      <property name="contentType" scope="instance" type="String"/>
      <property name="lastSubmissionId" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.rpc.JsonpService" superclass="dojo.rpc.RpcService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="requiredArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bind" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required"/>
          <parameter name="parameters" type="array" usage="required"/>
          <parameter name="deferredRequestHandler" type="deferred" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRequest" scope="instance">
        <parameters>
          <parameter name="parameters" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.rpc.RpcService" scope="instance"/>
    </mixins>
    <properties>
      <property name="strictArgChecks" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.rpc.RpcService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="parseResults" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="errorCallback" scope="instance">
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="resultCallback" scope="instance">
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="generateMethod" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required"/>
          <parameter name="parameters" type="array" usage="required"/>
          <parameter name="url" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="processSmd" scope="instance">
        <parameters>
          <parameter name="object" type="smd" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="strictArgChecks" scope="instance-prototype" type="Object"/>
      <property name="serviceUrl" scope="instance-prototype" type="Object"/>
      <property name="required" scope="instance" type="Object"/>
      <property name="smd" scope="instance" type="Object"/>
      <property name="timeout" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.store">
    <methods>
      <method name="Observable" scope="instance">
        <description>Observable wraps an existing store so that notifications can be made when a query
	is performed.</description>
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.store.__CacheArgs">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="isLoaded" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.store.Cache">
    <methods>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object|String" usage="required"/>
          <parameter name="directives" type="dojo.store.util.SimpleQueryEngine.__queryOptions" usage="optional"/>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A QueryResults object that can be used to iterate over.</return-description>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required"/>
          <parameter name="directives" type="dojo.store.__GetOptions" usage="optional"/>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A QueryResults object.</return-description>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="directives" type="dojo.store.__AddOptions" usage="optional"/>
        </parameters>
        <return-description>Number
	The new id for the object.</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="directives" type="dojo.store.__PutOptions" usage="optional"/>
        </parameters>
        <return-description>Number
	The new id for the object.</return-description>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required"/>
          <parameter name="directives" type="dojo.store.__RemoveOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="evict" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.store.DataStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_objectConverter" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="optional"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A query results object that can be used to iterate over results.</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
        <return-description>Number
	The id of the given object.</return-description>
      </method>
    </methods>
    <properties>
      <property name="target" scope="instance" type="String"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.store.JsonRest">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.store.JsonRest" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
        <return-description>Object
	The object in the store that matches the given id.</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="dojo.store.util.SimpleQueryEngine.__queryOptions" usage="optional"/>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	The results of the query, extended with iterative methods.</return-description>
      </method>
    </methods>
    <properties>
      <property name="target" scope="instance" type="String"/>
      <property name="idProperty" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.store.Memory">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.store.Memory" usage="required"/>
        </parameters>
      </method>
      <method name="queryEngine" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required"/>
        </parameters>
        <return-description>Object
	The object in the store that matches the given id.</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="dojo.store.util.SimpleQueryEngine.__queryOptions" usage="optional"/>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	The results of the query, extended with iterative methods.</return-description>
      </method>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Object[]" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="idProperty" scope="instance" type="String"/>
      <property name="index" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.store.Memory.data">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.store.util">
    <methods>
      <method name="QueryResults" scope="instance">
        <description>QueryResults is a basic wrapper that allows for array-like iteration
	over any kind of returned data from a query.  While the simplest store
	will return a plain array of data, other stores may return deferreds or
	promises; this wrapper makes sure that *all* results can be treated
	the same.
	Additional methods include `forEach`, `filter` and `map`.</description>
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
        <return-description>Object
	An array-like object that can be used for iterating over.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.store.util.SimpleQueryEngine">
    <description>The SimpleQueryEngine provides a way of getting a QueryResults through
	the use of a simple object hash as a filter.  The hash will be used to
	match properties on data objects with the corresponding value given. In
	other words, only exact matches will be returned.
	This function can be used as a template for more complex query engines;
	for example, an engine can be created that accepts an object hash that
	contains filtering functions, or a string that gets evaluated, etc.
	When creating a new dojo.store, simply set the store's queryEngine
	field as a reference to this function.</description>
  </class>
  <class type="dojo.store.util.SimpleQueryEngine.__sortInformation">
    <methods/>
    <properties>
      <property name="attribute" scope="instance" type="String"/>
      <property name="descending" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojo.store.util.SimpleQueryEngine.__queryOptions">
    <methods/>
    <properties>
      <property name="sort" scope="instance" type="dojo.store.util.SimpleQueryEngine.__sortInformation[]"/>
      <property name="start" scope="instance" type="Number"/>
      <property name="count" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.string">
    <methods>
      <method name="rep" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="num" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="pad" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="size" type="Integer" usage="required"/>
          <parameter name="ch" type="String" usage="optional"/>
          <parameter name="end" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="substitute" scope="instance">
        <parameters>
          <parameter name="template" type="String" usage="required"/>
          <parameter name="map" type="Object|Array" usage="required"/>
          <parameter name="transform" type="Function" usage="optional"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="trim" scope="instance">
        <description>This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	The short yet performant version of this function is dojo.trim(),
	which is part of Dojo base.  Uses String.prototype.trim instead, if available.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-description>String
	Returns the trimmed string</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.doc">
    <description>Refer to dojo.doc rather
	than referring to 'window.document' to ensure your code runs
	correctly in managed contexts.</description>
    <properties>
      <property name="styleSheets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Math">
    <properties>
      <property name="floor" scope="instance" type="Object"/>
      <property name="PI" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.doc.documentElement">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.window">
    <methods>
      <method name="getBox" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="nothing to do"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="node"/>
  <class type="node.ownerDocument">
    <properties>
      <property name="documentElement" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="node.ownerDocument.body">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.doc.body">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.NodeList">
    <properties>
      <property name="delegate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox">
    <description>DojoX is a collection of subprojects provided by Dojo committers and subject to
	the generous licensing and policies of the [Dojo CLA](http://dojotoolkit.org/cla)
	Each subproject in DojoX has its own top-level directory and a README file with
	status information and project status and a stability rating (experimental, beta, stable)
	Projects may or may not depend on other top-level Dojo projects, like Dojo or Dijit.
	Unlike Dojo and Dijit, code is not subject to i18n and a11y restrictions and may vary
	in quality (experimental code is encouraged in DojoX, but currently prohibited in Dojo
	and Dijit)
	DojoX projects may mature to a stable state and stay in DojoX, or on occasion
	after proving themselves may migrate to Dojo Core or Dijit.  Dojo and Dijit projects
	are constrained both by development resources as well as design goals, so DojoX is
	a natural place to provide enhanced behavior or extend Dojo Core or Dijit primitives.
	DojoX can also be an incubator for entirely new projects.</description>
    <properties>
      <property name="jq" scope="instance" type="Object"/>
      <property name="mobileApp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="djConfig">
    <properties>
      <property name="urchin" scope="instance" type="String"/>
      <property name="preloadImages" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.analytics">
    <methods>
      <method name="schedulePusher" scope="instance">
        <parameters>
          <parameter name="interval" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="addData" scope="instance">
        <parameters>
          <parameter name="dataType" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkData" scope="instance"/>
      <method name="onPushComplete" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_data" scope="instance" type="Array"/>
      <property name="_id" scope="instance" type="Number"/>
      <property name="sendInterval" scope="instance" type="Number"/>
      <property name="inTransitRetry" scope="instance" type="Number"/>
      <property name="dataUrl" scope="instance" type="Object"/>
      <property name="sendMethod" scope="instance" type="String"/>
      <property name="maxRequestSize" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.Urchin">
    <description>A small class object will allows for lazy-loading the Google Analytics API
	at any point during a page lifecycle. Most commonly, Google-Analytics is loaded
	via a synchronous script tag in the body, which causes `dojo.addOnLoad` to
	stall until the external API has been completely loaded. The Urchin helper
	will load the API on the fly, and provide a convenient API to use, wrapping
	Analytics for Ajaxy or single page applications.
	The class can be instantiated two ways: Programatically, by passing an
	`acct:` parameter, or via Markup / dojoType and defining a djConfig
	parameter `urchin:`
	IMPORTANT:
	This module will not work simultaneously with the core dojox.analytics
	package. If you need the ability to run Google Analytics AND your own local
	analytics system, you MUST include dojox.analytics._base BEFORE dojox.analytics.Urchin</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_gotGA" scope="instance"/>
      <method name="GAonLoad" scope="instance">
        <description>This function is executed when the tracker variable is
	complete and initialized. The initial trackPageView (with
	no arguments) is called here as well, so remeber to call
	manually if overloading this method.</description>
      </method>
      <method name="trackPageView" scope="instance">
        <parameters>
          <parameter name="url" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="acct" scope="instance-prototype" type="String"/>
      <property name="tracker" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.pushData">
    <methods/>
    <properties>
      <property name="_inTransit" scope="instance" type="Object"/>
      <property name="_data" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.analytics.getQueryPacket">
    <methods/>
    <properties>
      <property name="_split" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.analytics.plugins">
    <properties>
      <property name="consoleMessages" scope="instance" type="Object"/>
      <property name="dojo" scope="instance" type="Object"/>
      <property name="idle" scope="instance" type="Object"/>
      <property name="mouseClick" scope="instance" type="Object"/>
      <property name="mouseOver" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dependencies">
    <properties>
      <property name="layers" scope="instance" type="Array"/>
      <property name="prefixes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.atom.io"/>
  <class type="dojox.atom.io.Connection">
    <description>This object implements a transport layer for working with ATOM feeds and ATOM publishing protocols.
	Specifically, it provides a mechanism by which feeds can be fetched and entries can be fetched, created
	deleted, and modified.  It also provides access to the introspection data.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="sync" type="Boolean" usage="required"/>
          <parameter name="preventCache" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getFeed" scope="instance">
        <description>This function takes the URL for a specific ATOM feed and returns
	the data from that feed to the caller through the use of a callback
	handler.</description>
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="getService" scope="instance">
        <description>This function takes the URL for an ATOM item and feed and returns
	the introspection document.</description>
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="getEntry" scope="instance">
        <description>This function takes the URL for an ATOM entry and returns the constructed dojox.atom.io.model.Entry object through
	the specified callback.</description>
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="_getXmlDoc" scope="instance">
        <description>This internal function takes the URL for an XML document and and passes the
	parsed contents to a specified callback.</description>
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="nodeName" type="Object" usage="required"/>
          <parameter name="newNode" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="updateEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and pushes the
	changes back to the provider of the Entry.
	The entry MUST have a link tag with rel="edit" for this to work.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="retrieveUpdated" type="boolean" usage="required"/>
          <parameter name="xmethod" type="boolean" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="addEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and pushes the
	changes back to the provider of the Entry.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="retrieveEntry" type="boolean" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and calls for a delete on the
	service housing the ATOM Entry database.
	The entry MUST have a link tag with rel="edit" for this to work.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="xmethod" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
    </methods>
    <properties>
      <property name="preventCache" scope="instance-prototype" type="bool"/>
      <property name="alertsEnabled" scope="instance" type="bool"/>
      <property name="sync" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom"/>
  <class type="dojox.atom.io.model"/>
  <class type="dojox.atom.io.model.Node">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="name_space" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="attributes" type="Object" usage="required"/>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="shortNs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveAttributes" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addAttribute" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttribute" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance"/>
      <method name="addContent" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="name_space" scope="instance-prototype" type="Object"/>
      <property name="shortNs" scope="instance-prototype" type="Object"/>
      <property name="name" scope="instance-prototype" type="Object"/>
      <property name="textContent" scope="instance-prototype" type="Object"/>
      <property name="attributes" scope="instance-prototype" type="Array"/>
      <property name="content" scope="instance" type="Array"/>
      <property name="rawNodes" scope="instance" type="Array"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.AtomItem" superclass="dojox.atom.io.model.Node">
    <description>Class container for generic Atom items.
	child objects can override this if they want to be called after a Dom build</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="accept" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="buildFromDom" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addNamespace" scope="instance">
        <parameters>
          <parameter name="fullName" type="Object" usage="required"/>
          <parameter name="shortName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addAuthor" scope="instance">
        <description>Function to add in an author to the list of authors.</description>
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="email" type="String" usage="required"/>
          <parameter name="uri" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="addContributor" scope="instance">
        <description>Function to add in an author to the list of authors.</description>
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="email" type="String" usage="required"/>
          <parameter name="uri" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="addLink" scope="instance">
        <description>Function to add in a link to the list of links.</description>
        <parameters>
          <parameter name="href" type="String" usage="required"/>
          <parameter name="rel" type="String" usage="required"/>
          <parameter name="hrefLang" type="String" usage="required"/>
          <parameter name="title" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeLink" scope="instance">
        <description>Function to remove a link from the list of links.</description>
        <parameters>
          <parameter name="href" type="String" usage="required"/>
          <parameter name="rel" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeBasicLinks" scope="instance">
        <description>Function to remove all basic link from the list of links.</description>
      </method>
      <method name="addCategory" scope="instance">
        <description>Function to add in a category to the list of categories.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getCategories" scope="instance">
        <description>Function to get all categories that match a particular scheme.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeCategories" scope="instance">
        <description>Function to remove all categories that match a particular scheme and term.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <description>Function to set the title of the item.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="addExtension" scope="instance">
        <description>Function to add in an extension namespace into the item.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="attributes" type="Array" usage="required"/>
          <parameter name="content" type="String" usage="required"/>
          <parameter name="shortNS" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getExtensions" scope="instance">
        <description>Function to get extensions that match a namespace and name.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeExtensions" scope="instance">
        <description>Function to remove extensions that match a namespace and name.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="_accepts" scope="instance" type="Object"/>
      <property name="extensions" scope="instance-prototype" type="Object"/>
      <property name="authors" scope="instance-prototype" type="Object"/>
      <property name="contributors" scope="instance-prototype" type="Object"/>
      <property name="links" scope="instance-prototype" type="Object"/>
      <property name="categories" scope="instance-prototype" type="Object"/>
      <property name="icon" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance-prototype" type="Object"/>
      <property name="logo" scope="instance-prototype" type="Object"/>
      <property name="xmlBase" scope="instance-prototype" type="Object"/>
      <property name="rights" scope="instance-prototype" type="Object"/>
      <property name="subtitle" scope="instance-prototype" type="Object"/>
      <property name="updated" scope="instance-prototype" type="Object"/>
      <property name="published" scope="instance-prototype" type="Object"/>
      <property name="issued" scope="instance-prototype" type="Object"/>
      <property name="modified" scope="instance-prototype" type="Object"/>
      <property name="content" scope="instance-prototype" type="Object"/>
      <property name="entries" scope="instance-prototype" type="Object"/>
      <property name="ATOM_URI" scope="instance" type="Object"/>
      <property name="name_spaces" scope="instance" type="Object"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.AtomItem.title">
    <properties>
      <property name="value" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Category" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'Category' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the category tag, which is an XML structure.</description>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Category data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="scheme" scope="instance-prototype" type="Object"/>
      <property name="term" scope="instance-prototype" type="Object"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Content" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'Content' types. Such as summary, content, username, and so on types of data.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="xmlLang" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="_postBuild" scope="instance"/>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Content data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the content tag, which is an XML structure.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="type" scope="instance-prototype" type="String"/>
      <property name="scheme" scope="instance" type="Object"/>
      <property name="term" scope="instance" type="Object"/>
      <property name="tagName" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
      <property name="xmlLang" scope="instance" type="Object"/>
      <property name="HTML" scope="instance" type="String"/>
      <property name="TEXT" scope="instance" type="String"/>
      <property name="XHTML" scope="instance" type="String"/>
      <property name="XML" scope="instance" type="String"/>
      <property name="_useTextContent" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Link" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'link' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="rel" type="Object" usage="required"/>
          <parameter name="hrefLang" type="Object" usage="required"/>
          <parameter name="title" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="_postBuild" scope="instance"/>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the link data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the link tag, which is an XML structure.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="href" scope="instance-prototype" type="Object"/>
      <property name="hrefLang" scope="instance-prototype" type="Object"/>
      <property name="rel" scope="instance-prototype" type="Object"/>
      <property name="title" scope="instance-prototype" type="Object"/>
      <property name="type" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Person" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'person' types, such as Author, controbutors, and so on.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="personType" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="email" type="Object" usage="required"/>
          <parameter name="uri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="_postBuild" scope="instance"/>
      <method name="accept" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the person data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the Person tag, which is an XML structure.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="extensions" scope="instance" type="Array"/>
      <property name="author" scope="instance" type="String"/>
      <property name="contributor" scope="instance" type="String"/>
      <property name="personType" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="String"/>
      <property name="email" scope="instance" type="String"/>
      <property name="uri" scope="instance" type="String"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Person._accepts">
    <properties>
      <property name="name" scope="instance" type="Object"/>
      <property name="uri" scope="instance" type="Object"/>
      <property name="email" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Generator" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'Generator' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="version" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the generator data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the Generator tag, which is an XML structure.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="uri" scope="instance-prototype" type="Object"/>
      <property name="version" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Entry" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Entry' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the entry tag, which is an XML structure.</description>
        <parameters>
          <parameter name="amPrimary" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getEditHref" scope="instance">
        <description>Function to get the href that allows editing of this feed entry.</description>
        <return-description>The href that specifies edit capability.</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="setEditHref" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="published" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
      <property name="links" scope="instance" type="Array"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_objName" scope="instance" type="String"/>
      <property name="feedUrl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Entry._accepts">
    <properties>
      <property name="author" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="category" scope="instance" type="Object"/>
      <property name="contributor" scope="instance" type="Object"/>
      <property name="created" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="link" scope="instance" type="Object"/>
      <property name="published" scope="instance" type="Object"/>
      <property name="rights" scope="instance" type="Object"/>
      <property name="summary" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
      <property name="xmlbase" scope="instance" type="Object"/>
      <property name="issued" scope="instance" type="Object"/>
      <property name="modified" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Feed" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Feed' types.</description>
    <methods>
      <method name="addEntry" scope="instance">
        <description>Function to add an entry to this feed.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstEntry" scope="instance">
        <description>Function to get the first entry of the feed.</description>
        <return-description>The first entry in the feed.</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getEntry" scope="instance">
        <description>Function to get an entry by its id.</description>
        <parameters>
          <parameter name="entryId" type="String" usage="required"/>
        </parameters>
        <return-description>The entry desired, or null if none.</return-description>
      </method>
      <method name="removeEntry" scope="instance">
        <description>Function to remove an entry from the list of links.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setEntries" scope="instance">
        <description>Function to get an entry by its id.</description>
        <parameters>
          <parameter name="arrayOfEntry" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the feed tag, which is an XML structure.</description>
      </method>
      <method name="createEntry" scope="instance">
        <description>Function to Create a new entry object in the feed.</description>
        <return-description>An empty entry object in the feed.</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getSelfHref" scope="instance">
        <description>Function to get the href that refers to this feed.</description>
        <return-description>The href that refers to this feed or null if none.</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="entries" scope="instance" type="Array"/>
      <property name="rights" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Feed._accepts">
    <properties>
      <property name="author" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="category" scope="instance" type="Object"/>
      <property name="contributor" scope="instance" type="Object"/>
      <property name="created" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="link" scope="instance" type="Object"/>
      <property name="published" scope="instance" type="Object"/>
      <property name="rights" scope="instance" type="Object"/>
      <property name="summary" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
      <property name="xmlbase" scope="instance" type="Object"/>
      <property name="entry" scope="instance" type="Object"/>
      <property name="logo" scope="instance" type="Object"/>
      <property name="issued" scope="instance" type="Object"/>
      <property name="modified" scope="instance" type="Object"/>
      <property name="icon" scope="instance" type="Object"/>
      <property name="subtitle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Service" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Feed' types.
	builds a Service document.  each element of this, except for the namespace, is the href of
	a service that the server supports.  Some of the common services are:
	"create-entry" , "user-prefs" , "search-entries" , "edit-template" , "categories"</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Service data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
      </method>
      <method name="getCollection" scope="instance">
        <description>Function to collections that match a specific url.</description>
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="workspaces" scope="instance" type="Array"/>
      <property name="name_space" scope="instance" type="Object"/>
      <property name="href" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Workspace" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Workspace' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="title" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Workspace data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance-prototype" type="Object"/>
      <property name="collections" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Collection" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Collection' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="title" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Collection data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="href" scope="instance-prototype" type="Object"/>
      <property name="memberType" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance-prototype" type="Object"/>
      <property name="title" scope="instance-prototype" type="Object"/>
      <property name="attributes" scope="instance" type="Array"/>
      <property name="features" scope="instance" type="Array"/>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model._Constants">
    <description>Container for general constants.</description>
    <properties>
      <property name="ATOM_URI" scope="instance" type="String"/>
      <property name="ATOM_NS" scope="instance" type="String"/>
      <property name="PURL_NS" scope="instance" type="String"/>
      <property name="APP_NS" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model._actions">
    <description>Container for tag handling functions.  Each child of this container is
	a handler function for the given type of node. Each accepts two parameters:
	obj:  Object.
	The object to insert data into.
	node: DOM Node.
	The dom node containing the data
	Google news
	Google news</description>
    <methods>
      <method name="link" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="author" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="contributor" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="category" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="icon" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="id" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rights" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subtitle" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="title" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updated" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="issued" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="modified" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="published" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="content" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="summary" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="name" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="email" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uri" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generator" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.atom.io.model.util">
    <methods>
      <method name="createDate" scope="instance">
        <description>Utility function to create a date from a DOM node's text content.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
        <return-description>Date object from a DOM Node containing a ISO-8610 string.</return-description>
      </method>
      <method name="escapeHtml" scope="instance">
        <description>Utility function to escape XML special characters in an HTML string.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-description>HTML String with special characters (&lt;,&gt;,&amp;, ", etc,) escaped.</return-description>
      </method>
      <method name="unEscapeHtml" scope="instance">
        <description>Utility function to un-escape XML special characters in an HTML string.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped) characters (&lt;,&gt;,&amp;, ", etc,).</return-description>
      </method>
      <method name="getNodename" scope="instance">
        <description>Utility function to get a node name and deal with IE's bad handling of namespaces
	on tag names.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
        <return-description>String
	The name without namespace prefixes.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.atom.widget"/>
  <class type="dojox.atom.widget.FeedEntryEditor" superclass="dojox.atom.widget.FeedEntryViewer">
    <description>An ATOM feed entry editor that allows viewing of the individual attributes of an entry.
	Flag denoting if the current entry is editable or not.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setEntry" scope="instance">
        <description>Function to set the current entry that is being edited.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
          <parameter name="feed" type="object" usage="required"/>
          <parameter name="leaveMenuState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleEdit" scope="instance">
        <description>Internal function for toggling/enabling the display of edit mode</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_isEditable" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
        <return-description>Boolean denoting if the entry seems editable or not..</return-description>
      </method>
      <method name="setTitle" scope="instance">
        <description>Function to set the contents of the title node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="titleAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setAuthors" scope="instance">
        <description>Function to set the contents of the author node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="authorsAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setContributors" scope="instance">
        <description>Function to set the contents of the contributor node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setId" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="idAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setUpdated" scope="instance">
        <description>Function to set the contents of the updated node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setSummary" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	summaryAnchorNode:
	The DOM node to attach the content data to.</description>
        <parameters>
          <parameter name="contentAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_createEditor" scope="instance">
        <description>Function to create an appropriate text editor widget based on the given parameters.</description>
        <parameters>
          <parameter name="anchorNode" type="DOM" usage="required"/>
          <parameter name="node" type="DOM" usage="required"/>
          <parameter name="multiline" type="boolean" usage="required"/>
          <parameter name="rte" type="object" usage="required"/>
        </parameters>
        <return-description>Either a widget (for textarea or textbox widgets) or an anonymous object to be used to create a
	rich text area widget.</return-description>
      </method>
      <method name="_switchEditor" scope="instance">
        <description>Function to switch between a rich text editor and a textarea widget.  Used for title, summary,
	And content when switching between text and html/xhtml content.</description>
        <parameters>
          <parameter name="event" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_createPeopleEditor" scope="instance">
        <description>Creates a People Editor widget, sets its value, and returns it.</description>
        <parameters>
          <parameter name="anchorNode" type="DOM" usage="required"/>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
        <return-description>A new People Editor object.</return-description>
      </method>
      <method name="saveEdits" scope="instance">
        <description>Saves edits submitted when the 'save' button is pressed.  Distinguishes between new and existing
	entries and saves appropriately.  Fetches the values of the editors, and, if existing, compares them to
	the existing values and submits the updates, otherwise creates a new entry and posts it as a new entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleSave" scope="instance">
        <description>Function for handling the save of an entry, cleaning up the display after the edit is completed.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
          <parameter name="location" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.
	Close the editor and revert out.</return-description>
      </method>
      <method name="cancelEdits" scope="instance">
        <description>Cancels edits and reverts the editor to its previous state (display mode)</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="clear" scope="instance">
        <description>Clears the editor, destorys all editors, leaving the editor completely clear</description>
      </method>
      <method name="clearEditors" scope="instance"/>
      <method name="_enforceXhtml" scope="instance">
        <description>Function for cleaning up/enforcing the XHTML standard in HTML returned from the editor2 widget.</description>
        <parameters>
          <parameter name="html" type="string" usage="required"/>
        </parameters>
        <return-description>string of cleaned up HTML.</return-description>
      </method>
      <method name="_closeTag" scope="instance">
        <description>Function for closing tags in a text of HTML/XHTML</description>
        <parameters>
          <parameter name="xhtml" type="string" usage="required"/>
          <parameter name="tag" type="string" usage="required"/>
        </parameters>
        <return-description>string of cleaned up HTML.
	NOTE:  Probably should redo this function in a more efficient way.  This could get expensive.</return-description>
      </method>
      <method name="_toggleNew" scope="instance">
        <description>Function to put the editor into a state to create a new entry.</description>
      </method>
      <method name="_displaySections" scope="instance">
        <description>Function to display the appropriate sections based on validity.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.widget.FeedEntryViewer" scope="instance"/>
    </mixins>
    <properties>
      <property name="_contentEditor" scope="instance" type="Object"/>
      <property name="_oldContent" scope="instance" type="Object"/>
      <property name="_setObject" scope="instance" type="Object"/>
      <property name="enableEdit" scope="instance" type="bool"/>
      <property name="_contentEditorCreator" scope="instance" type="Object"/>
      <property name="entryNewButton" scope="instance" type="Object"/>
      <property name="_editable" scope="instance" type="bool"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="_editMode" scope="instance" type="bool"/>
      <property name="_toLoad" scope="instance" type="Object"/>
      <property name="entryContentNode" scope="instance" type="Object"/>
      <property name="_new" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.displayOptions">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelTitle">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelAuthors">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelContributors">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelId">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.close">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelUpdated">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelSummary">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelContent">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.doNew">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.edit">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.save">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.cancel">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.entryTitleSelect">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor._editors">
    <properties>
      <property name="authors" scope="instance" type="Object"/>
      <property name="contributors" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="summary" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.entrySummarySelect">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.entryContentSelect">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.PeopleEditor" superclass="dijit._Widget">
    <description>An editor for dojox.atom.io.model.Person objects.  Displays multiple rows for the respective arrays
	of people.  Can add/remove rows on the fly.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_createEditors" scope="instance">
        <description>creates editor boxes (textbox widgets) for the individual values of a Person.</description>
        <parameters>
          <parameter name="name" type="string" usage="required"/>
          <parameter name="email" type="string" usage="required"/>
          <parameter name="uri" type="string" usage="required"/>
          <parameter name="index" type="int" usage="required"/>
          <parameter name="widgetName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_createEditor" scope="instance">
        <description>Creates an individual editor widget (textbox) for a value.</description>
        <parameters>
          <parameter name="value" type="string" usage="required"/>
          <parameter name="id" type="string" usage="required"/>
          <parameter name="name" type="string" usage="required"/>
          <parameter name="labelNode" type="DOM" usage="required"/>
          <parameter name="node" type="DOM" usage="required"/>
        </parameters>
        <return-description>Editor widget.</return-description>
      </method>
      <method name="_removeEditor" scope="instance">
        <description>Removes a Person from our list of editors by removing the block of editors that
	make up that Person.</description>
        <parameters>
          <parameter name="event" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <description>Adds a new block of blank editors to represent a Person.</description>
      </method>
      <method name="getValues" scope="instance">
        <description>Gets the values of this editor in an array, with each Person as an object within the array.</description>
        <return-description>An array of anonymous objects representing dojox.atom.io.model.Persons.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_rows" scope="instance" type="Array"/>
      <property name="_editors" scope="instance" type="Array"/>
      <property name="_index" scope="instance" type="Number"/>
      <property name="_numRows" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer" superclass="dijit._Widget">
    <description>An ATOM feed entry editor for publishing updated ATOM entries, or viewing non-editable entries.
	The topic to listen on for entries to edit.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="clear" scope="instance">
        <description>Function to clear the state of the widget.</description>
      </method>
      <method name="clearNodes" scope="instance">
        <description>Function to clear all the display nodes for the ATOM entry from the viewer.</description>
      </method>
      <method name="setEntry" scope="instance">
        <description>Function to set the current entry that is being edited.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
          <parameter name="feed" type="object" usage="required"/>
          <parameter name="leaveMenuState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setTitleHeader" scope="instance">
        <description>Function to set the contents of the title header node in the template to some value.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	titleAchorNode:
	The DOM node to attach the title data to.
	editMode:
	Boolean to indicate if the display should be in edit mode or not.</description>
        <parameters>
          <parameter name="titleHeaderNode" type="DOM" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <description>Function to set the contents of the title node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	titleAchorNode:
	The DOM node to attach the title data to.</description>
        <parameters>
          <parameter name="titleAnchorNode" type="Object" usage="required"/>
          <parameter name="editMode" type="Boolean" usage="required"/>
          <parameter name="entry" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="setAuthorsHeader" scope="instance">
        <description>Function to set the title format for the authors section of the author row in the template to some value from the entry.
	This exists specifically so users can over-ride how the author data is filled out from an entry.</description>
        <parameters>
          <parameter name="authorHeaderNode" type="DOM" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setAuthors" scope="instance">
        <description>Function to set the contents of the author node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	authorsAchorNode:
	The DOM node to attach the author data to.</description>
        <parameters>
          <parameter name="authorsAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setContributorsHeader" scope="instance">
        <description>Function to set the contents of the contributor header node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsHeaderNode" type="DOM" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setContributors" scope="instance">
        <description>Function to set the contents of the contributor node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setIdHeader" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	idAnchorNode:
	The DOM node to attach the ID data to.</description>
        <parameters>
          <parameter name="idHeaderNode" type="DOM" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setId" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="idAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setUpdatedHeader" scope="instance">
        <description>Function to set the contents of the updated header node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedHeaderNode" type="DOM" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setUpdated" scope="instance">
        <description>Function to set the contents of the updated node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setSummaryHeader" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryHeaderNode" type="DOM" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setSummary" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setContentHeader" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contentHeaderNode" type="DOM" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contentAnchorNode" type="DOM" usage="required"/>
          <parameter name="editMode" type="boolean" usage="required"/>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_displaySections" scope="instance">
        <description>Internal function for determining which sections of the view to actually display.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setDisplaySections" scope="instance">
        <description>Function for setting which sections of the entry should be displayed.</description>
        <parameters>
          <parameter name="sectionsArray" type="array" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_setDisplaySectionsCheckboxes" scope="instance">
        <description>Internal function for setting which checkboxes on the display are selected.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_readDisplaySections" scope="instance">
        <description>Internal function for reading what is currently checked for display and generating the display list from it.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_toggleCheckbox" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="checkBox" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing</return-description>
      </method>
      <method name="_toggleOptions" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="checkBox" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setFieldValidity" scope="instance">
        <description>Function to set whether a field in the view is valid and displayable.
	This is needed for over-riding of the set* functions and customization of how data is displayed in the attach point.
	So if custom implementations use their own display logic, they can still enable the field.</description>
        <parameters>
          <parameter name="field" type="string" usage="required"/>
          <parameter name="isValid" type="boolean" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="isFieldValid" scope="instance">
        <description>Function to return if a displayable field is valid or not</description>
        <parameters>
          <parameter name="field" type="string" usage="required"/>
        </parameters>
        <return-description>boolean denoting if the field is valid and set.</return-description>
      </method>
      <method name="getEntry" scope="instance"/>
      <method name="getFeed" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="entrySelectionTopic" scope="instance" type="String"/>
      <property name="_validEntryFields" scope="instance" type="Object"/>
      <property name="displayEntrySections" scope="instance" type="String"/>
      <property name="_displayEntrySections" scope="instance" type="Array"/>
      <property name="enableMenu" scope="instance" type="bool"/>
      <property name="enableMenuFade" scope="instance" type="bool"/>
      <property name="_optionButtonDisplayed" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_entry" scope="instance" type="Object"/>
      <property name="_feed" scope="instance" type="Object"/>
      <property name="_editMode" scope="instance" type="bool"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.displayOptions">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelTitle">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelAuthors">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelContributors">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelId">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.close">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelUpdated">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelSummary">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelContent">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.EntryHeader" superclass="dijit._Widget">
    <description>Widget representing a header in a FeedEntryViewer/Editor</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setListHeader" scope="instance">
        <parameters>
          <parameter name="title" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewer" superclass="dijit._Widget">
    <description>An ATOM feed viewer that allows for viewing a feed, deleting entries, and editing entries.
	The body of the feed viewer table so we can access it and populate it.  Will be assigned via template.
	The overal table container which contains the feed viewer table.  Will be assigned via template.
	The topic to broadcast when any entry is clicked so that a listener can pick up it and display it.
	The URL to which to connect to initially on creation.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>The postCreate function.  Creates our AtomIO object for future interactions and subscribes to the
	event given in markup/creation.</description>
      </method>
      <method name="startup" scope="instance">
        <description>The startup function.  Parses the filters and sets the feed based on the given url.</description>
      </method>
      <method name="clear" scope="instance">
        <description>Function clearing all current entries in the feed view.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setFeedFromUrl" scope="instance">
        <description>Function setting the dojox.atom.io.model.Feed data into the view.</description>
        <parameters>
          <parameter name="url" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setFeed" scope="instance">
        <description>Function setting the dojox.atom.io.model.Feed data into the view.
	entry:
	The dojox.atom.io.model.Feed object to process</description>
        <parameters>
          <parameter name="feed" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_displayDateForEntry" scope="instance">
        <description>Internal function for determining of a particular entry is editable.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
        <return-description>An appropriate date for the feed viewer display.</return-description>
      </method>
      <method name="appendGrouping" scope="instance">
        <description>Function for appending a grouping of entries to the feed view.
	entry:
	The title of the new grouping to create on the view.</description>
        <parameters>
          <parameter name="titleText" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="appendEntry" scope="instance">
        <description>Function for appending an entry to the feed view.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>Function for deleting a row from the view</description>
        <parameters>
          <parameter name="entryRow" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeEntry" scope="instance">
        <description>callback for when an entry is deleted from a feed.</description>
        <parameters>
          <parameter name="entry" type="FeedViewerEntry" usage="required"/>
          <parameter name="success" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_rowSelected" scope="instance">
        <description>Internal function for handling the selection of feed entries.</description>
        <parameters>
          <parameter name="evt" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_deselectCurrentSelection" scope="instance">
        <description>Internal function for unselecting the current selection.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_isEditable" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
        <return-description>Boolean denoting if the entry seems editable or not..</return-description>
      </method>
      <method name="onEntrySelected" scope="instance">
        <description>Function intended for over0-riding/replacement as an attachpoint to for other items to recieve
	selection notification.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_isRelativeURL" scope="instance">
        <description>Method to determine if the URL is relative or absolute.  Basic assumption is if it doesn't start
	with http:// or file://, it's relative to the current document.</description>
        <parameters>
          <parameter name="url" type="string" usage="required"/>
        </parameters>
        <return-description>boolean indicating whether it's a relative url or not.</return-description>
      </method>
      <method name="_calculateBaseURL" scope="instance">
        <description>Internal function to calculate a baseline URL from the provided full URL.</description>
        <parameters>
          <parameter name="fullURL" type="string" usage="required"/>
          <parameter name="currentPageRelative" type="boolean" usage="required"/>
        </parameters>
        <return-description>String of the baseline URL</return-description>
      </method>
      <method name="_isFilterAccepted" scope="instance">
        <description>Internal function to do matching of category filters to widgets.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
        <return-description>boolean denoting if this entry matched one of the accept filters.</return-description>
      </method>
      <method name="addCategoryIncludeFilter" scope="instance">
        <description>Function to add a filter for entry inclusion in the feed view.</description>
        <parameters>
          <parameter name="filter" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="removeCategoryIncludeFilter" scope="instance">
        <description>Function to remove a filter for entry inclusion in the feed view.</description>
        <parameters>
          <parameter name="filter" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_addEntry" scope="instance">
        <description>callback function used when adding an entry to the feed.  After the entry has been posted to the feed,
	we add it to our feed representation (to show it on the page) and publish an event to update any entry viewers.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <description>Destroys this widget, including all descendants and subscriptions.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="feedViewerTableBody" scope="instance" type="Object"/>
      <property name="feedViewerTable" scope="instance" type="Object"/>
      <property name="entrySelectionTopic" scope="instance" type="String"/>
      <property name="url" scope="instance" type="String"/>
      <property name="xmethod" scope="instance" type="bool"/>
      <property name="localSaveOnly" scope="instance" type="bool"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_feed" scope="instance" type="Object"/>
      <property name="_currentSelection" scope="instance" type="Object"/>
      <property name="_includeFilters" scope="instance" type="Array"/>
      <property name="alertsEnabled" scope="instance" type="bool"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="atomIO" scope="instance" type="Object"/>
      <property name="childWidgets" scope="instance" type="Array"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry" superclass="dijit._Widget">
    <description>Widget for handling the display of an entry and specific events associated with it.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setTitle" scope="instance">
        <description>Function to set the title of the entry.</description>
        <parameters>
          <parameter name="text" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setTime" scope="instance">
        <description>Function to set the time of the entry.</description>
        <parameters>
          <parameter name="timeText" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="enableDelete" scope="instance">
        <description>Function to enable the delete action on this entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="disableDelete" scope="instance">
        <description>Function to disable the delete action on this entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>Function to handle the delete event and delete the entry.</description>
        <parameters>
          <parameter name="event" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onClick" scope="instance">
        <description>Attach point for when a row is clicked on.</description>
        <parameters>
          <parameter name="e" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="entryNode" scope="instance" type="Object"/>
      <property name="timeNode" scope="instance" type="Object"/>
      <property name="entry" scope="instance" type="Object"/>
      <property name="feed" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry.deleteButton">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry.deleteButton.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerGrouping" superclass="dijit._Widget">
    <description>Grouping of feed entries.</description>
    <methods>
      <method name="setText" scope="instance">
        <description>Sets the text to be shown above this grouping.</description>
        <parameters>
          <parameter name="text" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="groupingNode" scope="instance" type="Object"/>
      <property name="titleNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.AtomEntryCategoryFilter" superclass="dijit._Widget">
    <description>A filter to be applied to the list of entries.</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="scheme" scope="instance" type="String"/>
      <property name="term" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="isFilter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewer.CategoryIncludeFilter">
    <description>The initializer function.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The initializer function.</description>
        <parameters>
          <parameter name="scheme" type="Object" usage="required"/>
          <parameter name="term" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="match" scope="instance">
        <description>Function to determine if this category filter matches against a category on an atom entry</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required"/>
        </parameters>
        <return-description>boolean denoting if this category filter matched to this entry.</return-description>
      </method>
    </methods>
    <properties>
      <property name="scheme" scope="instance" type="Object"/>
      <property name="term" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av"/>
  <class type="dojox.av.FLAudio">
    <description>This class is brand new, so there is a lot of
	functionality not yet available. The initial
	purpose is for playing "event" sounds like button
	clicks, and for loading and controlling multiple
	sounds at once. As of yet, streaming is not supported
	and polling the sounds for events during playback
	may still be missing information. Markup is not
	supported, as it may not be needed.
	TODO:
	Streaming, playback events, crossdomain, CDN support,
	(alternate SWF location), global volume, ID3 tag,
	factor out doLater, onLoadStatus needs work,
	play(position) / seek()</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
        <return-description>The normalized url, which can be used to identify the
	audio.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="doPlay" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pause" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stop" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setVolume" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPan" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getVolume" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPan" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPosition" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadStatus" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onAllLoaded" scope="instance"/>
      <method name="onPlayStatus" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="onID3" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_sub" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="instance">
        <parameters>
          <parameter name="vol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeUrl" scope="instance">
        <parameters>
          <parameter name="_url" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance-prototype" type="String"/>
      <property name="initialVolume" scope="instance" type="Number"/>
      <property name="initialPan" scope="instance" type="Number"/>
      <property name="isDebug" scope="instance" type="Boolean"/>
      <property name="statusInterval" scope="instance" type="Number"/>
      <property name="_swfPath" scope="instance" type="Uri"/>
      <property name="allowScriptAccess" scope="instance" type="String"/>
      <property name="allowNetworking" scope="instance" type="String"/>
      <property name="_subs" scope="instance" type="Array"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLAudio._flashObject">
    <methods>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.global">
    <methods>
      <method name="swfIsInHTML" scope="instance"/>
      <method name="$" scope="instance"/>
      <method name="jQuery" scope="instance"/>
    </methods>
    <properties>
      <property name="_loadedCss" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLVideo" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="newUrl" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="instance"/>
      <method name="seek" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="volume" scope="instance">
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="mov" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="instance">
        <parameters>
          <parameter name="percent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSwfSized" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="instance"/>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance"/>
      <method name="_checkBuffer" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
          <parameter name="bufferLength" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.av._Media.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dojox.av._Media" scope="instance"/>
    </mixins>
    <properties>
      <property name="_swfPath" scope="instance" type="Uri"/>
      <property name="_subs" scope="instance" type="Array"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="mediaUrl" scope="instance" type="Object"/>
      <property name="initialVolume" scope="instance" type="Object"/>
      <property name="isPlaying" scope="instance" type="bool"/>
      <property name="isStopped" scope="instance" type="bool"/>
      <property name="isBuffering" scope="instance" type="Object"/>
      <property name="percentDownloaded" scope="instance" type="Object"/>
      <property name="_updateHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLVideo._flashObject">
    <methods>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av._Media">
    <description>Calculates the current status of the playing media and fires
	the appropriate events.</description>
    <methods>
      <method name="_initStatus" scope="instance"/>
      <method name="getTime" scope="instance">
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="mov" type="SWF" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="instance">
        <parameters>
          <parameter name="percent" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSwfSized" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="instance"/>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance"/>
      <method name="_figureStatus" scope="instance"/>
      <method name="_eventFactory" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_sub" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="instance">
        <parameters>
          <parameter name="vol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeUrl" scope="instance">
        <parameters>
          <parameter name="_url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="mediaUrl" scope="instance" type="String"/>
      <property name="initialVolume" scope="instance" type="Float"/>
      <property name="autoPlay" scope="instance" type="Boolean"/>
      <property name="bufferTime" scope="instance" type="Number"/>
      <property name="minBufferTime" scope="instance" type="Number"/>
      <property name="updateTime" scope="instance" type="Number"/>
      <property name="id" scope="instance" type="String"/>
      <property name="isDebug" scope="instance" type="Boolean"/>
      <property name="percentDownloaded" scope="instance" type="read-only-Number"/>
      <property name="_flashObject" scope="instance" type="read-only-Object"/>
      <property name="flashMedia" scope="instance" type="read-only-SWF"/>
      <property name="allowScriptAccess" scope="instance" type="String"/>
      <property name="allowNetworking" scope="instance" type="String"/>
      <property name="wmode" scope="instance" type="String"/>
      <property name="allowFullScreen" scope="instance" type="Boolean"/>
      <property name="status" scope="instance" type="String"/>
      <property name="_positionHandle" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="isBuffering" scope="instance" type="Object"/>
      <property name="_prevPos" scope="instance" type="Object"/>
      <property name="_prevStatus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget"/>
  <class type="dojox.av.widget.PlayButton" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance"/>
      <method name="onPlay" scope="instance"/>
      <method name="onPause" scope="instance"/>
      <method name="showPlay" scope="instance"/>
      <method name="showPause" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="_mode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Player" superclass="dijit._Widget">
    <description>Currently for markup only. All controls should reside as child
	nodes within the Player node. 'controlType' is used to determine
	the placement of the control. If no type or an unrecoginized type
	is used, it will be left-aligned in the same row as the volume.
	Note:
	Be sure to use 'controlType' as a node attribute. It is not a
	property of the widget.</description>
    <methods>
      <method name="_fillContent" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="playerWidth" scope="instance" type="Number"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="items" scope="instance" type="Array"/>
      <property name="children" scope="instance" type="Array"/>
      <property name="media" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.ProgressSlider" superclass="dijit._Widget">
    <description>Displays the current playhead position of the media. Has two
	progress bars: one for playhead position, and one for download
	progress.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
          <parameter name="playerWidget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="evt" type="HTMLEvent" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="instance"/>
      <method name="endDrag" scope="instance"/>
      <method name="setHandle" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setLoadedPosition" scope="instance">
        <parameters>
          <parameter name="decimal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleOver" scope="instance"/>
      <method name="handleOut" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="seeking" scope="instance" type="bool"/>
      <property name="handleWidth" scope="instance" type="Object"/>
      <property name="finalWidth" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="playerWidget" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="cmove" scope="instance" type="Object"/>
      <property name="cup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status" superclass="dijit._Widget">
    <description>Displays the name of the media file, and it's current status
	(playing, paused, buffering, etc.) in the middle. Displays
	the playhead time on the left and the duration on the right.</description>
    <methods>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="instance"/>
      <method name="onPlay" scope="instance"/>
      <method name="onPaused" scope="instance"/>
      <method name="onStop" scope="instance"/>
      <method name="onEnd" scope="instance"/>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="setStatus" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
          <parameter name="isError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toSeconds" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="isBuffering" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status.durNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.av.widget.VolumeButton" superclass="dijit._Widget">
    <description>Controls and displays the volume of the media. This widget
	opens a slider on click that is used to adjust the volume.
	The icon changes according to the volume level.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateIcon" scope="instance">
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onShowVolume" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDocClick" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onHideVolume" scope="instance"/>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="instance"/>
      <method name="endDrag" scope="instance"/>
      <method name="handleOver" scope="instance"/>
      <method name="handleOut" scope="instance"/>
      <method name="_getVolumeDim" scope="instance"/>
      <method name="_getHandleDim" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="handleWidth" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="slotWidth" scope="instance" type="Number"/>
      <property name="volumeSlider" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="showing" scope="instance" type="bool"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="clickOff" scope="instance" type="Object"/>
      <property name="isDragging" scope="instance" type="bool"/>
      <property name="cmove" scope="instance" type="Object"/>
      <property name="cup" scope="instance" type="Object"/>
      <property name="_domCoords" scope="instance" type="Object"/>
      <property name="_handleCoords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc">
    <methods>
      <method name="approx" scope="instance">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pow" scope="instance">
        <parameters>
          <parameter name="base" type="Number" usage="required"/>
          <parameter name="exponent" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="toFrac" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.calc.FuncGen" superclass="dijit._Widget">
    <methods>
      <method name="onSelect" scope="instance"/>
      <method name="onClear" scope="instance"/>
      <method name="saveFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSaved" scope="instance"/>
      <method name="clear" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="onReset" scope="instance"/>
      <method name="deleteThing" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance"/>
      <method name="readyStatus" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="writeStore" scope="instance" type="Object"/>
      <property name="readStore" scope="instance" type="Object"/>
      <property name="functions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.FuncGen.combo">
    <properties>
      <property name="item" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.GraphPro" superclass="dojox.calc.Standard">
    <methods>
      <method name="executorLoaded" scope="instance"/>
      <method name="makeFunctionWindow" scope="instance"/>
      <method name="makeGrapherWindow" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.calc.Standard" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="grapher" scope="instance" type="Object"/>
      <property name="funcMaker" scope="instance" type="Object"/>
      <property name="aFloatingPane" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.Grapher" superclass="dijit._Widget">
    <methods>
      <method name="addXYAxes" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectAll" scope="instance"/>
      <method name="deselectAll" scope="instance"/>
      <method name="drawOne" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraw" scope="instance"/>
      <method name="erase" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onErase" scope="instance"/>
      <method name="onDelete" scope="instance"/>
      <method name="createFunction" scope="instance"/>
      <method name="setStatus" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
          <parameter name="status" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changedColor" scope="instance"/>
      <method name="makeDirty" scope="instance"/>
      <method name="checkDirty1" scope="instance"/>
      <method name="checkDirty" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="chart" type="Chart2D" usage="required"/>
          <parameter name="functionToGraph" type="Function" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generatePoints" scope="instance">
        <parameters>
          <parameter name="funcToGraph" type="Function" usage="required"/>
          <parameter name="x" type="String" usage="required"/>
          <parameter name="y" type="String" usage="required"/>
          <parameter name="width" type="Number" usage="required"/>
          <parameter name="minX" type="Number" usage="required"/>
          <parameter name="maxX" type="Number" usage="required"/>
          <parameter name="minY" type="Number" usage="required"/>
          <parameter name="maxY" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="someone pushed cancel in the val code"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="checkboxIndex" scope="instance" type="Number"/>
      <property name="functionMode" scope="instance" type="Number"/>
      <property name="expressionIndex" scope="instance" type="Number"/>
      <property name="colorIndex" scope="instance" type="Number"/>
      <property name="dropDownIndex" scope="instance" type="Number"/>
      <property name="tooltipIndex" scope="instance" type="Number"/>
      <property name="colorBoxFieldsetIndex" scope="instance" type="Number"/>
      <property name="statusIndex" scope="instance" type="Number"/>
      <property name="chartIndex" scope="instance" type="Number"/>
      <property name="funcNumberIndex" scope="instance" type="Number"/>
      <property name="evaluatedExpression" scope="instance" type="Number"/>
      <property name="functionRef" scope="instance" type="Number"/>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="funcNumber" scope="instance" type="Number"/>
      <property name="rowCount" scope="instance" type="Number"/>
      <property name="array" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.calc.Standard" superclass="dijit._Widget">
    <methods>
      <method name="executorLoaded" scope="instance"/>
      <method name="saveFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="isReadOnly" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parseTextbox" scope="instance"/>
      <method name="cycleCommands" scope="instance">
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cycleCommandUp" scope="instance"/>
      <method name="cycleCommandDown" scope="instance"/>
      <method name="onBlur" scope="instance"/>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertMinus" scope="instance"/>
      <method name="print" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="isRight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTextboxValue" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putInAnsIfTextboxIsHighlighted" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearText" scope="instance"/>
      <method name="insertOperator" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="readStore" scope="instance" type="Object"/>
      <property name="writeStore" scope="instance" type="Object"/>
      <property name="functions" scope="instance" type="Array"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="commandIndex" scope="instance" type="Number"/>
      <property name="hasDisplay" scope="instance" type="Object"/>
      <property name="handle" scope="instance" type="Object"/>
      <property name="commandList" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.calc.Standard.textboxWidget.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
      <property name="selectionEnd" scope="instance" type="String"/>
      <property name="selectionStart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.Standard.displayBox">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.calc._Executor" superclass="dijit._Widget">
    <methods>
      <method name="_onLoad" scope="instance">
        <parameters>
          <parameter name="env" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="Function" scope="instance">
        <parameters>
          <parameter name="name" type="this" usage="required"/>
          <parameter name="args" type="the" usage="required"/>
          <parameter name="body" type="the" usage="required"/>
        </parameters>
      </method>
      <method name="normalizedFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="eval" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting">
    <properties>
      <property name="__ChartCtorArgs" scope="instance" type="Object"/>
      <property name="Chart2D" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Chart">
    <description>dojox.charting.Chart is the primary object used for any kind of charts.  It
	is simple to create--just pass it a node reference, which is used as the
	container for the chart--and a set of optional keyword arguments and go.
	Note that like most of dojox.gfx, most of dojox.charting.Chart's methods are
	designed to return a reference to the chart itself, to allow for functional
	chaining.  This makes defining everything on a Chart very easy to do.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.__ChartCtorArgs" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Chart
	The newly created chart.</return-description>
      </method>
      <method name="destroy" scope="instance">
        <return-description>void</return-description>
      </method>
      <method name="getCoords" scope="instance">
        <return-description>Object
	The resulting coordinates of the chart.  See dojo.coords for details.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setTheme" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The axis as stored in the chart's axis map.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="removeAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addPlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__PlotCtorArgs" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="removePlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getPlotOrder" scope="instance">
        <return-description>Array</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="setPlotOrder" scope="instance">
        <parameters>
          <parameter name="newOrder" type="Array:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="movePlotToFront" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="movePlotToBack" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
          <parameter name="data" type="Array|Object:" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.__SeriesCtorArgs:" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Chart:
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="removeSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="updateSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="data" type="Array|Object:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getSeriesOrder" scope="instance">
        <parameters>
          <parameter name="plotName" type="String:" usage="required"/>
        </parameters>
        <return-description>Array</return-description>
      </method>
      <method name="setSeriesOrder" scope="instance">
        <parameters>
          <parameter name="newOrder" type="Array:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="moveSeriesToFront" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="moveSeriesToBack" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="resize" scope="instance">
        <description>Resize the chart and its surface to the width and height dimensions.
	If no width/height or box is provided, resize the surface to the marginBox of the chart.</description>
        <parameters>
          <parameter name="width" type="Number" usage="required"/>
          <parameter name="height" type="Number" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getGeometry" scope="instance">
        <return-description>Object
	An map of geometry objects, a one-to-one mapping of axes.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setAxisWindow" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="scale" type="Number" usage="required"/>
          <parameter name="offset" type="Number" usage="required"/>
          <parameter name="zoom" type="Boolean|Object" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="setWindow" scope="instance">
        <parameters>
          <parameter name="sx" type="Number" usage="required"/>
          <parameter name="sy" type="Number" usage="required"/>
          <parameter name="dx" type="Number" usage="required"/>
          <parameter name="dy" type="Number" usage="required"/>
          <parameter name="zoom" type="Boolean|Object" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="zoomIn" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="range" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="calculateGeometry" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="fullGeometry" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="fullRender" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="delayedRender" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="connectToPlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="Function" usage="required"/>
        </parameters>
        <return-description>Array
	A handle to the connection, as defined by dojo.connect (see dojo.connect).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fireEvent" scope="instance">
        <parameters>
          <parameter name="seriesName" type="String:" usage="required"/>
          <parameter name="eventName" type="String:" usage="required"/>
          <parameter name="index" type="Number:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="_makeClean" scope="instance"/>
      <method name="_makeDirty" scope="instance"/>
      <method name="_invalidateDependentPlots" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
          <parameter name="verticalAxis" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="coords" scope="instance-prototype" type="Object"/>
      <property name="theme" scope="instance-prototype" type="Object"/>
      <property name="dirty" scope="instance-prototype" type="Object"/>
      <property name="runs" scope="instance-prototype" type="Object"/>
      <property name="series" scope="instance-prototype" type="Array"/>
      <property name="stack" scope="instance-prototype" type="Array"/>
      <property name="dim" scope="instance" type="Object"/>
      <property name="offsets" scope="instance" type="Object"/>
      <property name="titleGap" scope="instance-prototype" type="Object"/>
      <property name="titlePos" scope="instance-prototype" type="String"/>
      <property name="titleFont" scope="instance-prototype" type="Object"/>
      <property name="titleFontColor" scope="instance-prototype" type="String"/>
      <property name="plotArea" scope="instance" type="Object"/>
      <property name="chartTitle" scope="instance-prototype" type="Object"/>
      <property name="_delayedRenderHandle" scope="instance" type="Object"/>
      <property name="margins" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="delayInMs" scope="instance" type="Number"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="axes" scope="instance" type="Object"/>
      <property name="plots" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang">
    <methods>
      <method name="observable" scope="instance">
        <parameters>
          <parameter name="wrapped" type="Object" usage="required"/>
          <parameter name="onRead" type="function" usage="required"/>
          <parameter name="onWrite" type="function" usage="required"/>
          <parameter name="onInvoke" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="makeObservable" scope="instance">
        <parameters>
          <parameter name="onRead" type="function" usage="required"/>
          <parameter name="onWrite" type="function" usage="required"/>
          <parameter name="onInvoke" type="function" usage="required"/>
          <parameter name="hiddenFunctions" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="do it with getters and setters"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="lettableWin" scope="instance" type="Object"/>
      <property name="ReadOnlyProxy" scope="instance" type="Object"/>
      <property name="typed" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Chart3D">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
          <parameter name="camera" type="Object" usage="required"/>
          <parameter name="theme" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generate" scope="instance"/>
      <method name="invalidate" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="addPlot" scope="instance">
        <parameters>
          <parameter name="plot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePlot" scope="instance">
        <parameters>
          <parameter name="plot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addWall" scope="instance">
        <parameters>
          <parameter name="wall" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeWall" scope="instance">
        <parameters>
          <parameter name="wall" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_generateWalls" scope="instance"/>
      <method name="_generatePlots" scope="instance"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="view" scope="instance" type="Object"/>
      <property name="theme" scope="instance" type="Object"/>
      <property name="walls" scope="instance" type="Array"/>
      <property name="plots" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d">
    <methods>
      <method name="gradient" scope="instance">
        <parameters>
          <parameter name="model" type="dojox.gfx3d.lighting.Model:" usage="required"/>
          <parameter name="material" type="Object:" usage="required"/>
          <parameter name="center" type="Object:" usage="required"/>
          <parameter name="radius" type="Number:" usage="required"/>
          <parameter name="from" type="Number:" usage="required"/>
          <parameter name="to" type="Number:" usage="required"/>
          <parameter name="matrix" type="dojox.gfx3d.Matrix3D:" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="Matrix3D" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx">
    <description>dojox.gfx is an advanced API providing normalized vector drawing
	in a variety of browsers. It has individual renderers for SVG, VML,
	Canvas, and Silverlight.</description>
    <methods>
      <method name="normalizedLength" scope="instance">
        <parameters>
          <parameter name="len" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getVectorFont" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeColor" scope="instance">
        <parameters>
          <parameter name="color" type="Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="normalizeParameters" scope="instance">
        <parameters>
          <parameter name="existed" type="Object" usage="required"/>
          <parameter name="update" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeParameters" scope="instance">
        <parameters>
          <parameter name="defaults" type="Object" usage="required"/>
          <parameter name="update" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formatNumber" scope="instance">
        <parameters>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="addSpace" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makeFontString" scope="instance">
        <parameters>
          <parameter name="font" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="splitFontString" scope="instance">
        <description>Converts a CSS font string to a gfx font object. The CSS font
	string components should follow the W3C specified order
	(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):
	style, variant, weight, size, optional line height (will be
	ignored), and family.</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="px_in_pt" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pt2px" scope="instance">
        <parameters>
          <parameter name="len" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="px2pt" scope="instance">
        <parameters>
          <parameter name="len" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="equalSources" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="switchTo" scope="instance">
        <parameters>
          <parameter name="renderer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hasClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_addClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_removeClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="decompose" scope="instance">
        <description>this function decompose a matrix into four logical components:
	translation, rotation, scaling, and one more rotation using SVD.
	The components should be applied in following order:
	 [translate, rotate(angle2), scale, rotate(angle1)]</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_vectorFontCache" scope="instance" type="Object"/>
      <property name="_svgFontCache" scope="instance" type="Object"/>
      <property name="VectorText" scope="instance" type="Object"/>
      <property name="getDefault" scope="instance" type="Object"/>
      <property name="cm_in_pt" scope="instance" type="Number"/>
      <property name="mm_in_pt" scope="instance" type="Number"/>
      <property name="pathVmlRegExp" scope="instance" type="RegExp"/>
      <property name="pathSvgRegExp" scope="instance" type="RegExp"/>
      <property name="attach" scope="instance" type="Object"/>
      <property name="canvas_attach" scope="instance" type="Object"/>
      <property name="Matrix2D" scope="instance" type="Object"/>
      <property name="move" scope="instance" type="Object"/>
      <property name="silverlight_attach" scope="instance" type="Object"/>
      <property name="svg_attach" scope="instance" type="Object"/>
      <property name="renderer" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.DataChart" superclass="dojox.charting.Chart2D">
    <description>This code should be considered very experimental and the APIs subject
	to change. This is currently an alpha version and will need some testing
	and review.
	The main reason for this extension is to create animated charts, generally
	available with scroll=true, and a property field that gets continually updated.
	The previous property settings are kept in memory and displayed until scrolled
	off the chart.
	Although great effort was made to maintain the integrity of the current
	charting APIs, some things have been added or modified in order to get
	the store to connect and also to get the data to scroll/animate.
	"displayRange" in particular is used to force the xaxis to a specific
	size and keep the chart from stretching or squashing to fit the data.
	Currently, plot lines can only be set at initialization. Setting
	a new store query will have no effect (although using setStore
	may work but its untested).</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="?" usage="required"/>
          <parameter name="fieldName" type="?" usage="required"/>
          <parameter name="queryOptions" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="storeObject" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDataReceived" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getProperty" scope="instance">
        <parameters>
          <parameter name="item" type="storeObject" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onData" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="convertLabels" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="seriesLabels" scope="instance">
        <parameters>
          <parameter name="val" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="resizeChart" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Chart2D" scope="instance"/>
    </mixins>
    <properties>
      <property name="scroll" scope="instance" type="Boolean"/>
      <property name="comparative" scope="instance" type="Boolean"/>
      <property name="query" scope="instance" type="String"/>
      <property name="queryOptions" scope="instance" type="String"/>
      <property name="fieldName" scope="instance" type="String"/>
      <property name="chartTheme" scope="instance" type="dojox.charting.themes.*"/>
      <property name="displayRange" scope="instance" type="Number"/>
      <property name="stretchToFit" scope="instance-prototype" type="Boolean"/>
      <property name="minWidth" scope="instance" type="Number"/>
      <property name="minHeight" scope="instance" type="Number"/>
      <property name="showing" scope="instance" type="Boolean"/>
      <property name="label" scope="instance" type="String"/>
      <property name="firstRun" scope="instance-prototype" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="onSetInterval" scope="instance-prototype" type="Number"/>
      <property name="items" scope="instance" type="Object"/>
      <property name="dataOffset" scope="instance-prototype" type="Number"/>
      <property name="dataLength" scope="instance-prototype" type="Number"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="onSetItems" scope="instance" type="Object"/>
      <property name="seriesData" scope="instance" type="Object"/>
      <property name="seriesDataBk" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.DataChart.xaxis">
    <properties>
      <property name="labelFunc" scope="instance" type="Object"/>
      <property name="to" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.DataChart.yaxis">
    <properties>
      <property name="labelFunc" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.DataChart.chartTheme.plotarea">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.DataSeries">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="store" type="Object:" usage="required"/>
          <parameter name="kwArgs" type="Object:" usage="required"/>
          <parameter name="value" type="Function|Object|String|Null:" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setSeriesObject" scope="instance">
        <parameters>
          <parameter name="series" type="dojox.charting.Series:" usage="required"/>
        </parameters>
      </method>
      <method name="_dictValue" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="dict" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fieldValue" scope="instance">
        <parameters>
          <parameter name="field" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultValue" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="errorData" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildItemMap" scope="instance"/>
      <method name="_pushDataChanges" scope="instance"/>
      <method name="_onStoreNew" scope="instance"/>
      <method name="_onStoreDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onStoreSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="series" scope="instance" type="Object"/>
      <property name="_inFlight" scope="instance" type="bool"/>
      <property name="items" scope="instance" type="Object"/>
      <property name="data" scope="instance-prototype" type="Array"/>
      <property name="itemMap" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object:"/>
      <property name="kwArgs" scope="instance" type="Object:"/>
      <property name="value" scope="instance" type="Function|Object|String|Null:"/>
      <property name="_events" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
        </parameters>
      </method>
      <method name="createGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="dojox.gfx.Surface" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="purgeGroup" scope="instance">
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="cleanGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="dojox.gfx.Surface" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="destroyHtmlElements" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="getTextWidth" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextWithLimitLength" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="optional"/>
          <parameter name="font" type="String" usage="optional"/>
          <parameter name="limitWidth" type="Number" usage="optional"/>
          <parameter name="truncated" type="whether" usage="required"/>
        </parameters>
        <return-description>Object
	{
	text: processed text, maybe truncated or not</return-description>
      </method>
      <method name="getTextWithLimitCharCount" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="optional"/>
          <parameter name="font" type="String" usage="optional"/>
          <parameter name="wcLimit" type="Number" usage="optional"/>
          <parameter name="truncated" type="whether" usage="required"/>
        </parameters>
        <return-description>Object
	{
	text: processed text, maybe truncated or not</return-description>
      </method>
      <method name="_plotFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_shapeFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="bbox" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pseudoRadialFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="center" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="group" scope="instance-prototype" type="dojox.gfx.Group"/>
      <property name="htmlElements" scope="instance-prototype" type="Array"/>
      <property name="dirty" scope="instance-prototype" type="Boolean"/>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="trailingSymbol" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Element.chart">
    <properties>
      <property name="surface" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Series" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="data" type="Array|Object:" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.__SeriesCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="update" scope="instance">
        <parameters>
          <parameter name="data" type="Array|Object:" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
    </mixins>
    <properties>
      <property name="dyn" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="source" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="plot" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.__SeriesCtorArgs">
    <methods/>
    <properties>
      <property name="plot" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.StoreSeries">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="store" type="Object:" usage="required"/>
          <parameter name="kwArgs" type="Object:" usage="required"/>
          <parameter name="value" type="Function|Object|String|Null:" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setSeriesObject" scope="instance">
        <parameters>
          <parameter name="series" type="dojox.charting.Series:" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="_pushDataChanges" scope="instance"/>
    </methods>
    <properties>
      <property name="series" scope="instance" type="Object"/>
      <property name="objects" scope="instance" type="Array"/>
      <property name="observeHandle" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object:"/>
      <property name="kwArgs" scope="instance" type="Object:"/>
      <property name="value" scope="instance" type="Function|Object|String|Null:"/>
      <property name="data" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme">
    <description>While you can set up style definitions on a chart directly (usually through the various add methods
	on a dojox.charting.Chart2D object), a Theme simplifies this manual setup by allowing you to
	pre-define all of the various visual parameters of each element in a chart.
	Most of the properties of a Theme are straight-forward; if something is line-based (such as
	an axis or the ticks on an axis), they will be defined using basic stroke parameters.  Likewise,
	if an element is primarily block-based (such as the background of a chart), it will be primarily
	fill-based.
	In addition (for convenience), a Theme definition does not have to contain the entire JSON-based
	structure.  Each theme is built on top of a default theme (which serves as the basis for the theme
	"GreySkies"), and is mixed into the default theme object.  This allows you to create a theme based,
	say, solely on colors for data series.
	Defining a new theme is relatively easy; see any of the themes in dojox.charting.themes for examples
	on how to define your own.
	When you set a theme on a chart, the theme itself is deep-cloned.  This means that you cannot alter
	the theme itself after setting the theme value on a chart, and expect it to change your chart.  If you
	are looking to make alterations to a theme for a chart, the suggestion would be to create your own
	theme, based on the one you want to use, that makes those alterations before it is applied to a chart.
	Finally, a Theme contains a number of functions to facilitate rendering operations on a chart--the main
	helper of which is the ~next~ method, in which a chart asks for the information for the next data series
	to be rendered.
	A note on colors:
	The Theme constructor was on the use of dojox.color.Palette (in general) for creating a visually distinct
	set of colors for usage in a chart.  A palette is usually comprised of 5 different color definitions, and
	no more.  If you have a need to render a chart with more than 5 data elements, you can simply "push"
	new color definitions into the theme's .color array.  Make sure that you do that with the actual
	theme object from a Chart, and not in the theme itself (i.e. either do that before using .setTheme
	on a chart).</description>
    <methods>
      <method name="defineColors" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.charting.Theme.__DefineColorArgs" usage="required"/>
        </parameters>
        <return-description>dojo.Color[]
	An array of colors for use in a theme.</return-description>
        <return-types>
          <return-type type="dojo.Color[]"/>
        </return-types>
      </method>
      <method name="generateGradient" scope="instance">
        <parameters>
          <parameter name="fillPattern" type="Object" usage="required"/>
          <parameter name="colorFrom" type="Object" usage="required"/>
          <parameter name="colorTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generateHslColor" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
          <parameter name="luminance" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generateHslGradient" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
          <parameter name="fillPattern" type="Object" usage="required"/>
          <parameter name="lumFrom" type="Object" usage="required"/>
          <parameter name="lumTo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <return-description>dojox.charting.Theme
	The cloned theme; any alterations made will not affect the original.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="String" usage="optional"/>
          <parameter name="mixin" type="Object" usage="optional"/>
          <parameter name="doPost" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>Object
	An object of the structure { series, marker, symbol }</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="skip" scope="instance"/>
      <method name="addMixin" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required"/>
          <parameter name="elementType" type="String" usage="required"/>
          <parameter name="mixin" type="Object|Array" usage="required"/>
          <parameter name="doPost" type="Boolean" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Theme
	The new theme.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required"/>
          <parameter name="elementType" type="String" usage="required"/>
        </parameters>
        <return-description>dojox.charting.Theme
	The post-processed theme.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="getTick" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="mixin" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspectObjects" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reverseFills" scope="instance"/>
      <method name="addMarker" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="segment" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setMarkers" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildMarkerArray" scope="instance"/>
    </methods>
    <properties>
      <property name="defaultColors" scope="instance" type="Array"/>
      <property name="_current" scope="instance-prototype" type="Number"/>
      <property name="markers" scope="instance-prototype" type="Object"/>
      <property name="_markers" scope="instance" type="Array"/>
      <property name="colors" scope="instance" type="Object"/>
      <property name="seriesThemes" scope="instance" type="Object"/>
      <property name="markerThemes" scope="instance" type="Object"/>
      <property name="noGradConv" scope="instance" type="Object"/>
      <property name="noRadialConv" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultMarkers">
    <properties>
      <property name="CIRCLE" scope="instance" type="String"/>
      <property name="SQUARE" scope="instance" type="String"/>
      <property name="DIAMOND" scope="instance" type="String"/>
      <property name="CROSS" scope="instance" type="String"/>
      <property name="X" scope="instance" type="String"/>
      <property name="TRIANGLE" scope="instance" type="String"/>
      <property name="TRIANGLE_INVERTED" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme"/>
  <class type="dojox.charting.Theme.defaultTheme.chart">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="String"/>
      <property name="pageStyle" scope="instance" type="Object"/>
      <property name="titleGap" scope="instance" type="Number"/>
      <property name="titlePos" scope="instance" type="String"/>
      <property name="titleFont" scope="instance" type="String"/>
      <property name="titleFontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.plotarea">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis"/>
  <class type="dojox.charting.Theme.defaultTheme.axis.stroke">
    <properties>
      <property name="color" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis.tick">
    <properties>
      <property name="color" scope="instance" type="String"/>
      <property name="position" scope="instance" type="String"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
      <property name="titleGap" scope="instance" type="Number"/>
      <property name="titleFont" scope="instance" type="String"/>
      <property name="titleFontColor" scope="instance" type="String"/>
      <property name="titleOrientation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis.majorTick">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis.minorTick">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis.microTick">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.series">
    <properties>
      <property name="shadow" scope="instance" type="dx:"/>
      <property name="fill" scope="instance" type="String"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.series.stroke">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.series.outline">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.series.labelWiring">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.marker">
    <properties>
      <property name="shadow" scope="instance" type="dx:"/>
      <property name="fill" scope="instance" type="String"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.marker.stroke">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.marker.outline">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.shapeSpaces">
    <properties>
      <property name="shape" scope="instance" type="Number"/>
      <property name="shapeX" scope="instance" type="Number"/>
      <property name="shapeY" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.__DefineColorArgs">
    <methods/>
    <properties>
      <property name="num" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="String[]|dojo.Color[]"/>
      <property name="hue" scope="instance" type="Number"/>
      <property name="saturation" scope="instance" type="Number"/>
      <property name="low" scope="instance" type="Number"/>
      <property name="high" scope="instance" type="Number"/>
      <property name="base" scope="instance" type="String|dojo.Color"/>
      <property name="generator" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d">
    <properties>
      <property name="__BaseCtorArgs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="plot" type="String" usage="optional"/>
          <parameter name="kwargs" type="dojox.charting.action2d.__BaseCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="disconnect" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="handle" scope="instance" type="Object"/>
      <property name="anim" scope="instance-prototype" type="Object"/>
      <property name="chart" scope="instance" type="dojox.charting.Chart2D"/>
      <property name="plot" scope="instance" type="String"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Base.overOutEvents">
    <properties>
      <property name="onmouseover" scope="instance" type="Number"/>
      <property name="onmouseout" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__HighlightCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="highlight" scope="instance" type="String|dojo.Color|Function"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="plot" type="String" usage="optional"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__HighlightCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="colorFun" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Number"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight.optionalParams">
    <properties>
      <property name="highlight" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__MagnifyCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Magnify" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="plot" type="String" usage="optional"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MagnifyCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Magnify.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Number"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__MoveSliceCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="scale" scope="instance" type="Number"/>
      <property name="shift" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MoveSlice" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="plot" type="String" usage="optional"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MoveSliceCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="angles" scope="instance" type="Object"/>
      <property name="shift" scope="instance-prototype" type="Number"/>
      <property name="scale" scope="instance-prototype" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MoveSlice.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Number"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__ShakeCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="shift" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Shake" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="plot" type="String" usage="optional"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__ShakeCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="shiftX" scope="instance" type="Object"/>
      <property name="shiftY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Shake.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Number"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="shiftX" scope="instance" type="Object"/>
      <property name="shiftY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__TooltipCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods>
      <method name="text" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.Tooltip" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="plot" type="String" usage="optional"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__TooltipCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="aroundRect" scope="instance" type="Object"/>
      <property name="angles" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Tooltip.defaultParams">
    <properties>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d">
    <properties>
      <property name="__AxisCtorArgs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Base" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-description>Boolean
	If the axis is initialized or not.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="calculate" scope="instance">
        <parameters>
          <parameter name="min" type="Object" usage="required"/>
          <parameter name="max" type="Object" usage="required"/>
          <parameter name="span" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
      <method name="getScaler" scope="instance">
        <return-description>Object
	The scaler object (see dojox.charting.scaler.linear for more information)</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTicks" scope="instance">
        <return-description>Object
	The ticks object.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getOffsets" scope="instance">
        <return-description>Object
	An object of the form { l, r, t, b }.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="vertical" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default" superclass="dojox.charting.axis2d.Invisible">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="getOffsets" scope="instance">
        <return-description>Object
	The calculated offsets in the form of { l, r, t, b } (left, right, top, bottom).</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="labelTooltip" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
          <parameter name="truncatedLabel" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="elemType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.axis2d.Invisible" scope="instance"/>
    </mixins>
    <properties>
      <property name="trailingSymbol" scope="instance" type="Object"/>
      <property name="_cachedLabelWidth" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.defaultParams">
    <properties>
      <property name="vertical" scope="instance" type="bool"/>
      <property name="fixUpper" scope="instance" type="String"/>
      <property name="fixLower" scope="instance" type="String"/>
      <property name="natural" scope="instance" type="bool"/>
      <property name="leftBottom" scope="instance" type="Object"/>
      <property name="includeZero" scope="instance" type="bool"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="majorLabels" scope="instance" type="Object"/>
      <property name="minorTicks" scope="instance" type="Object"/>
      <property name="minorLabels" scope="instance" type="Object"/>
      <property name="microTicks" scope="instance" type="bool"/>
      <property name="rotation" scope="instance" type="Number"/>
      <property name="htmlLabels" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.optionalParams">
    <properties>
      <property name="min" scope="instance" type="Number"/>
      <property name="max" scope="instance" type="Number"/>
      <property name="from" scope="instance" type="Number"/>
      <property name="to" scope="instance" type="Number"/>
      <property name="majorTickStep" scope="instance" type="Number"/>
      <property name="minorTickStep" scope="instance" type="Number"/>
      <property name="microTickStep" scope="instance" type="Number"/>
      <property name="labels" scope="instance" type="Array"/>
      <property name="labelFunc" scope="instance" type="Object"/>
      <property name="maxLabelSize" scope="instance" type="Number"/>
      <property name="maxLabelCharCount" scope="instance" type="Number"/>
      <property name="trailingSymbol" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="majorTick" scope="instance" type="Object"/>
      <property name="minorTick" scope="instance" type="Object"/>
      <property name="microTick" scope="instance" type="Object"/>
      <property name="tick" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
      <property name="titleGap" scope="instance" type="Number"/>
      <property name="titleFont" scope="instance" type="String"/>
      <property name="titleFontColor" scope="instance" type="String"/>
      <property name="titleOrientation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.scaler">
    <properties>
      <property name="major" scope="instance" type="Object"/>
      <property name="minor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.chart.theme">
    <properties>
      <property name="axis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.opt">
    <properties>
      <property name="font" scope="instance" type="Object"/>
      <property name="titleFont" scope="instance" type="Object"/>
      <property name="leftBottom" scope="instance" type="Object"/>
      <property name="fontColor" scope="instance" type="Object"/>
      <property name="titleFontColor" scope="instance" type="Object"/>
      <property name="titleOrientation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.scaler"/>
  <class type="dojox.charting.axis2d.Invisible" superclass="dojox.charting.axis2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="dependOnData" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-description>Boolean
	Whether a scaler has been calculated and if the axis is not dirty.</return-description>
      </method>
      <method name="setWindow" scope="instance">
        <parameters>
          <parameter name="scale" type="Number" usage="required"/>
          <parameter name="offset" type="Number" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="getWindowScale" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getWindowOffset" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_groupLabelWidth" scope="instance">
        <parameters>
          <parameter name="labels" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="wcLimit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculate" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="labels" type="String[]" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="getScaler" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTicks" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.axis2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="labels" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.defaultParams">
    <properties>
      <property name="vertical" scope="instance" type="bool"/>
      <property name="fixUpper" scope="instance" type="String"/>
      <property name="fixLower" scope="instance" type="String"/>
      <property name="natural" scope="instance" type="bool"/>
      <property name="leftBottom" scope="instance" type="Object"/>
      <property name="includeZero" scope="instance" type="bool"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="majorLabels" scope="instance" type="Object"/>
      <property name="minorTicks" scope="instance" type="Object"/>
      <property name="minorLabels" scope="instance" type="Object"/>
      <property name="microTicks" scope="instance" type="bool"/>
      <property name="rotation" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.optionalParams">
    <properties>
      <property name="min" scope="instance" type="Number"/>
      <property name="max" scope="instance" type="Number"/>
      <property name="from" scope="instance" type="Number"/>
      <property name="to" scope="instance" type="Number"/>
      <property name="majorTickStep" scope="instance" type="Number"/>
      <property name="minorTickStep" scope="instance" type="Number"/>
      <property name="microTickStep" scope="instance" type="Number"/>
      <property name="labels" scope="instance" type="Array"/>
      <property name="labelFunc" scope="instance" type="Object"/>
      <property name="maxLabelSize" scope="instance" type="Number"/>
      <property name="maxLabelCharCount" scope="instance" type="Number"/>
      <property name="trailingSymbol" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.scaler">
    <properties>
      <property name="bounds" scope="instance" type="Object"/>
      <property name="minMinorStep" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.opt">
    <properties>
      <property name="from" scope="instance" type="String"/>
      <property name="to" scope="instance" type="String"/>
      <property name="font" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.chart.theme">
    <properties>
      <property name="axis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.utils">
    <methods>
      <method name="merge" scope="instance">
        <parameters>
          <parameter name="object" type="Object:" usage="required"/>
          <parameter name="mixin" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="coerceType" scope="instance">
        <parameters>
          <parameter name="target" type="Object:" usage="required"/>
          <parameter name="source" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="updateWithObject" scope="instance">
        <parameters>
          <parameter name="target" type="Object:" usage="required"/>
          <parameter name="source" type="Object:" usage="required"/>
          <parameter name="conv" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="updateWithPattern" scope="instance">
        <parameters>
          <parameter name="target" type="Object:" usage="required"/>
          <parameter name="source" type="Object:" usage="required"/>
          <parameter name="pattern" type="Object:" usage="required"/>
          <parameter name="conv" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.axis2d.common"/>
  <class type="dojox.charting.axis2d.common.createText">
    <methods>
      <method name="gfx" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="creator" type="dojox.gfx.Surface" usage="required"/>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="y" type="Number" usage="required"/>
          <parameter name="align" type="String" usage="required"/>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="font" type="String" usage="required"/>
          <parameter name="fontColor" type="String|dojo.Color" usage="required"/>
        </parameters>
        <return-description>dojox.gfx.Text
	The resultant GFX object.</return-description>
      </method>
      <method name="html" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="creator" type="dojox.gfx.Surface" usage="required"/>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="y" type="Number" usage="required"/>
          <parameter name="align" type="String" usage="required"/>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="font" type="String" usage="required"/>
          <parameter name="fontColor" type="String|dojo.Color" usage="required"/>
          <parameter name="labelWidth" type="Number" usage="optional"/>
        </parameters>
        <return-description>DOMNode
	The resultant DOMNode (a "div" element).</return-description>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot2d">
    <methods>
      <method name="__PlotCtorArgs" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.plot2d.Areas" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Areas.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__BarCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Bars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Bars"/>
        </return-types>
      </method>
      <method name="_animateBar" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="hoffset" type="Object" usage="required"/>
          <parameter name="hsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.chart.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__PlotCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="dojox.charting.axis2d.Base" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="dojox.charting.Series" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="calculateAxes" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <return-description>Boolean
	The state of the plot.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isDataDirty" scope="instance">
        <return-description>Boolean
	Flag indicating if any of this plot's series are invalid and need rendering.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="performZoom" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	The number of colors needed.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="initializeScalers" scope="instance">
        <parameters>
          <parameter name="dim" type="Object:" usage="required"/>
          <parameter name="stats" type="Object:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="series" scope="instance" type="Array"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="zoom" scope="instance" type="Object"/>
      <property name="zoomQueue" scope="instance" type="Array"/>
      <property name="lastWindow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base._vAxis">
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base._hAxis">
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base._hScaler">
    <properties>
      <property name="bounds" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base._vScaler">
    <properties>
      <property name="bounds" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Bubble
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Bubble"/>
        </return-types>
      </method>
      <method name="_animateBubble" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble.optionalParams">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="collectStats" scope="instance">
        <parameters>
          <parameter name="series" type="dojox.charting.Series[]" usage="required"/>
        </parameters>
        <return-description>Object
	Returns an object in the form of { hmin, hmax, vmin, vmax }.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Candlesticks
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Candlesticks"/>
        </return-types>
      </method>
      <method name="_animateCandlesticks" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredBars" superclass="dojox.charting.plot2d.Bars">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.ClusteredBars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.ClusteredBars"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Bars" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredBars.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredColumns" superclass="dojox.charting.plot2d.Columns">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.ClusteredColumns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.ClusteredColumns"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Columns" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredColumns.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Columns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Columns"/>
        </return-types>
      </method>
      <method name="_animateColumn" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__DefaultCtorArgs" superclass="dojox.charting.plot2d.__PlotCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__PlotCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="lines" scope="instance" type="Boolean"/>
      <property name="areas" scope="instance" type="Boolean"/>
      <property name="markers" scope="instance" type="Boolean"/>
      <property name="tension" scope="instance" type="Number|String"/>
      <property name="animate" scope="instance" type="Boolean"/>
      <property name="stroke" scope="instance" type="dojox.gfx.Stroke"/>
      <property name="outline" scope="instance" type="dojox.gfx.Stroke"/>
      <property name="shadow" scope="instance" type="dojox.gfx.Stroke"/>
      <property name="fill" scope="instance" type="dojox.gfx.Fill"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String|dojo.Color"/>
      <property name="markerStroke" scope="instance" type="dojo.gfx.Stroke"/>
      <property name="markerOutline" scope="instance" type="dojo.gfx.Stroke"/>
      <property name="markerShadow" scope="instance" type="dojo.gfx.Stroke"/>
      <property name="markerFill" scope="instance" type="dojo.gfx.Fill"/>
      <property name="markerFont" scope="instance" type="String"/>
      <property name="markerFontColor" scope="instance" type="String|dojo.Color"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Default
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Default"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="bool"/>
      <property name="markers" scope="instance" type="bool"/>
      <property name="tension" scope="instance" type="String"/>
      <property name="animate" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default.optionalParams">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
      <property name="markerStroke" scope="instance" type="Object"/>
      <property name="markerOutline" scope="instance" type="Object"/>
      <property name="markerShadow" scope="instance" type="Object"/>
      <property name="markerFill" scope="instance" type="Object"/>
      <property name="markerFont" scope="instance" type="String"/>
      <property name="markerFontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__GridCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="hMajorLines" scope="instance" type="Boolean"/>
      <property name="hMinorLines" scope="instance" type="Boolean"/>
      <property name="vMajorLines" scope="instance" type="Boolean"/>
      <property name="vMinorLines" scope="instance" type="Boolean"/>
      <property name="hStripes" scope="instance" type="String"/>
      <property name="vStripes" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__GridCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="initializeScalers" scope="instance"/>
      <method name="isDirty" scope="instance">
        <return-description>Boolean
	If this plot needs to be rendered, this will return true.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="performZoom" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	Returns 0, since there are no series associated with this plot type.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="_animateGrid" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="dirty" scope="instance-prototype" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
      <property name="zoom" scope="instance" type="Object"/>
      <property name="zoomQueue" scope="instance" type="Array"/>
      <property name="lastWindow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="hMajorLines" scope="instance" type="Object"/>
      <property name="hMinorLines" scope="instance" type="bool"/>
      <property name="vMajorLines" scope="instance" type="Object"/>
      <property name="vMinorLines" scope="instance" type="bool"/>
      <property name="hStripes" scope="instance" type="String"/>
      <property name="vStripes" scope="instance" type="String"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid._vAxis">
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid._hAxis">
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid.chart.theme">
    <properties>
      <property name="axis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Lines" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Lines.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Markers" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Markers.opt">
    <properties>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.MarkersOnly" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.MarkersOnly.opt">
    <properties>
      <property name="lines" scope="instance" type="bool"/>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="collectStats" scope="instance">
        <parameters>
          <parameter name="series" type="dojox.charting.Series[]" usage="required"/>
        </parameters>
        <return-description>Object
	Returns an object in the form of { hmin, hmax, vmin, vmax }.</return-description>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.OHLC
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.OHLC"/>
        </return-types>
      </method>
      <method name="_animateOHLC" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__PieCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="labels" scope="instance" type="Boolean"/>
      <property name="ticks" scope="instance" type="Boolean"/>
      <property name="fixed" scope="instance" type="Boolean"/>
      <property name="precision" scope="instance" type="Number"/>
      <property name="labelOffset" scope="instance" type="Number"/>
      <property name="labelStyle" scope="instance" type="String"/>
      <property name="htmlLabels" scope="instance" type="Boolean"/>
      <property name="radGrad" scope="instance" type="String"/>
      <property name="fanSize" scope="instance" type="Number"/>
      <property name="startAngle" scope="instance" type="Number"/>
      <property name="radius" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Pie
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="initializeScalers" scope="instance"/>
      <method name="getRequiredColors" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="continue"/>
          <return-type type="stop iteration"/>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="_getProperLabelRadius" scope="instance">
        <parameters>
          <parameter name="slices" type="Object" usage="required"/>
          <parameter name="labelHeight" type="Object" usage="required"/>
          <parameter name="minRidius" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_caculateLabelR" scope="instance">
        <parameters>
          <parameter name="firstSlice" type="Object" usage="required"/>
          <parameter name="slices" type="Object" usage="required"/>
          <parameter name="labelHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="dyn" scope="instance-prototype" type="Array"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.defaultParams">
    <properties>
      <property name="labels" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="bool"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="precision" scope="instance" type="Number"/>
      <property name="labelOffset" scope="instance" type="Number"/>
      <property name="labelStyle" scope="instance" type="String"/>
      <property name="htmlLabels" scope="instance" type="Object"/>
      <property name="radGrad" scope="instance" type="String"/>
      <property name="fanSize" scope="instance" type="Number"/>
      <property name="startAngle" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.optionalParams">
    <properties>
      <property name="radius" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
      <property name="labelWiring" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.opt">
    <properties>
      <property name="radius" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.run">
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Scatter
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Scatter"/>
        </return-types>
      </method>
      <method name="_animateScatter" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="shadows" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter.optionalParams">
    <properties>
      <property name="markerStroke" scope="instance" type="Object"/>
      <property name="markerOutline" scope="instance" type="Object"/>
      <property name="markerShadow" scope="instance" type="Object"/>
      <property name="markerFill" scope="instance" type="Object"/>
      <property name="markerFont" scope="instance" type="String"/>
      <property name="markerFontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Spider
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Spider
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="dojox.charting.Series" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="calculateAxes" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	The number of colors needed.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="initializeScalers" scope="instance">
        <parameters>
          <parameter name="dim" type="Object:" usage="required"/>
          <parameter name="stats" type="Object:" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Spider
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="_createSeriesEntry" scope="instance">
        <parameters>
          <parameter name="ts" type="Object" usage="required"/>
          <parameter name="osps" type="Object" usage="required"/>
          <parameter name="sps" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="sk" type="Object" usage="required"/>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="ro" type="Object" usage="required"/>
          <parameter name="ms" type="Object" usage="required"/>
          <parameter name="at" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="plotEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBoundary" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_drawArrow" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildPoints" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="circle" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="angle" type="Object" usage="required"/>
          <parameter name="recursive" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCoordinate" scope="instance">
        <parameters>
          <parameter name="circle" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="angle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getObjectLength" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="dyn" scope="instance-prototype" type="Array"/>
      <property name="series" scope="instance-prototype" type="Array"/>
      <property name="datas" scope="instance-prototype" type="Object"/>
      <property name="labelKey" scope="instance-prototype" type="Array"/>
      <property name="oldSeriePoints" scope="instance-prototype" type="Object"/>
      <property name="animations" scope="instance-prototype" type="Object"/>
      <property name="_hScaler" scope="instance" type="Object"/>
      <property name="_vScaler" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="aroundRect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.defaultParams">
    <properties>
      <property name="labels" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="bool"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="precision" scope="instance" type="Number"/>
      <property name="labelOffset" scope="instance" type="Number"/>
      <property name="labelStyle" scope="instance" type="String"/>
      <property name="htmlLabels" scope="instance" type="Object"/>
      <property name="startAngle" scope="instance" type="Number"/>
      <property name="divisions" scope="instance" type="Number"/>
      <property name="axisColor" scope="instance" type="String"/>
      <property name="axisWidth" scope="instance" type="Number"/>
      <property name="spiderColor" scope="instance" type="String"/>
      <property name="spiderWidth" scope="instance" type="Number"/>
      <property name="seriesWidth" scope="instance" type="Number"/>
      <property name="seriesFillAlpha" scope="instance" type="Number"/>
      <property name="spiderOrigin" scope="instance" type="Number"/>
      <property name="markerSize" scope="instance" type="Number"/>
      <property name="spiderType" scope="instance" type="String"/>
      <property name="animationType" scope="instance" type="Object"/>
      <property name="axisTickFont" scope="instance" type="String"/>
      <property name="axisTickFontColor" scope="instance" type="String"/>
      <property name="axisFont" scope="instance" type="String"/>
      <property name="axisFontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.optionalParams">
    <properties>
      <property name="radius" scope="instance" type="Number"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.chart">
    <properties>
      <property name="seriesShapes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.chart.theme">
    <properties>
      <property name="axis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.opt">
    <properties>
      <property name="radius" scope="instance" type="String"/>
      <property name="font" scope="instance" type="Object"/>
      <property name="axisFont" scope="instance" type="Object"/>
      <property name="axisTickFontColor" scope="instance" type="Object"/>
      <property name="axisFontColor" scope="instance" type="Object"/>
      <property name="axisColor" scope="instance" type="Object"/>
      <property name="spiderColor" scope="instance" type="Object"/>
      <property name="axisWidth" scope="instance" type="Object"/>
      <property name="spiderWidth" scope="instance" type="Object"/>
      <property name="seriesWidth" scope="instance" type="Object"/>
      <property name="spiderOrigin" scope="instance" type="Object"/>
      <property name="markerSize" scope="instance" type="Object"/>
      <property name="spiderType" scope="instance" type="Object"/>
      <property name="animationType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Stacked" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Stacked
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Stacked"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Stacked.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedAreas" superclass="dojox.charting.plot2d.Stacked">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Stacked" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.StackedAreas.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedBars" superclass="dojox.charting.plot2d.Bars">
    <methods>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.StackedBars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.StackedBars"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Bars" scope="instance"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedBars.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedColumns" superclass="dojox.charting.plot2d.Columns">
    <methods>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.StackedColumns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.StackedColumns"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Columns" scope="instance"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedColumns.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedLines" superclass="dojox.charting.plot2d.Stacked">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Stacked" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.StackedLines.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d._PlotEvents">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="plotEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="raiseEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
        <return-description>Array
	The handle as returned from dojo.connect (see dojo.connect).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="events" scope="instance">
        <return-description>Boolean
	A flag indicating that there are handlers attached.</return-description>
      </method>
      <method name="resetEvents" scope="instance"/>
      <method name="_connectSingleEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="eventName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectEvents" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_reconnectEvents" scope="instance">
        <parameters>
          <parameter name="seriesName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fireEvent" scope="instance">
        <parameters>
          <parameter name="seriesName" type="String:" usage="required"/>
          <parameter name="eventName" type="String:" usage="required"/>
          <parameter name="index" type="Number:" usage="required"/>
          <parameter name="eventObject" type="Object:" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="_shapeEvents" scope="instance-prototype" type="Array"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.common">
    <methods>
      <method name="makeStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentColor" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="collectSimpleStats" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculateBarSize" scope="instance">
        <parameters>
          <parameter name="availableSize" type="Number" usage="required"/>
          <parameter name="opt" type="Object" usage="required"/>
          <parameter name="clusterSize" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="collectStackedStats" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="curve" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
          <parameter name="tension" type="Number|String" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Number" usage="required"/>
          <parameter name="fixed" type="Boolean" usage="required"/>
          <parameter name="precision" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot2d.common.defaultStats">
    <properties>
      <property name="vmin" scope="instance" type="Object"/>
      <property name="vmax" scope="instance" type="Object"/>
      <property name="hmin" scope="instance" type="Object"/>
      <property name="hmax" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d"/>
  <class type="dojox.charting.plot3d.Bars" superclass="dojox.charting.plot3d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot3d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="depth" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="data" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Bars.material">
    <properties>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="data" scope="instance" type="Array"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Cylinders" superclass="dojox.charting.plot3d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot3d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="depth" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="data" scope="instance" type="Array"/>
      <property name="outline" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Cylinders.material">
    <properties>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.scaler.common">
    <methods>
      <method name="findString" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
          <parameter name="text" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getNumericLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Number" usage="required"/>
          <parameter name="precision" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.scaler.linear">
    <methods>
      <method name="buildScaler" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="buildTicks" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransformerFromModel" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="getTransformerFromPlot" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.scaler.primitive">
    <methods>
      <method name="buildScaler" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildTicks" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransformerFromModel" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="getTransformerFromPlot" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes">
    <properties>
      <property name="Adobebricks" scope="instance" type="Object"/>
      <property name="Algae" scope="instance" type="Object"/>
      <property name="Bahamation" scope="instance" type="Object"/>
      <property name="BlueDusk" scope="instance" type="Object"/>
      <property name="CubanShirts" scope="instance" type="Object"/>
      <property name="Desert" scope="instance" type="Object"/>
      <property name="Distinctive" scope="instance" type="Object"/>
      <property name="Dollar" scope="instance" type="Object"/>
      <property name="Grasshopper" scope="instance" type="Object"/>
      <property name="Grasslands" scope="instance" type="Object"/>
      <property name="GreySkies" scope="instance" type="Object"/>
      <property name="Harmony" scope="instance" type="Object"/>
      <property name="IndigoNation" scope="instance" type="Object"/>
      <property name="Ireland" scope="instance" type="Object"/>
      <property name="MiamiNice" scope="instance" type="Object"/>
      <property name="Midwest" scope="instance" type="Object"/>
      <property name="Minty" scope="instance" type="Object"/>
      <property name="PrimaryColors" scope="instance" type="Object"/>
      <property name="PurpleRain" scope="instance" type="Object"/>
      <property name="RoyalPurples" scope="instance" type="Object"/>
      <property name="SageToLime" scope="instance" type="Object"/>
      <property name="Shrooms" scope="instance" type="Object"/>
      <property name="Tufte" scope="instance" type="Object"/>
      <property name="WatersEdge" scope="instance" type="Object"/>
      <property name="Wetland" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.Charged">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Chris">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Claro">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Electric">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Julie">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.PlotKit"/>
  <class type="dojox.charting.themes.PlotKit.base">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.PlotKit.blue.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.blue.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.blue">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.cyan.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.cyan.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.cyan">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.green.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.green.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.green">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.orange.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.orange.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.orange">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.purple.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.purple.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.purple">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.red.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.red.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.red">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.Renkoo">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.gradientGenerator">
    <methods>
      <method name="generateGradientByIntensity" scope="instance">
        <parameters>
          <parameter name="color" type="dojo.Color:" usage="required"/>
          <parameter name="intensityMap" type="Array:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="generateFills" scope="instance">
        <parameters>
          <parameter name="colors" type="Array:" usage="required"/>
          <parameter name="fillPattern" type="Object:" usage="required"/>
          <parameter name="lumFrom" type="Number:" usage="required"/>
          <parameter name="lumTo" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="updateFills" scope="instance">
        <parameters>
          <parameter name="themes" type="Array:" usage="required"/>
          <parameter name="fillPattern" type="Object:" usage="required"/>
          <parameter name="lumFrom" type="Number:" usage="required"/>
          <parameter name="lumTo" type="Number:" usage="required"/>
        </parameters>
      </method>
      <method name="generateMiniTheme" scope="instance">
        <parameters>
          <parameter name="colors" type="Array:" usage="required"/>
          <parameter name="fillPattern" type="Object:" usage="required"/>
          <parameter name="lumFrom" type="Number:" usage="required"/>
          <parameter name="lumTo" type="Number:" usage="required"/>
          <parameter name="lumStroke" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.ThreeD.series"/>
  <class type="dojox.charting.themes.ThreeD.series.shadow">
    <properties>
      <property name="dx" scope="instance" type="Number"/>
      <property name="dy" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.ThreeD">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Tom">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.widget">
    <properties>
      <property name="Chart2D" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Chart" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="resize" scope="instance">
        <description>Resize the domNode and the widget surface to the dimensions of a box of the following form:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	If no box is provided, resize the surface to the marginBox of the domNode.</description>
        <parameters>
          <parameter name="box" type="If" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="theme" scope="instance" type="Object"/>
      <property name="margins" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
      <property name="actions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Legend" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeIcon" scope="instance">
        <parameters>
          <parameter name="div" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="chartRef" scope="instance" type="String"/>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="swatchSize" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="legendNode" scope="instance" type="Object"/>
      <property name="legendBody" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="_surfaces" scope="instance" type="Array"/>
      <property name="_tr" scope="instance" type="Object"/>
      <property name="_inrow" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Legend.series.0.chart.stack">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.SelectableLegend" superclass="dojox.charting.widget.Legend">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyEvents" scope="instance"/>
      <method name="_toggle" scope="instance">
        <parameters>
          <parameter name="shapes" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="isOff" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="seriesName" type="Object" usage="required"/>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlight" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="iconShape" type="Object" usage="required"/>
          <parameter name="shapes" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="isOff" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="seriesName" type="Object" usage="required"/>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAnim" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getTransitionFill" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFilledShape" scope="instance">
        <parameters>
          <parameter name="shapes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isPie" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.widget.Legend" scope="instance"/>
    </mixins>
    <properties>
      <property name="outline" scope="instance" type="bool"/>
      <property name="transitionFill" scope="instance" type="Object"/>
      <property name="transitionStroke" scope="instance" type="Object"/>
      <property name="legends" scope="instance" type="Array"/>
      <property name="legendAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget._FocusManager">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="legend" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHrizontalLength" scope="instance"/>
      <method name="_onKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToFocus" scope="instance"/>
    </methods>
    <properties>
      <property name="index" scope="instance" type="Number"/>
      <property name="horizontalLength" scope="instance" type="Object"/>
      <property name="firstLabel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget._FocusManager.legend">
    <properties>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="active" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.charting.widget._FocusManager.legend.legends">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Sparkline" superclass="dojox.charting.widget.Chart2D">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.widget.Chart2D" scope="instance"/>
    </mixins>
    <properties>
      <property name="theme" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="String"/>
      <property name="valueFn" scope="instance" type="String"/>
      <property name="store" scope="instance" type="String"/>
      <property name="field" scope="instance" type="String"/>
      <property name="query" scope="instance" type="String"/>
      <property name="queryOptions" scope="instance" type="String"/>
      <property name="start" scope="instance" type="String"/>
      <property name="count" scope="instance" type="String"/>
      <property name="sort" scope="instance" type="String"/>
      <property name="data" scope="instance" type="String"/>
      <property name="name" scope="instance" type="String"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Sparkline.margins">
    <properties>
      <property name="l" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.collections">
    <properties>
      <property name="Set" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.ArrayList">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="a" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.ArrayList"/>
        </return-types>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="indexOf" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="reverse" scope="instance"/>
      <method name="sort" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance"/>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="delim" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.collections.BinaryTree">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance"/>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance"/>
      <method name="search" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="order" type="Object" usage="required"/>
          <parameter name="sep" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Number"/>
      <property name="root" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.BinaryTree.TraversalMethods">
    <properties>
      <property name="Preorder" scope="instance" type="Number"/>
      <property name="Inorder" scope="instance" type="Number"/>
      <property name="Postorder" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.collections.Dictionary">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Dictionary"/>
        </return-types>
      </method>
      <method name="contains" scope="instance"/>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeyList" scope="instance"/>
      <method name="getValueList" scope="instance"/>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.collections.Queue">
    <methods>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Queue"/>
        </return-types>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="dequeue" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="enqueue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="peek" scope="instance"/>
      <method name="toArray" scope="instance"/>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.SortedList">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.SortedList"/>
        </return-types>
      </method>
      <method name="contains" scope="instance"/>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="getKey" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getKeyList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getValueList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="indexOfKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="indexOfValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.Stack">
    <methods>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance"/>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="peek" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="pop" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="push" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.DictionaryEntry">
    <methods>
      <method name="valueOf" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="key" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.Iterator">
    <methods>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <properties>
      <property name="element" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.DictionaryIterator">
    <methods>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <properties>
      <property name="element" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color">
    <methods>
      <method name="fromXYZ" scope="instance">
        <parameters>
          <parameter name="xyz" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="fromCmy" scope="instance">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromCmyk" scope="instance">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
          <parameter name="black" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsl" scope="instance">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="luminosity" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsv" scope="instance">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="value" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="Colorspace" scope="instance" type="Object"/>
      <property name="blend" scope="instance" type="Object"/>
      <property name="fromRgb" scope="instance" type="Object"/>
      <property name="fromHex" scope="instance" type="Object"/>
      <property name="fromArray" scope="instance" type="Object"/>
      <property name="fromString" scope="instance" type="Object"/>
      <property name="greyscale" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color.Color">
    <methods>
      <method name="toXYZ" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmy" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmyk" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsl" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsv" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.math">
    <methods>
      <method name="toRadians" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="toDegrees" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="degreesToRadians" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="radiansToDegrees" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_gamma" scope="instance">
        <parameters>
          <parameter name="z" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="normal integer quick return"/>
          <return-type type="undefined at nonpositive integers since sin() below will return 0"/>
          <return-type type="popular gamma(1/2)"/>
          <return-type type="reflection"/>
        </return-types>
      </method>
      <method name="factorial" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="permutations" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="k" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="combinations" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="r" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bernstein" scope="instance">
        <parameters>
          <parameter name="t" type="Number" usage="required"/>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="i" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="gaussian" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="range" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="optional"/>
          <parameter name="step" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="distance" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="midpoint" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="round" scope="instance">
        <description>Rounds to the nearest value with the given number of decimal places, away from zero if equal,
	similar to Number.toFixed().  Rounding can be done by fractional increments also.
	Makes minor adjustments to accommodate for precision errors due to binary floating point representation
	of Javascript Numbers.  See http://speleotrove.com/decimal/decifaq.html for more information.
	Because of this adjustment, the rounding may not be mathematically correct for full precision
	floating point values.  The calculations assume 14 significant figures, so the accuracy will
	be limited to a certain number of decimal places preserved will vary with the magnitude of
	the input.  This is not a substitute for decimal arithmetic.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="places" type="Number" usage="optional"/>
          <parameter name="increment" type="Number" usage="optional"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="BigInteger-ext" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color.Palette">
    <description>A Palette is a representation of a set of colors.  While the standard
	number of colors contained in a palette is 5, it can really handle any
	number of colors.
	A palette is useful for the ability to transform all the colors in it
	using a simple object-based approach.  In addition, you can generate
	palettes using dojox.color.Palette.generate; these generated palettes
	are based on the palette generators at http://kuler.adobe.com.</description>
    <methods>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="base" type="String|dojox.color.Color" usage="required"/>
          <parameter name="type" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="transform" scope="instance">
        <description>{palette}.transform is a simple way to uniformly transform
	all of the colors in a palette using any of 5 formulae:
	RGBA, HSL, HSV, CMYK or CMY.
	Once the forumula to be used is determined, you can pass any
	number of parameters based on the formula "d"[param]; for instance,
	{ use: "rgba", dr: 20, dg: -50 } will take all of the colors in
	palette, add 20 to the R value and subtract 50 from the G value.
	Unlike other types of transformations, transform does *not* alter
	the original palette but will instead return a new one.</description>
        <parameters>
          <parameter name="kwArgs" type="dojox.color.Palette.__transformArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="colors" scope="instance" type="dojox.color.Color[]"/>
    </properties>
  </class>
  <class type="dojox.color.Palette.generators">
    <methods>
      <method name="analogous" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__analogousArgs" usage="required"/>
        </parameters>
      </method>
      <method name="monochromatic" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="triadic" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="complementary" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="splitComplementary" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__splitComplementaryArgs" usage="required"/>
        </parameters>
      </method>
      <method name="compound" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="shades" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.color.Palette.__transformArgs">
    <methods/>
    <properties>
      <property name="use" scope="instance" type="String"/>
      <property name="dr" scope="instance" type="Number"/>
      <property name="dg" scope="instance" type="Number"/>
      <property name="db" scope="instance" type="Number"/>
      <property name="da" scope="instance" type="Number"/>
      <property name="dc" scope="instance" type="Number"/>
      <property name="dm" scope="instance" type="Number"/>
      <property name="dy" scope="instance" type="Number"/>
      <property name="dk" scope="instance" type="Number"/>
      <property name="dh" scope="instance" type="Number"/>
      <property name="ds" scope="instance" type="Number"/>
      <property name="dl" scope="instance" type="Number"/>
      <property name="dv" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.color.Palette.__generatorArgs">
    <methods/>
    <properties>
      <property name="base" scope="instance" type="dojo.Color"/>
    </properties>
  </class>
  <class type="dojox.color.Palette.__analogousArgs">
    <methods/>
    <properties>
      <property name="base" scope="instance" type="dojo.Color"/>
      <property name="high" scope="instance" type="Number"/>
      <property name="low" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.color.Palette.__splitComplementaryArgs">
    <methods/>
    <properties>
      <property name="base" scope="instance" type="dojo.Color"/>
      <property name="da" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.cometd">
    <properties>
      <property name="HttpChannels" scope="instance" type="Object"/>
      <property name="connectionTypes" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="ackEnabled" scope="instance" type="Object"/>
      <property name="ack" scope="instance" type="Object"/>
      <property name="longPollTransport" scope="instance" type="Object"/>
      <property name="timestamp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.RestChannels">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Keyword" usage="required"/>
        </parameters>
      </method>
      <method name="absoluteUrl" scope="instance">
        <parameters>
          <parameter name="baseUrl" type="Object" usage="required"/>
          <parameter name="relativeUrl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <description>Note that if there is no connection open, this is automatically called when you do a subscription,
	it is often not necessary to call this</description>
        <return-types>
          <return-type type="this can be called after dojo is unloaded, just do nothing in that case"/>
        </return-types>
      </method>
      <method name="_send" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="don't process the response, the response will be received in the main channels response"/>
        </return-types>
      </method>
      <method name="publish" scope="instance">
        <description>This does a simple POST operation to the provided URL,
	POST is the semantic equivalent of publishing a message within REST/Channels</description>
        <parameters>
          <parameter name="channel" type="Channel/resource" usage="required"/>
          <parameter name="data" type="data" usage="required"/>
        </parameters>
      </method>
      <method name="_processMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="indicate an error"/>
        </return-types>
      </method>
      <method name="onprogress" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="contentType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="receive" scope="instance">
        <parameters>
          <parameter name="message" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="disconnected" scope="instance"/>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
    </methods>
    <properties>
      <property name="acceptType" scope="instance" type="String"/>
      <property name="subscriptions" scope="instance" type="Object"/>
      <property name="subCallbacks" scope="instance" type="Object"/>
      <property name="autoReconnectTime" scope="instance" type="Number"/>
      <property name="reloadDataOnReconnect" scope="instance" type="Object"/>
      <property name="sendAsJson" scope="instance" type="bool"/>
      <property name="url" scope="instance" type="String"/>
      <property name="autoSubscribeRoot" scope="instance" type="String"/>
      <property name="started" scope="instance" type="bool"/>
      <property name="connectionId" scope="instance" type="Object"/>
      <property name="createdClientId" scope="instance" type="Object"/>
      <property name="lastIndex" scope="instance" type="Number"/>
      <property name="connected" scope="instance" type="bool"/>
      <property name="defaultInstance" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection">
    <methods>
      <method name="state" scope="instance"/>
      <method name="init" scope="instance">
        <description>Initialize the cometd implementation of the Bayeux protocol by
	sending a handshake message. The cometd state will be changed to CONNECTING
	until a handshake response is received and the first successful connect message
	has returned.
	The protocol state changes may be monitored
	by subscribing to the dojo topic "/prefix/meta" (typically "/cometd/meta") where
	events are published in the form
	{cometd:this,action:"handshake",successful:true,state:this.state()}</description>
        <parameters>
          <parameter name="root" type="String" usage="required"/>
          <parameter name="props" type="Object" usage="optional"/>
          <parameter name="bargs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <description>`dojox.cometd.subscribe()` handles all the hard work of telling
	the server that we want to be notified when events are
	published on a particular topic. `subscribe` accepts a function
	to handle messages and returns a `dojo.Deferred` object which
	has an extra property added to it which makes it suitable for
	passing to `dojox.cometd.unsubscribe()` as a "subscription
	handle" (much like the handle object that `dojo.connect()`
	produces and which `dojo.disconnect()` expects).
	Note that of a subscription is registered before a connection
	with the server is established, events sent before the
	connection is established will not be delivered to this client.
	The deferred object which `subscribe` returns will callback
	when the server successfuly acknolwedges receipt of our
	"subscribe" request.</description>
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="objOrFunc" type="Object" usage="required"/>
          <parameter name="funcName" type="String" usage="required"/>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="objOrFunc" type="Object" usage="optional"/>
          <parameter name="funcName" type="String" usage="optional"/>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>Disconnect from the server by sending a disconnect message</description>
      </method>
      <method name="subscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance">
        <parameters>
          <parameter name="childLocation" type="Object" usage="required"/>
          <parameter name="childDomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_backoff" scope="instance"/>
      <method name="_backon" scope="instance"/>
      <method name="_interval" scope="instance"/>
      <method name="_publishMeta" scope="instance">
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="successful" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finishInit" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extendIn" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extendOut" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sendMessage" scope="instance">
        <parameters>
          <parameter name="message" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="startBatch" scope="instance"/>
      <method name="endBatch" scope="instance"/>
      <method name="_onUnload" scope="instance"/>
      <method name="_connectTimeout" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance" type="Object"/>
      <property name="_isXD" scope="instance" type="bool"/>
      <property name="_props" scope="instance" type="Object"/>
      <property name="_messageQ" scope="instance" type="Array"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_status" scope="instance" type="String"/>
      <property name="batch" scope="instance" type="Number"/>
      <property name="_deferredSubscribes" scope="instance" type="Object"/>
      <property name="_handshook" scope="instance" type="Object"/>
      <property name="_backoffInterval" scope="instance" type="Number"/>
      <property name="handshakeReturn" scope="instance" type="Object"/>
      <property name="clientId" scope="instance" type="Object"/>
      <property name="lastMessage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection._advice">
    <properties>
      <property name="interval" scope="instance" type="Number"/>
      <property name="reconnect" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection.currentTransport">
    <properties>
      <property name="_cometd" scope="instance" type="Object"/>
      <property name="version" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd._ack">
    <methods>
      <method name="_in" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_out" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.cometd.callbackPollTransport">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="tunnelCollapse" scope="instance" type="Object"/>
      <property name="_connect" scope="instance" type="Object"/>
      <property name="deliver" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.callbackPollTransport._cometd">
    <properties>
      <property name="_polling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportFormEncoded">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_connect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_poll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportFormEncoded._cometd">
    <properties>
      <property name="_status" scope="instance" type="String"/>
      <property name="_polling" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportJsonEncoded">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_connect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_poll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportJsonEncoded._cometd">
    <properties>
      <property name="_status" scope="instance" type="String"/>
      <property name="_polling" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.cometd.timesync">
    <methods>
      <method name="getServerTime" scope="instance"/>
      <method name="getServerDate" scope="instance"/>
      <method name="setTimeout" scope="instance">
        <parameters>
          <parameter name="call" type="function" usage="required"/>
          <parameter name="atTimeOrDate" type="long|Date" usage="required"/>
        </parameters>
      </method>
      <method name="_in" scope="instance">
        <description>Look for ext:{timesync:{}} field and calculate offset if present.</description>
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_out" scope="instance">
        <description>Look for handshake and connect messages and add the ext:{timesync:{}} fields</description>
        <parameters>
          <parameter name="msg" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_window" scope="instance" type="Number"/>
      <property name="_lags" scope="instance" type="Array"/>
      <property name="_offsets" scope="instance" type="Array"/>
      <property name="lag" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="samples" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.css3.fx">
    <methods>
      <method name="puff" scope="instance">
        <description>Fades out an element and scales it to args.endScale</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="expand" scope="instance">
        <description>Scales an element to args.endScale</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shrink" scope="instance">
        <description>Shrinks an element, same as expand({ node: node, endScale: .01 });</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rotate" scope="instance">
        <description>Rotates an element from args.startAngle to args.endAngle</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flip" scope="instance">
        <description>Flips an element around his y axis. The default is a 360deg flip
	but it's possible to run a partial flip using args.whichAnims</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bounce" scope="instance">
        <description>Vertical bounce animation, the scaleX, scaleY deformation and the
	jump height (args.jumpHeight) can be specified</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.css3"/>
  <class type="dojox.data">
    <methods>
      <method name="_getStoreForItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="restListener" scope="instance">
        <description>Example:
		dojo.connect(window,"onMessage",null,function(event) {
			var data = dojo.fromJson(event.data);
			dojox.restListener(data);
		});</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="ASYNC_MODE" scope="instance" type="Number"/>
      <property name="SYNC_MODE" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemsFromLoadedData" scope="instance">
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
        <return-description>array
	Array of items in store item format.</return-description>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required"/>
          <parameter name="parentItem" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="_ccUrl" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance-prototype" type="Object"/>
      <property name="typeMap" scope="instance" type="Object"/>
      <property name="clearOnClose" scope="instance-prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="hierarchical" scope="instance-prototype" type="Object"/>
      <property name="_jsonFileUrl" scope="instance-prototype" type="Object"/>
      <property name="_jsonData" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance-prototype" type="Array"/>
      <property name="_itemsByIdentity" scope="instance-prototype" type="Object"/>
      <property name="_labelAttr" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_storeRefPropName" scope="instance" type="String"/>
      <property name="_itemNumPropName" scope="instance" type="String"/>
      <property name="_rootItemPropName" scope="instance" type="String"/>
      <property name="_reverseRefMap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore._features.dojo.data.api">
    <properties>
      <property name="Identity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore._datatypeMap">
    <properties>
      <property name="Date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrWriteStore" superclass="dojox.data.AndOrReadStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_assert" scope="instance">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getIdentifierAttribute" scope="instance"/>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="_removeArrayElement" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="almost" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required"/>
          <parameter name="parentItem" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_removeReferenceFromMap" scope="instance">
        <description>Method to remove an reference map entry for an item and attribute.  This will
	also perform cleanup on the map such that if there are no more references at all to
	the item, its reference object and entry are removed.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required"/>
          <parameter name="parentItem" type="item" usage="required"/>
          <parameter name="attribute" type="strin" usage="required"/>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="instance">
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_getValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_flatten" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="instance"/>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="something" type="The" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required"/>
          <parameter name="newValue" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="onNew" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.
	If the store is still dirty (unsaved changes), then an error will be thrown instead of
	clearing the internal state for reload from the url.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.AndOrReadStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="referenceIntegrity" scope="instance-prototype" type="bool"/>
      <property name="_saveInProgress" scope="instance-prototype" type="bool"/>
      <property name="_pending" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrWriteStore._features.dojo.data.api">
    <properties>
      <property name="Write" scope="instance" type="Object"/>
      <property name="Notification" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrWriteStore._datatypeMap.Date">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.AppStore" superclass="dojo.data.util.simpleFetch">
    <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFeed" scope="instance">
        <description>Sets the internal feed using a dojox.atom.io.model.Feed object.  Also adds
	a property to the entries to track that they belong to this store. It
	also parses stored requests (since we were waiting on a callback) and
	executes those as well.</description>
        <parameters>
          <parameter name="feed" type="dojox.atom.io.model.Feed" usage="required"/>
          <parameter name="data" type="unused" usage="required"/>
        </parameters>
      </method>
      <method name="_getAllItems" scope="instance">
        <description>Function to return all entries in the Feed as an array of items.</description>
        <return-description>Array of all entries in the feed.</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <description>This function tests whether the item passed in is indeed an item
	in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <description>This function tests whether the item passed in is indeed a valid
	'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-description>Returns a boolean indicating whether this is a valid attribute.</return-description>
      </method>
      <method name="_addUpdate" scope="instance">
        <description>Internal function to add an updated entry to our updates array</description>
        <parameters>
          <parameter name="update" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
          <parameter name="trim" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>Fetch items (Atom entries) that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required"/>
          <parameter name="fetchHandler" type="A" usage="required"/>
          <parameter name="errorHandler" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <description>Internal function for finishing a fetch request.  Needed since the feed
	might not have been loaded, so we finish the fetch in a callback.</description>
        <parameters>
          <parameter name="request" type="A" usage="required"/>
          <parameter name="fetchHandler" type="A" usage="required"/>
          <parameter name="errorHandler" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="almost" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance"/>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Whether"/>
      <property name="xmethod" scope="instance" type="boolean"/>
      <property name="_atomIO" scope="instance" type="Object"/>
      <property name="_feed" scope="instance" type="Object"/>
      <property name="_requests" scope="instance" type="Array"/>
      <property name="_processing" scope="instance" type="Object"/>
      <property name="_updates" scope="instance" type="Object"/>
      <property name="_adds" scope="instance" type="Object"/>
      <property name="_deletes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AtomReadStore" superclass="dojo.data.util.simpleFetch">
    <description>A data store for Atom XML based services or documents.	This store is still under development
	and doesn't support wildcard filtering yet.	Attribute filtering is limited to category or id.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>'item' must be an instance of an object created by the AtomReadStore instance.
	Accepted attributes are id, subtitle, title, summary, content, author, updated,
	published, category, link and alternate</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
      </method>
      <method name="getValues" scope="instance">
        <description>'item' must be an instance of an object created by the AtomReadStore instance.
	Accepted attributes are id, subtitle, title, summary, content, author, updated,
	published, category, link and alternate</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
        </parameters>
        <return-description>An array of values for the attribute value found, otherwise 'defaultValue'</return-description>
      </method>
      <method name="getAttributes" scope="instance">
        <description>'item' must be have been created by the AtomReadStore instance.
	tag names of child elements and XML attribute names of attributes
	specified to the element are returned along with special attribute
	names applicable to the element including "tagName", "childNodes"
	if the element has child elements, "text()" if the element has
	child text nodes, and attribute names in '_attributeMap' that match
	the tag name of the element.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-description>An array of attributes found</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
        </parameters>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeedValue" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValues" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="document" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHTML" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The"/>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="sendQuery" scope="instance-prototype" type="A"/>
      <property name="unescapeHTML" scope="instance-prototype" type="A"/>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="_feedMetaData" scope="instance" type="Object"/>
      <property name="_items" scope="instance" type="Object"/>
      <property name="rewriteUrl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CdfStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasProperty" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The store always loads all items, so if it's an item, then it's loaded.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetch" scope="instance">
        <description>Returns an Array of items based on the request arguments.
	If the store is in ASYNC mode, the items should be expected in an onComplete
	method passed in the request object. If store is in SYNC mode, the items will
	be return directly as well as within the onComplete method.
	note:
	The mode can be set on store initialization or during a fetch as one of the
	parameters.
	query: String
	The items in the store are treated as objects, but this is reading an XML
	document. Further, the actual querying of the items takes place in Tibco GI's
	jsx3.xml.Entity. Therefore, we are using their syntax which is xpath.
	Note:
	As conforming to a CDF document, most, if not all nodes are considered "records"
	and their tagNames are as such. The root node is named "data".
	examples:
	All items:
		store.fetch({query:"*"});
	Item with a jsxid attribute equal to "1" (note you could use byId for this)
		store.fetch({query:"//record[@jsxid='1']"});
	All items with any jsxid attribute:
		"//record[@jsxid='*']"
	The items with a jsxid of '1' or '4':
		"//record[@jsxid='4' or @jsxid='1']"
	All children within a "group" node (could be multiple group nodes):
	"//group/record"
	All children within a specific group node:
	"//group[@name='mySecondGroup']/record"
	Any record, anywhere in the document:
		"//record"
	Only the records beneath the root (data) node:
		"//data/record"
	See:
	http://www.tibco.com/devnet/resources/gi/3_7/api/html/jsx3/xml/Entity.html#method:selectNodes
	http://www.w3.org/TR/xpath
	http://msdn.microsoft.com/en-us/library/ms256086.aspx
	See dojo.data.Read.fetch():
	onBegin
	onComplete
	onItem
	onError
	scope
	start
	count
	sort</description>
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_loadCDF" scope="instance">
        <return-types>
          <return-type type="jsx3.xml.CDF"/>
          <return-type type="dojo.Deferred"/>
          <return-type type="Error"/>
        </return-types>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="cdfDoc" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="jsx3.xml.Entity"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="almost" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_makeDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeXmlString" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="byId" scope="instance-prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="identity" scope="instance-prototype" type="String"/>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="xmlStr" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="label" scope="instance-prototype" type="String"/>
      <property name="mode" scope="instance-prototype" type="Object"/>
      <property name="cdfDoc" scope="instance" type="Object"/>
      <property name="_modifiedItems" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.ClientFilter">
    <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
      </method>
      <method name="clearCache" scope="instance"/>
      <method name="updateResultSet" scope="instance">
        <description>This will attempt to update the provide result based on previous notification, adding new items
	from onNew calls, removing deleted items, and updating modified items, and properly removing
	and adding items as required by the query and sort parameters. This function will return:
	0: Indicates it could not successfully update the result set
	1: Indicates it could successfully handle all the notifications, but no changes were made to the result set
	2: Indicates it successfully handled all the notifications and result set has been updated.</description>
        <parameters>
          <parameter name="resultSet" type="Array" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="querySuperSet" scope="instance">
        <parameters>
          <parameter name="argsSuper" type="Dojo" usage="required"/>
          <parameter name="argsSub" type="Dojo" usage="required"/>
        </parameters>
      </method>
      <method name="cachingFetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="clientSidePaging" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeComparator" scope="instance">
        <parameters>
          <parameter name="sort" type="See" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="keep the order unchanged"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="cacheByDefault" scope="instance" type="bool"/>
      <property name="_fetchCache" scope="instance-prototype" type="Array"/>
      <property name="serverVersion" scope="instance" type="Number"/>
      <property name="onSet" scope="instance" type="Object"/>
      <property name="onNew" scope="instance" type="Object"/>
      <property name="onDelete" scope="instance" type="Object"/>
      <property name="_updates" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.data.CouchDBRestStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStores" scope="instance">
        <parameters>
          <parameter name="couchServerUrl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.CouchDBRestStore.service">
    <properties>
      <property name="servicePath" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CssClassStore" superclass="dojox.data.CssRuleStore">
    <description>The CssClassStore allows users to get information about active Css classes in the page running the CssClassStore.
	It can also filter out classes from specific stylesheets.  The attributes it exposes on classes are as follows:
	class:		The classname, including the '.'.
	classSans:	The classname without the '.'.</description>
    <methods>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
          <parameter name="styleSheet" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="instance"/>
      <method name="_handleFetchByIdentityReturn" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="request" type="request" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.CssRuleStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_labelAttribute" scope="instance" type="String"/>
      <property name="_idAttribute" scope="instance" type="String"/>
      <property name="_cName" scope="instance" type="String"/>
      <property name="_pending" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.data.CssRuleStore">
    <description>The CssRuleStore allows users to get information about active CSS rules in the page running the CssRuleStore.
	It can also filter out rules from specific stylesheets.  The attributes it exposes on rules are as follows:
	selector:				The selector text.
	classes:				An array of classes present in this selector.
	rule:					The actual DOM Rule object.
	style:					The actual DOM CSSStyleDeclaration object.
	cssText:				The cssText string provided on the rule object.
	styleSheet:				The originating DOM Stylesheet object.
	parentStyleSheet: 		The parent stylesheet to the sheet this rule originates from.
	parentStyleSheetHref: 	The href of the parent stylesheet.
	AND every style attribute denoted as style.*, such as style.textAlign or style.backgroundColor</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setContext" scope="instance">
        <parameters>
          <parameter name="context" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
          <parameter name="styleSheet" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="instance"/>
      <method name="_handleFetchReturn" scope="instance">
        <parameters>
          <parameter name="request" type="Request" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="_labelAttribute" scope="instance" type="String"/>
      <property name="_cache" scope="instance-prototype" type="Object"/>
      <property name="_browserMap" scope="instance" type="Object"/>
      <property name="_cName" scope="instance" type="String"/>
      <property name="context" scope="instance" type="Object"/>
      <property name="_pending" scope="instance" type="Array"/>
      <property name="_allItems" scope="instance-prototype" type="Object"/>
      <property name="_waiting" scope="instance" type="Array"/>
      <property name="gatherHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CsvStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_getIndex" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The CsvStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="_splitLines" scope="instance">
        <parameters>
          <parameter name="csvContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processData" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_createItemFromIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="string"/>
      <property name="label" scope="instance-prototype" type="string"/>
      <property name="identifier" scope="instance-prototype" type="string"/>
      <property name="separator" scope="instance-prototype" type="string"/>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_csvData" scope="instance-prototype" type="Object"/>
      <property name="_getArrayOfArraysFromCsvFileContents" scope="instance" type="Object"/>
      <property name="_attributes" scope="instance-prototype" type="Array"/>
      <property name="_dataArray" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_attributeIndexes" scope="instance" type="Object"/>
      <property name="_storeProp" scope="instance" type="String"/>
      <property name="_idProp" scope="instance" type="String"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_idMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FileStore">
    <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResult" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemArray" scope="instance">
        <parameters>
          <parameter name="itemArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The"/>
      <property name="_storeRef" scope="instance" type="string"/>
      <property name="label" scope="instance-prototype" type="The"/>
      <property name="_identifier" scope="instance" type="string"/>
      <property name="_attributes" scope="instance" type="string"/>
      <property name="pathSeparator" scope="instance" type="string"/>
      <property name="options" scope="instance-prototype" type="array"/>
      <property name="failOk" scope="instance" type="boolean"/>
      <property name="urlPreventCache" scope="instance-prototype" type="string"/>
      <property name="pathAsQueryParam" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrRestStore" superclass="dojox.data.FlickrStore">
    <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Function" usage="required"/>
          <parameter name="errorHandler" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_processFlickrData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="cacheKey" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_checkPrevRanges" scope="instance">
        <parameters>
          <parameter name="primaryKey" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.FlickrStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_id" scope="instance-prototype" type="Integer"/>
      <property name="_requestCount" scope="instance" type="Integer"/>
      <property name="_flickrRestUrl" scope="instance" type="String"/>
      <property name="_apikey" scope="instance-prototype" type="String"/>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="_cache" scope="instance-prototype" type="Array"/>
      <property name="_prevRequests" scope="instance-prototype" type="Object"/>
      <property name="_handlers" scope="instance-prototype" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="_prevRequestRanges" scope="instance" type="Array"/>
      <property name="_maxPhotosPerUser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrRestStore._sortAttributes">
    <properties>
      <property name="date-posted" scope="instance" type="Object"/>
      <property name="date-taken" scope="instance" type="Object"/>
      <property name="interestingness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrStore" superclass="dojo.data.util.simpleFetch">
    <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required"/>
          <parameter name="fetchHandler" type="A" usage="required"/>
          <parameter name="errorHandler" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_processFlickrData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped)
	characters (&lt;,&gt;,&amp;, ", etc,).</return-description>
      </method>
    </methods>
    <properties>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="label" scope="instance-prototype" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Object"/>
      <property name="urlRegistry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleFeedStore" superclass="dojox.data.GoogleSearchStore">
    <methods>
      <method name="getFeedValue" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValues" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_googleUrl" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_feedMetaData" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleFeedStore._queryAttrs">
    <properties>
      <property name="url" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleSearchStore">
    <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_format" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="base implementation does not format any items"/>
        </return-types>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_getSort" scope="instance"/>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_id" scope="instance-prototype" type="Integer"/>
      <property name="_requestCount" scope="instance" type="Integer"/>
      <property name="_googleUrl" scope="instance" type="String"/>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="label" scope="instance-prototype" type="String"/>
      <property name="_type" scope="instance" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean"/>
      <property name="_key" scope="instance" type="Object"/>
      <property name="_lang" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleSearchStore._aggregatedAttributes">
    <properties>
      <property name="estimatedResultCount" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleSearchStore._queryAttrs">
    <properties>
      <property name="text" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleWebSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.GoogleBlogSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore._aggregatedAttributes">
    <properties>
      <property name="viewport" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore._queryAttrs">
    <properties>
      <property name="text" scope="instance" type="String"/>
      <property name="centerLatLong" scope="instance" type="String"/>
      <property name="searchSpan" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleVideoSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleNewsSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleBookSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleImageSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.HtmlStore" superclass="dojo.data.util.simpleFetch">
    <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	The HTML table or list should be of the following form:
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	-or-
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	-or-
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	The HTML table or list should be of the following form:
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	-or-
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	-or-
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_indexItems" scope="instance"/>
      <method name="_getHeadings" scope="instance"/>
      <method name="_getAllItems" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If '_fetchUrl' is specified, it is used to load an XML document
	with a query string.
	Otherwise and if 'url' is specified, the XML document is
	loaded and list XML elements that match to a query (set of element
	names and their text attribute values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If '_rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required"/>
          <parameter name="fetchHandler" type="A" usage="required"/>
          <parameter name="errorHandler" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The"/>
      <property name="dataId" scope="instance-prototype" type="The"/>
      <property name="trimWhitespace" scope="instance-prototype" type="Trim"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean"/>
      <property name="fetchOnCreate" scope="instance-prototype" type="boolean"/>
      <property name="_rootNode" scope="instance" type="Object"/>
      <property name="_headings" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.data.HtmlTableStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHeadings" scope="instance"/>
      <method name="_getAllItems" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If '_fetchUrl' is specified, it is used to load an XML document
	with a query string.
	Otherwise and if 'url' is specified, the XML document is
	loaded and list XML elements that match to a query (set of element
	names and their text attribute values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If '_rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required"/>
          <parameter name="fetchHandler" type="A" usage="required"/>
          <parameter name="errorHandler" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="string"/>
      <property name="tableId" scope="instance-prototype" type="string"/>
      <property name="_headings" scope="instance" type="Array"/>
      <property name="_rootNode" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.ItemExplorer" superclass="dijit.Tree">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshItem" scope="instance"/>
      <method name="_createEditDialog" scope="instance">
        <return-types>
          <return-type type="isFocused"/>
          <return-type type="Object"/>
          <return-type type="this.store.getItemByIdentity(this._editDialog.attr(&quot;value&quot;)._reference);"/>
        </return-types>
      </method>
      <method name="_enableFields" scope="instance">
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateItem" scope="instance">
        <parameters>
          <parameter name="vals" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_editProperty" scope="instance"/>
      <method name="_destroyProperty" scope="instance"/>
      <method name="_addProperty" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Tree" scope="instance"/>
    </mixins>
    <properties>
      <property name="useSelect" scope="instance" type="bool"/>
      <property name="refSelectSearchAttr" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_modelNodeIdMap" scope="instance-prototype" type="Object"/>
      <property name="_modelNodePropMap" scope="instance-prototype" type="Object"/>
      <property name="_editDialog" scope="instance" type="Object"/>
      <property name="model" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.ItemExplorer.rootModelNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonQueryRestStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.util.JsonQuery.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
      <mixin type="dojox.data.util.JsonQuery" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.JsonRestStore" superclass="dojox.data.ServiceStore">
    <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
        <parameters>
          <parameter name="options" type="Keyword" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="data" type="object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="anyStore" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="don't change anything, and deal with the stupid post-commit lint complaints"/>
        </return-types>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="instance"/>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onNew" scope="instance"/>
      <method name="onDelete" scope="instance"/>
      <method name="getFeatures" scope="instance"/>
      <method name="getParent" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_constructor" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStore" scope="instance">
        <parameters>
          <parameter name="options" type="See" usage="required"/>
          <parameter name="Class" type="Constructor" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.ServiceStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="loadReferencedSchema" scope="instance" type="Object"/>
      <property name="idAsRef" scope="instance" type="bool"/>
      <property name="referenceIntegrity" scope="instance" type="Object"/>
      <property name="target" scope="instance" type="String"/>
      <property name="allowNoTrailingSlash" scope="instance" type="bool"/>
      <property name="serverVersion" scope="instance" type="Object"/>
      <property name="idAttribute" scope="instance" type="String"/>
      <property name="_index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonRestStore.service">
    <properties>
      <property name="_schema" scope="instance" type="Object"/>
      <property name="_store" scope="instance" type="Object"/>
      <property name="idAsRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonRestStore.schema">
    <properties>
      <property name="_idAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.json.ref">
    <methods>
      <method name="fromJson" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_addProp" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_useRefs" scope="instance" type="bool"/>
      <property name="serializeFunctions" scope="instance" type="bool"/>
      <property name="refAttribute" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.KeyValueStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The KeyValueStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_processData" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="instance">
        <parameters>
          <parameter name="something" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_finishFetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_keyValueString" scope="instance-prototype" type="Object"/>
      <property name="_keyValueVar" scope="instance-prototype" type="Object"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance" type="Array"/>
      <property name="_loadFinished" scope="instance" type="Object"/>
      <property name="_keyAttribute" scope="instance" type="String"/>
      <property name="_valueAttribute" scope="instance" type="String"/>
      <property name="_storeProp" scope="instance" type="String"/>
      <property name="_features" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.OpenSearchStore" superclass="dojo.data.util.simpleFetch">
    <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createSearchUrl" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required"/>
          <parameter name="fetchHandler" type="A" usage="required"/>
          <parameter name="errorHandler" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDxml" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemxml" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDatom" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItematom" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDrss" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemrss" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDfeed" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemfeed" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getNodeXml" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="skipFirst" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOsdd" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="itemPath" scope="instance-prototype" type="String"/>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="iframeElement" scope="instance" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean"/>
      <property name="ATOM_CONTENT_TYPE" scope="instance" type="Number"/>
      <property name="ATOM_CONTENT_TYPE_STRING" scope="instance" type="String"/>
      <property name="RSS_CONTENT_TYPE" scope="instance" type="Number"/>
      <property name="RSS_CONTENT_TYPE_STRING" scope="instance" type="String"/>
      <property name="XML_CONTENT_TYPE" scope="instance" type="Number"/>
      <property name="XML_CONTENT_TYPE_STRING" scope="instance" type="String"/>
      <property name="contentType" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.OpenSearchStore.urlElement">
    <properties>
      <property name="attributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.OpmlStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_removeChildNodesThatAreNotElementNodes" scope="instance">
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="recursive" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_processRawXmlTree" scope="instance">
        <parameters>
          <parameter name="rawXmlTree" type="xmlDoc" usage="required"/>
        </parameters>
      </method>
      <method name="_checkChildNodes" scope="instance">
        <description>Internal function to recurse over all child nodes from the store and add them
	As non-toplevel items</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="regexp" type="RegExp" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <description>Four things are verified to ensure that "something" is an item:
	something can not be null, the nodeType must be an XML Element,
	the tagName must be "outline", and the node must be a member of
	XML document for this datastore.</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The OpmlStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke the callback handlers.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="label" scope="instance-prototype" type="string"/>
      <property name="url" scope="instance-prototype" type="string"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_xmlData" scope="instance-prototype" type="Object"/>
      <property name="_metadataNodes" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_opmlData" scope="instance-prototype" type="Object"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance" type="Array"/>
      <property name="_identityMap" scope="instance" type="Object"/>
      <property name="_identCount" scope="instance" type="Number"/>
      <property name="_idProp" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.PersevereStore" superclass="dojox.data.JsonQueryRestStore">
    <methods>
      <method name="getStores" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="optional"/>
          <parameter name="sync" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="addProxy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonQueryRestStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="useFullIdInQueries" scope="instance" type="Object"/>
      <property name="jsonQueryPagination" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.rpc">
    <methods>
      <method name="getTarget" scope="instance">
        <parameters>
          <parameter name="smd" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toOrdered" scope="instance">
        <parameters>
          <parameter name="parameters" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_sync" scope="instance" type="Object"/>
      <property name="JsonRPC" scope="instance" type="Object"/>
      <property name="ProxiedPath" scope="instance" type="Object"/>
      <property name="transportRegistry" scope="instance" type="Object"/>
      <property name="envelopeRegistry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.PicasaStore" superclass="dojo.data.util.simpleFetch">
    <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required"/>
          <parameter name="fetchHandler" type="A" usage="required"/>
          <parameter name="errorHandler" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_processPicasaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="instance">
        <description>Utility function to un-escape XML special characters in an HTML string.</description>
        <parameters>
          <parameter name="str" type="String." usage="required"/>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped) characters (&lt;,&gt;,&amp;, ", etc,).
	TODO: Check to see if theres already compatible escape() in dojo.string or dojo.html</return-description>
      </method>
    </methods>
    <properties>
      <property name="_picasaUrl" scope="instance" type="String"/>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="label" scope="instance-prototype" type="string"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean"/>
      <property name="maxResults" scope="instance-prototype" type="Define"/>
    </properties>
  </class>
  <class type="dojox.data.QueryReadStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_xhrFetchHandler" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_filterResponse" scope="instance">
        <parameters>
          <parameter name="data" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="requestMethod" scope="instance" type="String"/>
      <property name="_className" scope="instance" type="String"/>
      <property name="_items" scope="instance" type="Array"/>
      <property name="_lastServerQuery" scope="instance" type="Object"/>
      <property name="_numRows" scope="instance" type="Number"/>
      <property name="lastRequestHash" scope="instance" type="String"/>
      <property name="doClientPaging" scope="instance" type="bool"/>
      <property name="doClientSorting" scope="instance" type="bool"/>
      <property name="_itemsByIdentity" scope="instance" type="Object"/>
      <property name="_identifier" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_labelAttr" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.QueryReadStore._features.dojo.data.api">
    <properties>
      <property name="Read" scope="instance" type="Object"/>
      <property name="Identity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.RailsStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="rootAttribute" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.data.S3Store" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.ServiceStore">
    <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
        <parameters>
          <parameter name="options" type="Keyword" usage="required"/>
        </parameters>
      </method>
      <method name="getSchema" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="return the plain value since it was found;"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="property" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="service" scope="instance" type="Object"/>
      <property name="schema" scope="instance" type="Object"/>
      <property name="idAttribute" scope="instance-prototype" type="Object"/>
      <property name="labelAttribute" scope="instance" type="String"/>
      <property name="syncMode" scope="instance" type="bool"/>
      <property name="estimateCountFactor" scope="instance" type="Number"/>
      <property name="loadLazyValues" scope="instance" type="Object"/>
      <property name="_currentId" scope="instance" type="Number"/>
      <property name="byId" scope="instance" type="Object"/>
      <property name="_index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.SnapLogicStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchHandler" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_partHandler" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="part" type="String" usage="required"/>
          <parameter name="response" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="A"/>
      <property name="_parameters" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.SnapLogicStore.Parts">
    <properties>
      <property name="DATA" scope="instance" type="String"/>
      <property name="COUNT" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.StoreExplorer" superclass="dijit.layout.BorderContainer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="setItemName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_formatCell" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createNew" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.BorderContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="columnWidth" scope="instance" type="String"/>
      <property name="stringQueries" scope="instance" type="bool"/>
      <property name="showAllColumns" scope="instance" type="bool"/>
      <property name="tree" scope="instance" type="Object"/>
      <property name="gridOnFetchComplete" scope="instance" type="Object"/>
      <property name="queryOptions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.StoreExplorer.grid._pending_requests">
    <properties>
      <property name="0" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.data.StoreExplorer.grid">
    <methods>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.WikipediaStore" superclass="dojox.data.ServiceStore">
    <description>The WikipediaStore is a data store interface to Wikipedia, using the
	Wikipedia SMD spec from dojox.rpc. It currently is useful only for
	finding articles that contain some particular text or grabbing single
	articles by full name; no wildcards or other filtering are supported.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.ServiceStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="service" scope="instance" type="Object"/>
      <property name="idAttribute" scope="instance" type="String"/>
      <property name="labelAttribute" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.XmlStore" superclass="dojo.data.util.simpleFetch">
    <description>A data store for XML based services or documents</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", the tag name of the element is
	returned.
	If 'attribute' specifies "childNodes", the first element child is
	returned.
	If 'attribute' specifies "text()", the value of the first text
	child is returned.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value of the XML
	attribute is returned.
	Otherwise, the first child element of the tag name specified with
	'attribute' is returned.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
        <return-types>
          <return-type type="object"/>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", the tag name of the element is
	returned.
	If 'attribute' specifies "childNodes", child elements are returned.
	If 'attribute' specifies "text()", the values of child text nodes
	are returned.
	For generic attributes, if 'attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value of the XML
	attribute is returned.
	Otherwise, child elements of the tag name specified with
	'attribute' are returned.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
        </parameters>
        <return-description>An array of attribute values found, otherwise an empty array</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	tag names of child elements and XML attribute names of attributes
	specified to the element are returned along with special attribute
	names applicable to the element including "tagName", "childNodes"
	if the element has child elements, "text()" if the element has
	child text nodes, and attribute names in '_attributeMap' that match
	the tag name of the element.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-description>An array of attributes found</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
        </parameters>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If 'sendQuery' is true, an XML document is loaded from
	'url' with a query string.
	Otherwise, an XML document is loaded and list XML elements that
	match to a query (set of element names and their text attribute
	values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If 'rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required"/>
          <parameter name="fetchHandler" type="A" usage="required"/>
          <parameter name="errorHandler" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="instance">
        <description>This default implementation generates a query string in the form of
	"?name1=value1&amp;name2=value2..." off properties of 'query' object
	specified in 'request' and appends it to 'url', if 'sendQuery'
	is set to false.
	Otherwise, 'url' is returned as is.
	Sub-classes may override this method for the custom URL generation.</description>
        <parameters>
          <parameter name="request" type="A" usage="required"/>
        </parameters>
        <return-description>A fetch URL</return-description>
      </method>
      <method name="_getItems" scope="instance">
        <description>This default implementation walks through child elements of
	the document element to see if all properties of 'query' object
	match corresponding attributes of the element (item).
	If 'request' is not specified, all child elements are returned.
	Sub-classes may override this method for the custom search in
	an XML document.</description>
        <parameters>
          <parameter name="document" type="An" usage="required"/>
          <parameter name="request" type="A" usage="required"/>
        </parameters>
        <return-description>An array of items</return-description>
      </method>
      <method name="_flattenNodes" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <description>At least, 'keywordArgs' must contain "tagName" to be used for
	the new	element.
	Other attributes in 'keywordArgs' are set to the new element,
	including "text()", but excluding "childNodes".</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
        <return-description>An XML element</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", nothing is set and false is
	returned.
	If 'attribute' specifies "childNodes", the value (XML element) is
	added to the element.
	If 'attribute' specifies "text()", a text node is created with
	the value and set it to the element as a child.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value is set to the XML
	attribute.
	Otherwise, a text node is created with the value and set it to
	the first child element of the tag name specified with 'attribute'.
	If the child element does not exist, it is created.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="value" type="almost" usage="required"/>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", nothing is set and false is
	returned.
	If 'attribute' specifies "childNodes", the value (array of XML
	elements) is set to the element's childNodes.
	If 'attribute' specifies "text()", a text node is created with
	the values and set it to the element as a child.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the first value is set to
	the XML attribute.
	Otherwise, child elements of the tag name specified with
	'attribute' are replaced with new child elements and their
	child text nodes of values.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	'attribute' can be an XML attribute name of the element or one of
	special names described below.
	If 'attribute' specifies "tagName", nothing is removed and false is
	returned.
	If 'attribute' specifies "childNodes" or "text()", all child nodes
	are removed.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the XML attribute is removed.
	Otherwise, child elements of the tag name specified with
	'attribute' are removed.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required"/>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <description>'url' is used to save XML documents for new, modified and/or
	deleted XML elements.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <description>If 'item' is specified, true is returned if the item is new,
	modified or deleted.
	Otherwise, true is returned if there are any new, modified
	or deleted items.</description>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-description>True if an item or items are new, modified or deleted, otherwise
	false</return-description>
      </method>
      <method name="_saveItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPostUrl" scope="instance">
        <description>This default implementation just returns 'url'.
	Sub-classes may override this method for the custom URL.</description>
        <parameters>
          <parameter name="item" type="An" usage="required"/>
        </parameters>
        <return-description>A post URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPutUrl" scope="instance">
        <description>This default implementation just returns 'url'.
	Sub-classes may override this method for the custom URL.</description>
        <parameters>
          <parameter name="item" type="An" usage="required"/>
        </parameters>
        <return-description>A put URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getDeleteUrl" scope="instance">
        <description>This default implementation returns 'url' with 'keyAttribute'
	as a query string.
	Sub-classes may override this method for the custom URL based on
	changes (new, deleted, or modified).</description>
        <parameters>
          <parameter name="item" type="An" usage="required"/>
        </parameters>
        <return-description>A delete URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPostContent" scope="instance">
        <description>This default implementation generates an XML document for one
	(the first only) new or modified element.
	Sub-classes may override this method for the custom post content
	generation.</description>
        <parameters>
          <parameter name="item" type="An" usage="required"/>
        </parameters>
        <return-description>A post content</return-description>
        <return-types>
          <return-type type="XML string"/>
        </return-types>
      </method>
      <method name="_getPutContent" scope="instance">
        <description>This default implementation generates an XML document for one
	(the first only) new or modified element.
	Sub-classes may override this method for the custom put content
	generation.</description>
        <parameters>
          <parameter name="item" type="An" usage="required"/>
        </parameters>
        <return-description>A post content</return-description>
        <return-types>
          <return-type type="XML string"/>
        </return-types>
      </method>
      <method name="_getAttribute" scope="instance">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="_backupItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="new or already modified"/>
        </return-types>
      </method>
      <method name="_restoreItems" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forgetItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getDocument" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getRootElement" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMElement"/>
        </return-types>
      </method>
      <method name="_getXPath" scope="instance">
        <description>A function to compute the xpath of a node in a DOM document.  Used for
	Client side query handling and identity.</description>
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String."/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <description>For XmlStore, if sendQuery is false and no keyAttribute was set, then this function
	returns null, as xpath is used for the identity, which is not a public attribute of
	the item.  If sendQuery is true and keyAttribute is set, then this function
	returns an array of one attribute name: keyAttribute.   This means the server side
	implementation must apply a keyAttribute to a returned node that always allows
	it to be looked up again.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The"/>
      <property name="rootItem" scope="instance-prototype" type="A"/>
      <property name="keyAttribute" scope="instance-prototype" type="An"/>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="sendQuery" scope="instance-prototype" type="A"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Parameter"/>
      <property name="_newItems" scope="instance-prototype" type="Array"/>
      <property name="_deletedItems" scope="instance-prototype" type="Array"/>
      <property name="_modifiedItems" scope="instance-prototype" type="Array"/>
      <property name="_attributeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.XmlItem">
    <description>This class represents an item of 'XmlStore' holding an XML element.
	'element'
	element:
	An XML element</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="element" type="An" usage="required"/>
          <parameter name="store" type="The" usage="required"/>
          <parameter name="query" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <return-description>a value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="element" scope="instance" type="An"/>
      <property name="store" scope="instance" type="The"/>
      <property name="q" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.css">
    <methods>
      <method name="findStyleSheets" scope="instance">
        <parameters>
          <parameter name="sheets" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findStyleSheet" scope="instance">
        <parameters>
          <parameter name="sheet" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="IE stylesheet has imports[] containing @import'ed rules"/>
        </return-types>
      </method>
      <method name="determineContext" scope="instance">
        <parameters>
          <parameter name="initialStylesheets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.css.rules">
    <methods>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="Object" usage="required"/>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.dom">
    <methods>
      <method name="createDocument" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="optional"/>
          <parameter name="mimetype" type="string" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument."/>
        </return-types>
      </method>
      <method name="textContent" scope="instance">
        <description>Implementation of the DOM Level 3 attribute; scan node for text
	This function can also update the text of a node by replacing all child
	content of the node.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="text" type="string" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="replaceChildren" scope="instance">
        <description>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required"/>
          <parameter name="newChildren" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="removeChildren" scope="instance">
        <parameters>
          <parameter name="node" type="Element" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="innerXML" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
          <return-type type="Object"/>
          <return-type type="null"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.rpc.Rest">
    <methods>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="server error, let the error propagate"/>
        </return-types>
      </method>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="serializedContent" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.util"/>
  <class type="dojox.data.util.JsonQuery">
    <methods>
      <method name="_toJsonQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="jsonQueryPagination" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="instance"/>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="querySuperSet" scope="instance">
        <parameters>
          <parameter name="argsSuper" type="Object" usage="required"/>
          <parameter name="argsSub" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="useFullIdInQueries" scope="instance" type="bool"/>
      <property name="jsonQueryPagination" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.buddhist">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
        </parameters>
      </method>
      <method name="isLeapYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="date1" type="buddhist.Date" usage="required"/>
          <parameter name="date2" type="buddhist.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="FIXME"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.buddhist.Date" usage="required"/>
          <parameter name="interval" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.buddhist.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.buddhist.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.buddhist.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.buddhist.Date">
    <description>This fucntion initialize the date object values</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>This fucntion initialize the date object values</description>
      </method>
      <method name="getDate" scope="instance">
        <parameters>
          <parameter name="isNumber" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="getMonth" scope="instance"/>
      <method name="getFullYear" scope="instance"/>
      <method name="getHours" scope="instance"/>
      <method name="getMinutes" scope="instance"/>
      <method name="getSeconds" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="setDate" scope="instance">
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="instance">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
          <parameter name="month" type="number" usage="optional"/>
          <parameter name="date" type="number" usage="optional"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance"/>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="number" usage="required"/>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="fromGregorian" scope="instance">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="toGregorian" scope="instance">
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getDay" scope="instance">
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="valueOf" scope="instance"/>
    </methods>
    <properties>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Number"/>
      <property name="_year" scope="instance-prototype" type="Number"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date"/>
  <class type="dojox.date.buddhist.locale">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="addCustomFormats" scope="instance">
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getBuddhistBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="buddhist" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="hebrew.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.
	date1:
	hebrew.Date object
	date2:
	hebrew.Date object.  If not specified, the current hebrew.Date is used.</description>
        <parameters>
          <parameter name="dateheb1" type="hebrew.Date" usage="required"/>
          <parameter name="dateheb2" type="hebrew.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.hebrew.Date" usage="required"/>
          <parameter name="interval" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.hebrew.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.hebrew.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.hebrew.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew.Date">
    <description>A Date-like object which implements the Hebrew Calendar.  Because this object
	implements many of the same methods as the native JavaScript Date object, which
	implements the Gregorian calendar, it can often be used its place.  Note that
	this object does not extend Date or use its prototype.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="getDate" scope="instance">
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getDateLocalized" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getMonth" scope="instance">
        <description>the result is the index in the month array:
	0. Tishri
	1. Heshvan
	2. Kislev
	3. Tevet
	4. Shevat
	5. Adar I (leap years only)
	6. Adar
	7. Nisan
	8. Iyar
	9. Sivan
	10. Tammuz
	11.	Av
	12. Elul - 12
	For non leap years, for months after Shevat, the actual position of
	the month in the year (used for short format) is less than
	the "absolute" index by 1.</description>
      </method>
      <method name="getFullYear" scope="instance"/>
      <method name="getHours" scope="instance"/>
      <method name="getMinutes" scope="instance"/>
      <method name="getSeconds" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="setDate" scope="instance">
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="instance">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
          <parameter name="month" type="number" usage="optional"/>
          <parameter name="date" type="number" usage="optional"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance">
        <description>Sets the hour and optionally minutes, seconds, milliseconds also.</description>
      </method>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setDay" scope="instance"/>
      <method name="toString" scope="instance">
        <description>returns a string representation of the date in "dd, MM, yyyy HH:mm:ss" format (all numeric)
	For user presentation, use dojox.date.hebrew.locale.format which will present in the appropriate language
	and format.  toString() language- and culturally-specific conventions to keep this module free of
	dependencies on dojox.date.locale and dojo.cldr.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDaysInHebrewMonth" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_yearType" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_handleGetYearLength" scope="instance">
        <parameters>
          <parameter name="eyear" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_startOfYear" scope="instance">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="isLeapYear" scope="instance">
        <description>The Leap year contains additional month adar sheni
	return (year * 12 + 17) % 19 &gt;= 12;</description>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="fromGregorian" scope="instance">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_computeHebrewFields" scope="instance">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="toGregorian" scope="instance">
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="_floorDivide" scope="instance">
        <parameters>
          <parameter name="numerator" type="Object" usage="required"/>
          <parameter name="denominator" type="Object" usage="required"/>
          <parameter name="remainder" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDay" scope="instance"/>
      <method name="_getJulianDayFromGregorianDate" scope="instance">
        <parameters>
          <parameter name="gdate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="valueOf" scope="instance"/>
    </methods>
    <properties>
      <property name="_MONTH_LENGTH" scope="instance" type="Array"/>
      <property name="_MONTH_START" scope="instance" type="Array"/>
      <property name="_LEAP_MONTH_START" scope="instance" type="Array"/>
      <property name="_GREGORIAN_MONTH_COUNT" scope="instance" type="Array"/>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Number"/>
      <property name="_year" scope="instance-prototype" type="String"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.date.hebrew.locale">
    <methods>
      <method name="format" scope="instance">
        <description>Create a string from a hebrew.Date object using a known pattern.
	By default, this method formats both date and time from dateObject.
	Default formatting lengths is 'short'</description>
        <parameters>
          <parameter name="dateObject" type="hebrew.Date" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="hebrew.Date"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <description>The user may add custom localized formats where the bundle has properties following the
	same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	The pattern string should match the format used by the CLDR.
	See dojo.date.locale.format() for details.
	The resources must be loaded by dojo.requireLocalization() prior to use</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getHebrewBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="dojox.date.hebrew.Date" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew.numerals">
    <methods>
      <method name="getYearHebrewLetters" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseYearHebrewLetters" scope="instance">
        <parameters>
          <parameter name="year" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getDayHebrewLetters" scope="instance">
        <parameters>
          <parameter name="day" type="Object" usage="required"/>
          <parameter name="nogrsh" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseDayHebrewLetters" scope="instance">
        <parameters>
          <parameter name="day" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getMonthHebrewLetters" scope="instance">
        <parameters>
          <parameter name="month" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseMonthHebrewLetters" scope="instance">
        <parameters>
          <parameter name="monthStr" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.islamic">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="islamic.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.</description>
        <parameters>
          <parameter name="date1" type="islamic.Date" usage="required"/>
          <parameter name="date2" type="islamic.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.islamic.Date" usage="required"/>
          <parameter name="interval" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.islamic.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.islamic.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.islamic.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.islamic.Date">
    <description>This module is similar to the Date() object provided by JavaScript</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>This function initialize the date object values</description>
      </method>
      <method name="getDate" scope="instance"/>
      <method name="getMonth" scope="instance"/>
      <method name="getFullYear" scope="instance"/>
      <method name="getDay" scope="instance"/>
      <method name="getHours" scope="instance"/>
      <method name="getMinutes" scope="instance"/>
      <method name="getSeconds" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="setDate" scope="instance">
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="instance">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance"/>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance"/>
      <method name="toGregorian" scope="instance"/>
      <method name="fromGregorian" scope="instance">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="valueOf" scope="instance"/>
      <method name="_yearStart" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_monthStart" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
          <parameter name="month" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_civilLeapYear" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="getDaysInIslamicMonth" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.islamic.Date"/>
        </return-types>
      </method>
      <method name="_mod" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Object"/>
      <property name="_year" scope="instance-prototype" type="String"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="instance" type="Object"/>
      <property name="_GREGORIAN_EPOCH" scope="instance" type="Number"/>
      <property name="_ISLAMIC_EPOCH" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.date.islamic.locale">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="dateObject" type="islamic.Date" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="addCustomFormats" scope="instance">
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getIslamicBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="islamic" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="weekDays" scope="instance" type="Object"/>
      <property name="months" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.php.DateFormat">
    <methods>
      <method name="d" scope="instance"/>
      <method name="D" scope="instance"/>
      <method name="j" scope="instance"/>
      <method name="l" scope="instance"/>
      <method name="N" scope="instance"/>
      <method name="S" scope="instance"/>
      <method name="w" scope="instance"/>
      <method name="z" scope="instance"/>
      <method name="W" scope="instance"/>
      <method name="F" scope="instance"/>
      <method name="m" scope="instance"/>
      <method name="M" scope="instance"/>
      <method name="n" scope="instance"/>
      <method name="t" scope="instance"/>
      <method name="L" scope="instance"/>
      <method name="o" scope="instance"/>
      <method name="Y" scope="instance"/>
      <method name="y" scope="instance"/>
      <method name="a" scope="instance"/>
      <method name="b" scope="instance"/>
      <method name="B" scope="instance"/>
      <method name="g" scope="instance"/>
      <method name="G" scope="instance"/>
      <method name="h" scope="instance"/>
      <method name="H" scope="instance"/>
      <method name="i" scope="instance"/>
      <method name="s" scope="instance"/>
      <method name="e" scope="instance"/>
      <method name="I" scope="instance"/>
      <method name="O" scope="instance"/>
      <method name="P" scope="instance"/>
      <method name="T" scope="instance"/>
      <method name="Z" scope="instance"/>
      <method name="c" scope="instance"/>
      <method name="r" scope="instance"/>
      <method name="U" scope="instance"/>
    </methods>
    <properties>
      <property name="weekdays" scope="instance" type="Array"/>
      <property name="weekdays_3" scope="instance" type="Array"/>
      <property name="months" scope="instance" type="Array"/>
      <property name="months_3" scope="instance" type="Array"/>
      <property name="monthdays" scope="instance" type="Array"/>
      <property name="tokens" scope="instance" type="Object"/>
      <property name="replacements" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php.DateFormat.format">
    <methods/>
    <properties>
      <property name="date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php.DateFormat.constructor.prototype">
    <properties>
      <property name="regex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.posix">
    <methods>
      <method name="strftime" scope="instance">
        <description>see http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getStartOfWeek" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDay" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="setIsoWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="week" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getIsoWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getIsoWeeksInYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.relative">
    <methods>
      <method name="format" scope="instance">
        <description>Create a string from a Date object using the most significant information
	and a known localized pattern.  This method formats both the date and
	time from dateObject.  Formatting patterns are chosen appropriate to
	the locale.
	If the day portion of the date falls within the current date (or the
	relativeDate option, if present), then the time will be all that
	is displayed
	If the day portion of the date falls within the past week (or the
	week preceeding relativeDate, if present), then the display will show
	day of week and time.  This functionality can be turned off by setting
	weekCheck to false.
	If the year portion of the date falls within the current year (or the
	year portion of relativeDate, if present), then the display will show
	month and day.
	Otherwise, this function is equivalent to calling dojo.date.format with
	formatLength of "medium"</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="options" type="dojox.date.relative.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.relative.__FormatOptions">
    <methods/>
    <properties>
      <property name="locale" scope="instance" type="String"/>
      <property name="relativeDate" scope="instance" type="Date"/>
      <property name="weekCheck" scope="instance" type="boolean"/>
    </properties>
  </class>
  <class type="dojo._contentHandlers">
    <methods>
      <method name="olson-zoneinfo" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="auto" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.timezone">
    <description>mix-in to dojo.date to provide timezones based on
	the Olson timezone data.
	If you pass "timezone" as a parameter to your format options,
	then you get the date formatted (and offset) for that timezone</description>
    <methods>
      <method name="getTzInfo" scope="instance">
        <parameters>
          <parameter name="dt" type="Date" usage="required"/>
          <parameter name="tz" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="loadZoneData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAllZones" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dnd"/>
  <class type="dojox.dnd.BoundingBoxController">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="sources" type="Array:" usage="required"/>
          <parameter name="domNode" type="String|DomNode:" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="boundingBoxIsViable" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="_finishSelecting" scope="instance"/>
      <method name="_drawBoundingBox" scope="instance"/>
    </methods>
    <properties>
      <property name="_startX" scope="instance" type="Object"/>
      <property name="_startY" scope="instance" type="Object"/>
      <property name="_endX" scope="instance" type="Object"/>
      <property name="_endY" scope="instance" type="Object"/>
      <property name="domNode" scope="instance-prototype" type="String|DomNode:"/>
      <property name="events" scope="instance" type="Array"/>
      <property name="subscriptions" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dnd.Selector" superclass="dojo.dnd.Selector">
    <methods>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="selectNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode:" usage="required"/>
          <parameter name="add" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="deselectNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectByBBox" scope="instance">
        <parameters>
          <parameter name="left" type="Number:" usage="required"/>
          <parameter name="top" type="Number:" usage="required"/>
          <parameter name="right" type="Number:" usage="required"/>
          <parameter name="bottom" type="Number:" usage="required"/>
          <parameter name="add" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_isBoundedByBox" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode:" usage="required"/>
          <parameter name="left" type="Number:" usage="required"/>
          <parameter name="top" type="Number:" usage="required"/>
          <parameter name="right" type="Number:" usage="required"/>
          <parameter name="bottom" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="shift" scope="instance">
        <parameters>
          <parameter name="toNext" type="Boolean:" usage="required"/>
          <parameter name="add" type="Boolean:" usage="optional"/>
        </parameters>
      </method>
      <method name="_getNodeId" scope="instance">
        <parameters>
          <parameter name="nodeId" type="String:" usage="required"/>
          <parameter name="toNext" type="Boolean:" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="anchor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing">
    <methods>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRegistered" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.Drawing">
    <description>Drawing is similar to DojoX Sketch, but is designed to be more versatile
	extendable and customizable.
	Drawing currently only initiates from HTML although it's technically not
	a Dijit to keep the file size light. But if Dijit is available, Drawing
	will register itself with it and can be accessed dijit.byId('myDrawing')
	NOTES:
	Although not Drawing and Toolbar, all other objects are created with a custom
	declare. See dojox.drawing.util.oo
	The files are laid out as such:
	- Drawing
	The master class. More than one instance of a Drawing can be placed
	on a page at one time (although this has not yet been tested). Plugins
	can be added in markup.
	- Toolbar
	Like Drawing, Toolbar is a psudeo Dijit that does not need Dijit. It is
	optional. It can be oriented horizontal or vertical by placing one of
	those params in the class (at least one is required).  Plugins
	can be added in markup. A drawingId is required to point toolbar to
	the drawing.
	- defaults
	Contains the default styles and dimensions for Stencils. An individual
	Stencil can be changed by calling stencil.att({color obj}); To change
	all styles, a custom defaults file should be used.
	-Stencils
	Drawing uses a concept of 'Stencils' to avoid confusion between a
	Dojox Shape and a Drawing Shape. The classes in the 'stencils' package
	are display only, they are not used for actually drawing (see 'tools').
	This package contains _Base from which stencils inherit most of their
	methods.(Path and Image are display only and not found in Tools)
	- Tools
	The Tools package contains Stencils that are attached to mouse events
	and can be used for drawing. Items in this package can also be selected
	and modified.
	- Tools / Custom
	Holds tools that do not directly extend Stencil base classes and often
	have very custom code.
	- Library (not implemented)
	The Library package, which is not yet implemented, will be the place to
	hold stencils that have very specific data points that result in a picture.
	Flag-like-banners, fancy borders, or other complex shapes would go here.
	- Annotations
	Annotations 'decorate' and attach to other Stencils, such as a 'Label'
	that can show text on a stencil, or an 'Angle' that shows while dragging
	or modifying a Vector, or an Arrow head that is attached to the beginning
	or end of a line.
	- Manager
	Contains classes that control functionality of a Drawing.
	- Plugins
	Contains optional classes that are 'plugged into' a Drawing. There are two
	types: 'drawing' plugins that modify the canvas, and 'tools' which would
	show in the toolbar.
	- Util
	A collection of common tasks.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="HTMLNode" usage="required"/>
        </parameters>
      </method>
      <method name="_createCanvas" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="box" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="getShapeProps" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addPlugin" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initPlugins" scope="instance"/>
      <method name="onSurfaceReady" scope="instance"/>
      <method name="addUI" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addStencil" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAll" scope="instance"/>
      <method name="selectAll" scope="instance"/>
      <method name="toSelected" scope="instance">
        <parameters>
          <parameter name="func" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="exporter" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="importer" scope="instance">
        <parameters>
          <parameter name="objects" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="changeDefaults" scope="instance">
        <parameters>
          <parameter name="newStyle" type="Object" usage="required"/>
          <parameter name="value" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onRenderStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="instance">
        <parameters>
          <parameter name="abbr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="unSetTool" scope="instance"/>
    </methods>
    <properties>
      <property name="ready" scope="instance" type="Boolean"/>
      <property name="mode" scope="instance-prototype" type="String"/>
      <property name="width" scope="instance-prototype" type="Number"/>
      <property name="height" scope="instance-prototype" type="Number"/>
      <property name="canvas" scope="instance" type="Object"/>
      <property name="plugins" scope="instance-prototype" type="Array"/>
      <property name="undo" scope="instance" type="Object"/>
      <property name="anchors" scope="instance" type="Object"/>
      <property name="uiStencils" scope="instance" type="Object"/>
      <property name="stencils" scope="instance" type="Object"/>
      <property name="currentType" scope="instance" type="Array"/>
      <property name="currentStencil" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
      <property name="keys" scope="instance" type="Object"/>
      <property name="mouse" scope="instance" type="Object"/>
      <property name="tools" scope="instance" type="Object"/>
      <property name="stencilTypes" scope="instance" type="Object"/>
      <property name="stencilTypeMap" scope="instance" type="Object"/>
      <property name="srcRefNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="widgetId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.Drawing.defaults">
    <properties>
      <property name="clickable" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.drawing.annotations">
    <properties>
      <property name="Angle" scope="instance" type="Object"/>
      <property name="Arrow" scope="instance" type="Object"/>
      <property name="BoxShadow" scope="instance" type="Object"/>
      <property name="Label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults">
    <description>This object contains defaults for objects used in Drawing.
	To change one item's style, use item.attr();
	To change all these styles, create a copy of this file
	and point to it in the Drawing properties:
		&lt;div dojoType="dojox.drawing.Drawing" id="drawing" defaults="MyCustom.defaults"&gt;&lt;/div&gt;
	See:
	Drawing.changeDefaults
	Determines whether in draw or edit mode (whether stencils
	are clickable.  If clickMode is false, the original
	functionality of silently switching between select modes
	is enabled.  If clickMode is true, it allows powerpoint-
	like functionality.  Clickable is used by powerpoint to
	distinguish when things can be selected and when they can't</description>
    <methods>
      <method name="copy" scope="instance"/>
    </methods>
    <properties>
      <property name="clickMode" scope="instance" type="Object"/>
      <property name="clickable" scope="instance" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
      <property name="currentHit" scope="instance" type="Object"/>
      <property name="angleSnap" scope="instance" type="Number"/>
      <property name="zAxis" scope="instance" type="Boolean"/>
      <property name="zAxisEnabled" scope="instance" type="Boolean"/>
      <property name="zAngle" scope="instance" type="Number"/>
      <property name="renderHitLines" scope="instance" type="Boolean"/>
      <property name="renderHitLayer" scope="instance" type="If"/>
      <property name="labelSameColor" scope="instance" type="If"/>
      <property name="useSelectedStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.norm">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.selected">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.highlighted">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.disabled">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitNorm">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitNorm.color">
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitNorm.fill">
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitSelected">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitSelected.fill">
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitHighlighted">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitHighlighted.fill">
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.anchors">
    <properties>
      <property name="size" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="minSize" scope="instance" type="Number"/>
      <property name="marginZero" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.arrows">
    <properties>
      <property name="length" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.text">
    <properties>
      <property name="minWidth" scope="instance" type="Number"/>
      <property name="deleteEmptyCreate" scope="instance" type="Object"/>
      <property name="deleteEmptyModify" scope="instance" type="Object"/>
      <property name="pad" scope="instance" type="Number"/>
      <property name="size" scope="instance" type="String"/>
      <property name="family" scope="instance" type="String"/>
      <property name="weight" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.textDisabled">
    <properties>
      <property name="size" scope="instance" type="String"/>
      <property name="family" scope="instance" type="String"/>
      <property name="weight" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.textMode"/>
  <class type="dojox.drawing.defaults.textMode.create">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.textMode.edit">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button"/>
  <class type="dojox.drawing.defaults.button.norm">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.norm.fill">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.over">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.over.fill">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.down">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.down.fill">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.selected">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.selected.fill">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.icon"/>
  <class type="dojox.drawing.defaults.button.icon.norm">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.icon.selected">
    <properties>
      <property name="fill" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.library"/>
  <class type="dojox.drawing.library.greek">
    <description>These are used to convert between the character and
	the written version of greek letters.  Any character
	can be included here and it will automatically be added
	to the palette and converted by typesetter</description>
    <properties>
      <property name="alpha" scope="instance" type="Number"/>
      <property name="beta" scope="instance" type="Number"/>
      <property name="gamma" scope="instance" type="Number"/>
      <property name="delta" scope="instance" type="Number"/>
      <property name="epsilon" scope="instance" type="Number"/>
      <property name="zeta" scope="instance" type="Number"/>
      <property name="eta" scope="instance" type="Number"/>
      <property name="theta" scope="instance" type="Number"/>
      <property name="iota" scope="instance" type="Number"/>
      <property name="kappa" scope="instance" type="Number"/>
      <property name="lambda" scope="instance" type="Number"/>
      <property name="mu" scope="instance" type="Number"/>
      <property name="nu" scope="instance" type="Number"/>
      <property name="xi" scope="instance" type="Number"/>
      <property name="omicron" scope="instance" type="Number"/>
      <property name="pi" scope="instance" type="Number"/>
      <property name="rho" scope="instance" type="Number"/>
      <property name="sigmaf" scope="instance" type="Number"/>
      <property name="sigma" scope="instance" type="Number"/>
      <property name="tau" scope="instance" type="Number"/>
      <property name="upsilon" scope="instance" type="Number"/>
      <property name="phi" scope="instance" type="Number"/>
      <property name="chi" scope="instance" type="Number"/>
      <property name="psi" scope="instance" type="Number"/>
      <property name="omega" scope="instance" type="Number"/>
      <property name="thetasym" scope="instance" type="Number"/>
      <property name="upsih" scope="instance" type="Number"/>
      <property name="piv" scope="instance" type="Number"/>
      <property name="Alpha" scope="instance" type="Number"/>
      <property name="Beta" scope="instance" type="Number"/>
      <property name="Gamma" scope="instance" type="Number"/>
      <property name="Delta" scope="instance" type="Number"/>
      <property name="Epsilon" scope="instance" type="Number"/>
      <property name="Zeta" scope="instance" type="Number"/>
      <property name="Eta" scope="instance" type="Number"/>
      <property name="Theta" scope="instance" type="Number"/>
      <property name="Iota" scope="instance" type="Number"/>
      <property name="Kappa" scope="instance" type="Number"/>
      <property name="Lambda" scope="instance" type="Number"/>
      <property name="Mu" scope="instance" type="Number"/>
      <property name="Nu" scope="instance" type="Number"/>
      <property name="Xi" scope="instance" type="Number"/>
      <property name="Omicron" scope="instance" type="Number"/>
      <property name="Pi" scope="instance" type="Number"/>
      <property name="Rho" scope="instance" type="Number"/>
      <property name="Sigma" scope="instance" type="Number"/>
      <property name="Tau" scope="instance" type="Number"/>
      <property name="Upsilon" scope="instance" type="Number"/>
      <property name="Phi" scope="instance" type="Number"/>
      <property name="Chi" scope="instance" type="Number"/>
      <property name="Psi" scope="instance" type="Number"/>
      <property name="Omega" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons">
    <description>Each icon name coresponds to a Stencil or a Plugin. One can be inserted
	into a button by adding the property: 'icon', which points to one of
	these Stencil objects.</description>
  </class>
  <class type="dojox.drawing.library.icons.line">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.ellipse">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="rx" scope="instance" type="Number"/>
      <property name="ry" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.rect">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.triangle">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.path">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.arrow">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.textBlock">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.equation">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.axes">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.vector">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.pan">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.plus">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.zoomIn">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.zoomOut">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.zoom100">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="text" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.iconize">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.pencil">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.manager">
    <properties>
      <property name="Anchors" scope="instance" type="Object"/>
      <property name="Anchor" scope="instance" type="Object"/>
      <property name="Canvas" scope="instance" type="Object"/>
      <property name="Mouse" scope="instance" type="Object"/>
      <property name="Stencil" scope="instance" type="Object"/>
      <property name="StencilUI" scope="instance" type="Object"/>
      <property name="Undo" scope="instance" type="Object"/>
      <property name="_registry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.manager.keys">
    <methods>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onEsc" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onEnter" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onArrow" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLetter" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="editMode" scope="instance">
        <parameters>
          <parameter name="_isedit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="_enabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
    </methods>
    <properties>
      <property name="arrowIncrement" scope="instance" type="Number"/>
      <property name="arrowShiftIncrement" scope="instance" type="Number"/>
      <property name="shift" scope="instance" type="Boolean"/>
      <property name="ctrl" scope="instance" type="Boolean"/>
      <property name="alt" scope="instance" type="Boolean"/>
      <property name="cmmd" scope="instance" type="Boolean"/>
      <property name="meta" scope="instance" type="Boolean"/>
      <property name="listeners" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.manager.keys.scanForFields">
    <methods/>
    <properties>
      <property name="_fieldCons" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins">
    <properties>
      <property name="_Plugin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing">
    <properties>
      <property name="Grid" scope="instance" type="Object"/>
      <property name="Silverlight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette" superclass="dijit._Widget">
    <description>Grid showing all available entity options which the
	user can pick from.  The library loaded for use by the picker
	is found in dojox.drawing.library.greek.  Adding characters
	there will automatically add them to the palette.
	This works as a popup and as such its onChange and onCancel
	close it.  TextBlock manages it, since it's what uses the assist
	so opening it happens there.  In order to activate the plugin
	add it to the dojox.drawing.Drawing node as shown below:</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="closeAll" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_onCellMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_onCellClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_setCurrent" scope="instance">
        <description>At any point in time there's exactly one
	cell with tabIndex != -1.   If focus is inside the palette then
	focus is on that cell.
	After calling this method, arrow key handlers and mouse click handlers
	should focus the cell in a setTimeout().</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_displayDetails" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePalette" scope="instance">
        <parameters>
          <parameter name="choices" type="String[][]" usage="required"/>
          <parameter name="titles" type="String[]" usage="required"/>
        </parameters>
      </method>
      <method name="_navigateByArrow" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_palette" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="showPreview" scope="instance" type="Boolean"/>
      <property name="dyeClass" scope="instance" type="String"/>
      <property name="paletteClass" scope="instance" type="String"/>
      <property name="cellClass" scope="instance" type="String"/>
      <property name="_currentFocus" scope="instance" type="Object"/>
      <property name="_cells" scope="instance" type="Array"/>
      <property name="_blankGif" scope="instance" type="Object"/>
      <property name="_xDim" scope="instance" type="Object"/>
      <property name="_yDim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette._textBlock">
    <properties>
      <property name="_dropMode" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette.previewNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette.descNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.Greeks">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_alias" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools">
    <properties>
      <property name="Zoom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Iconize"/>
  <class type="dojox.drawing.plugins.tools.Iconize.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Pan"/>
  <class type="dojox.drawing.plugins.tools.Pan.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
      <property name="button" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.ZoomIn"/>
  <class type="dojox.drawing.plugins.tools.ZoomIn.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Zoom100"/>
  <class type="dojox.drawing.plugins.tools.Zoom100.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.ZoomOut"/>
  <class type="dojox.drawing.plugins.tools.ZoomOut.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="__StencilData">
    <properties>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="rx" scope="instance" type="Number"/>
      <property name="ry" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.stencil">
    <properties>
      <property name="Ellipse" scope="instance" type="Object"/>
      <property name="Image" scope="instance" type="Object"/>
      <property name="Line" scope="instance" type="Object"/>
      <property name="Path" scope="instance" type="Object"/>
      <property name="Rect" scope="instance" type="Object"/>
      <property name="Text" scope="instance" type="Object"/>
      <property name="_Base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="StencilArgs">
    <properties>
      <property name="container" scope="instance" type="dojo.gfx.group"/>
      <property name="anchorType" scope="instance" type="String"/>
      <property name="isText" scope="instance" type="Boolean"/>
      <property name="shortType" scope="instance" type="String"/>
      <property name="annotation" scope="instance" type="Boolean"/>
      <property name="subShape" scope="instance" type="Boolean"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
      <property name="mouse" scope="instance" type="Object"/>
      <property name="keys" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="StencilPoints"/>
      <property name="data" scope="instance" type="StencilData"/>
      <property name="marginZero" scope="instance" type="Number"/>
      <property name="created" scope="instance" type="bool"/>
      <property name="highlighted" scope="instance" type="bool"/>
      <property name="selected" scope="instance" type="bool"/>
      <property name="draws" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools"/>
  <class type="dojox.drawing.tools.Arrow"/>
  <class type="dojox.drawing.tools.Arrow.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Ellipse"/>
  <class type="dojox.drawing.tools.Ellipse.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Line"/>
  <class type="dojox.drawing.tools.Line.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Path"/>
  <class type="dojox.drawing.tools.Path.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Pencil"/>
  <class type="dojox.drawing.tools.Pencil.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Rect"/>
  <class type="dojox.drawing.tools.Rect.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.TextBlock"/>
  <class type="dojox.drawing.tools.TextBlock.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom"/>
  <class type="dojox.drawing.tools.custom.Axes"/>
  <class type="dojox.drawing.tools.custom.Axes.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Equation"/>
  <class type="dojox.drawing.tools.custom.Equation.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector"/>
  <class type="dojox.drawing.tools.custom.Vector.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary">
    <description>See Toolbar.js makeButtons function.  The toolbar
	checks Vector.setup for a secondary tool and requires
	name, label, and funct.  Currently it doesn't accept icon
	and only uses text from label for the button.  Funct is the
	function that fires when the button is clicked.
	Setup and postSetup are optional
	and allow tool specific functions to be added to the
	Toolbar object as if they were written there.</description>
    <methods>
      <method name="postSetup" scope="instance">
        <parameters>
          <parameter name="btn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.funct">
    <methods/>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.funct.drawing.stencils">
    <properties>
      <property name="selectedStencils" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.setup">
    <methods>
      <method name="zSelect" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zDeselect" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="vectorTest" scope="instance"/>
    </methods>
    <properties>
      <property name="zSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui">
    <properties>
      <property name="Button" scope="instance" type="Object"/>
      <property name="Tooltip" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.Toolbar">
    <description>Creates a GFX-based toobar that holds GFX-based buttons. Can be either created
	within the actual drawing or within a seperate DOM element. When within the
	drawing, the toolbar will cover a portion of the drawing; hence the option.
	A Toolbar can be created programmtically or in markup. Currently markup is as
	a separate DOM element and programmtic is within the drawing.
	examples:
		dojo.connect(myDrawing, "onSurfaceReady", function(){
			new dojox.drawing.ui.Toolbar({
				drawing:myDrawing,
				tools:"all",
				plugs:"all",
				selected:"ellipse"
			});
		});
	 &lt;div dojoType="dojox.drawing.ui.Toolbar" id="gfxToolbarNode" drawingId="drawingNode"
			class="gfxToolbar" tools="all" plugs="all" selected="ellipse" orient="H"&gt;&lt;/div&gt;</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeButtons" scope="instance"/>
      <method name="onRenderStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTool" scope="instance"/>
      <method name="addPlugin" scope="instance"/>
      <method name="addBack" scope="instance"/>
      <method name="onToolClick" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlugClick" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixprops" scope="instance">
        <parameters>
          <parameter name="props" type="Array" usage="required"/>
          <parameter name="objNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="padding" scope="instance" type="Number"/>
      <property name="margin" scope="instance" type="Number"/>
      <property name="size" scope="instance" type="Number"/>
      <property name="radius" scope="instance" type="Number"/>
      <property name="toolPlugGap" scope="instance" type="number"/>
      <property name="strSelected" scope="instance-prototype" type="Object"/>
      <property name="strTools" scope="instance-prototype" type="Object"/>
      <property name="strPlugs" scope="instance-prototype" type="Object"/>
      <property name="buttons" scope="instance" type="Array"/>
      <property name="plugins" scope="instance" type="Array"/>
      <property name="selected" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
      <property name="toolDrawing" scope="instance" type="Object"/>
      <property name="drawing" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="orient" scope="instance" type="Object"/>
      <property name="horizontal" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.dom">
    <properties>
      <property name="Zoom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.dom.Pan"/>
  <class type="dojox.drawing.ui.dom.Pan.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.dom.Toolbar">
    <description>Currently works in markup only. A class is required with
	either horizontal or vertical as a class (IE prevented using
	either as a default). Assign an attribute of 'drawingId' with
	the id of the DojoX Drawing to which this is assigned.
	The node children will be assigned as the Tools in the toolbar.
	Plugins can also be assigned.
	The Toolbar is largely self contained and has no real public
	methods or events. the Drawing object should be used.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createIcon" scope="instance">
        <parameters>
          <parameter name="node" type="HTMLNode" usage="required"/>
          <parameter name="constr" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="createTool" scope="instance">
        <parameters>
          <parameter name="node" type="HTMLNode" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onSetTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="buttonClass" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
      <property name="drawing" scope="instance" type="Object"/>
      <property name="toolNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.util"/>
  <class type="dojox.drawing.util.common">
    <methods>
      <method name="radToDeg" scope="instance">
        <parameters>
          <parameter name="n" type="Numer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="degToRad" scope="instance">
        <parameters>
          <parameter name="n" type="Numer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="angle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required"/>
          <parameter name="snap" type="?" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Whole Number"/>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="oppAngle" scope="instance">
        <parameters>
          <parameter name="ang" type="Angle" usage="required"/>
        </parameters>
      </method>
      <method name="radians" scope="instance">
        <parameters>
          <parameter name="o" type="EventObject" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="o" type="EventObject" usage="required"/>
        </parameters>
      </method>
      <method name="lineSub" scope="instance">
        <description>x1,y1,x2,y2 represents the Line. 'amt' represents the amount
	to subtract from it.</description>
        <parameters>
          <parameter name="x1" type="Number" usage="required"/>
          <parameter name="y1" type="Number" usage="required"/>
          <parameter name="x2" type="Number" usage="required"/>
          <parameter name="y2" type="Number" usage="required"/>
          <parameter name="amt" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="argsToObj" scope="instance"/>
      <method name="distance" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="slope" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pointOnCircle" scope="instance">
        <parameters>
          <parameter name="cx" type="Number" usage="required"/>
          <parameter name="cy" type="Number" usage="required"/>
          <parameter name="radius" type="Number" usage="required"/>
          <parameter name="angle" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="constrainAngle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required"/>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="snapAngle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required"/>
          <parameter name="ca" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="idSetStart" scope="instance">
        <parameters>
          <parameter name="num" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uid" scope="instance">
        <parameters>
          <parameter name="str" type="?" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="abbr" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="o1" type="Object" usage="required"/>
          <parameter name="o2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="prop" type="property" usage="required"/>
          <parameter name="value" type="?" usage="required"/>
          <parameter name="squelchErrors" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="objects" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.util.oo">
    <description>Inheritance utilities used in DojoX Drawing.
	There were designed in a effort to make Drawing as
	fast as possible - especially in a case where thousands
	of objects are being loaded. Drawing declare performs
	about 3 times faster than Dojo declare and 2 times
	faster than Dojox declare. This is not to say Drawing
	declare is wthout limitations. It doesn't have the same
	syntatic sugar and extensibility of the other two. You
	can't inhert methods. It won't work with Dijit. But it
	is simple and effective.</description>
    <methods>
      <method name="declare" scope="instance">
        <description>Similar in look and feel to Dojo declare as
	far as order and number of arguments, although
	constructed a little closer to prototypical
	inheritance. All arguments passed into the
	constructor are passed into all sub constructors.
	arguments:
	Function, [Object|Function....]
	The first argument is always the base
	constructor. The last argument is always
	an object of methods (or empty object) to
	be mixed in (in the future would like to
	make that object optional). Remaining
	arguments are other constructors mixed in
	using extend() (See below).</description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="extend" scope="instance">
        <description>Typically not used by itself - it's used as
	part of declare(). Could be used by itself
	however, to mix together two or more
	constructors.
	arguments:
	Function, [ Function...]
	Any number of arguments, all must be
	function constructors. The first is
	considered the base object and its
	constructor will fire first.</description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.util.positioning">
    <methods>
      <method name="label" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="angle" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.util.typeset">
    <methods>
      <method name="convertHTML" scope="instance">
        <parameters>
          <parameter name="inText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="convertLaTeX" scope="instance">
        <parameters>
          <parameter name="inText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl">
    <methods>
      <method name="quickFilter" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="TOKEN_BLOCK" scope="instance" type="Number"/>
      <property name="TOKEN_VAR" scope="instance" type="Number"/>
      <property name="TOKEN_COMMENT" scope="instance" type="Number"/>
      <property name="TOKEN_TEXT" scope="instance" type="Number"/>
      <property name="_Context" scope="instance" type="Object"/>
      <property name="Template" scope="instance" type="Object"/>
      <property name="_QuickNodeList" scope="instance" type="Object"/>
      <property name="_Filter" scope="instance" type="Object"/>
      <property name="_TextNode" scope="instance" type="Object"/>
      <property name="_Node" scope="instance" type="Object"/>
      <property name="_NodeList" scope="instance" type="Object"/>
      <property name="_VarNode" scope="instance" type="Object"/>
      <property name="_Parser" scope="instance" type="Object"/>
      <property name="mark_safe" scope="instance" type="Object"/>
      <property name="TOKEN_CHANGE" scope="instance" type="Number"/>
      <property name="TOKEN_ATTR" scope="instance" type="Number"/>
      <property name="TOKEN_CUSTOM" scope="instance" type="Number"/>
      <property name="TOKEN_NODE" scope="instance" type="Number"/>
      <property name="DomTemplate" scope="instance" type="Object"/>
      <property name="DomBuffer" scope="instance" type="Object"/>
      <property name="_DomNode" scope="instance" type="Object"/>
      <property name="_DomNodeList" scope="instance" type="Object"/>
      <property name="_DomVarNode" scope="instance" type="Object"/>
      <property name="ChangeNode" scope="instance" type="Object"/>
      <property name="AttributeNode" scope="instance" type="Object"/>
      <property name="_DomTextNode" scope="instance" type="Object"/>
      <property name="_DomParser" scope="instance" type="Object"/>
      <property name="HtmlTemplate" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Context" superclass="dojox.dtl._Context.prototype">
    <methods>
      <method name="getKeys" scope="instance"/>
      <method name="extend" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.dtl.Context|Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="filter" type="dojox.dtl.Context|Object|String" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="getThis" scope="instance"/>
      <method name="hasKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_this" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Context.setThis">
    <methods/>
    <properties>
      <property name="_this" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomInline" superclass="dijit._Widget.prototype">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
      <property name="declaredClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomInline.render">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomInline.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomInline.postMixInProperties">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.HtmlInline">
    <properties>
      <property name="declaredClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline" superclass="dijit._Widget.prototype">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
      <property name="declaredClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.render">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.render.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.postMixInProperties">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated">
    <methods>
      <method name="_getContext" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_dijitTemplateCompat" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Object"/>
      <property name="_render" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated.setTemplate">
    <methods/>
    <properties>
      <property name="template" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated.render">
    <methods/>
    <properties>
      <property name="template" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated._getCachedTemplate">
    <methods/>
    <properties>
      <property name="_templates" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib">
    <properties>
      <property name="html" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.dijit">
    <methods>
      <method name="dojoAttachPoint" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dojoAttachEvent" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dojoType" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="on" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="AttachNode" scope="instance" type="Object"/>
      <property name="EventNode" scope="instance" type="Object"/>
      <property name="DojoTypeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlTemplated">
    <properties>
      <property name="declaredClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl._Templated" superclass="dijit._Templated">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="getCachedTemplate" scope="instance">
        <parameters>
          <parameter name="templatePath" type="Object" usage="required"/>
          <parameter name="templateString" type="Object" usage="required"/>
          <parameter name="alwaysUseString" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="_dijitTemplateCompat" scope="instance" type="bool"/>
      <property name="_template" scope="instance" type="Object"/>
      <property name="_startupWidgets" scope="instance" type="Object"/>
      <property name="_supportingWidgets" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_templateCache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.parser">
    <properties>
      <property name="_query" scope="instance" type="String"/>
      <property name="_attrName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl.Token">
    <methods>
      <method name="split" scope="instance"/>
      <method name="split_contents" scope="instance">
        <parameters>
          <parameter name="limit" type="Integer" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="token_type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Token.contents">
    <properties>
      <property name="split" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.text">
    <methods>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="module" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTag" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFilter" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplate" scope="instance">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplateString" scope="instance">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveLazy" scope="instance">
        <parameters>
          <parameter name="location" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
          <parameter name="json" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveTemplateArg" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isTemplate" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveContextArg" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseDelims" scope="instance">
        <parameters>
          <parameter name="varr" type="Object" usage="required"/>
          <parameter name="load" type="Object" usage="required"/>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_re" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.dtl._noOpNode">
    <methods>
      <method name="render" scope="instance"/>
      <method name="unrender" scope="instance"/>
      <method name="clone" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.register">
    <methods>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributeTags" scope="instance"/>
      <method name="_any" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="base" type="Object" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tags" scope="instance">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filters" scope="instance">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.register._registry">
    <properties>
      <property name="attributes" scope="instance" type="Array"/>
      <property name="tags" scope="instance" type="Array"/>
      <property name="filters" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dtl._base">
    <methods>
      <method name="escape" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="safe" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.contrib.data">
    <methods>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bind_data" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bind_query" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_BoundItem" scope="instance" type="Object"/>
      <property name="BindDataNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.data._BoundItem.get">
    <properties>
      <property name="safe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.dom">
    <methods>
      <method name="buffer" scope="instance">
        <description>When using DomTemplate, wrap any content
	that you expect to change often during
	re-rendering. It will then remove its parent
	from the main document while it re-renders that
	section of code. It will only remove it from
	the main document if a mainpulation of somes sort
	happens. ie It won't swap out if it diesn't have to.</description>
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="html" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="style_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="StyleNode" scope="instance" type="Object"/>
      <property name="BufferNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.objects">
    <methods>
      <method name="key" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.BOOLS">
    <properties>
      <property name="checked" scope="instance" type="Number"/>
      <property name="disabled" scope="instance" type="Number"/>
      <property name="readonly" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.dtl.dom">
    <methods>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="nodes" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_tokenize" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="tokens" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="__tokenize" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="tokens" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_attributes" scope="instance" type="Object"/>
      <property name="_uppers" scope="instance" type="Object"/>
      <property name="_re4" scope="instance" type="RegExp"/>
      <property name="_reTrim" scope="instance" type="RegExp"/>
      <property name="_reSplit" scope="instance" type="RegExp"/>
      <property name="_swallowed" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dtl.dom.getTemplate">
    <methods/>
    <properties>
      <property name="_commentable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.ext-dojo">
    <properties>
      <property name="NodeList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.dates">
    <methods>
      <method name="_toDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="date" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="time" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timesince" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timeuntil" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter"/>
  <class type="dojox.dtl.filter.htmlstrings">
    <methods>
      <method name="linebreaks" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linebreaksbr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removetags" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="striptags" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_linebreaksrn" scope="instance" type="RegExp"/>
      <property name="_linebreaksn" scope="instance" type="RegExp"/>
      <property name="_linebreakss" scope="instance" type="RegExp"/>
      <property name="_linebreaksbr" scope="instance" type="RegExp"/>
      <property name="_removetagsfind" scope="instance" type="RegExp"/>
      <property name="_striptags" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.integers">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get_digit" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.lists">
    <methods>
      <method name="_dictsort" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dictsort" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dictsortreversed" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="first" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="join" scope="instance">
        <description>Django throws a compile error, but JS can't do arg checks
	so we're left with run time errors, which aren't wise for something
	as trivial here as an empty arg.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length_is" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="random" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slice" scope="instance">
        <description>Uses the same syntax as Python's list slicing; see
	http://diveintopython.org/native_data_types/lists.html#odbchelper.list.slice
	for an introduction.
	Also uses the optional third value to denote every X item.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unordered_list" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="tabs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unordered_list" scope="instance">
        <description>The list is assumed to be in the proper format. For example, if ``var`` contains
	``['States', [['Kansas', [['Lawrence', []], ['Topeka', []]]], ['Illinois', []]]]``,
	then ``{{ var|unordered_list }}`` would return::
		&lt;li&gt;States
		&lt;ul&gt;
			&lt;li&gt;Kansas
			&lt;ul&gt;
				&lt;li&gt;Lawrence&lt;/li&gt;
				&lt;li&gt;Topeka&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
			&lt;li&gt;Illinois&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.logic">
    <methods>
      <method name="default_" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="default_if_none" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="divisibleby" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="yesno" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_yesno" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.misc">
    <methods>
      <method name="filesizeformat" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pluralize" scope="instance">
        <description>By default, 's' is used as a suffix; if an argument is provided, that string
	is used instead. If the provided argument contains a comma, the text before
	the comma is used for the singular case.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="phone2numeric" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pprint" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.misc._phone2numeric">
    <properties>
      <property name="a" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="c" scope="instance" type="Number"/>
      <property name="d" scope="instance" type="Number"/>
      <property name="e" scope="instance" type="Number"/>
      <property name="f" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="h" scope="instance" type="Number"/>
      <property name="i" scope="instance" type="Number"/>
      <property name="j" scope="instance" type="Number"/>
      <property name="k" scope="instance" type="Number"/>
      <property name="l" scope="instance" type="Number"/>
      <property name="m" scope="instance" type="Number"/>
      <property name="n" scope="instance" type="Number"/>
      <property name="o" scope="instance" type="Number"/>
      <property name="p" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
      <property name="s" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
      <property name="u" scope="instance" type="Number"/>
      <property name="v" scope="instance" type="Number"/>
      <property name="w" scope="instance" type="Number"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.strings">
    <methods>
      <method name="_urlquote" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="safe" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="addslashes" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="capfirst" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="center" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cut" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fix_ampersands" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="floatformat" scope="instance">
        <description>If called without an argument, displays a floating point
	number as 34.2 -- but only if there's a point to be displayed.
	With a positive numeric argument, it displays that many decimal places
	always.
	With a negative numeric argument, it will display that many decimal
	places -- but only if there's places to be displayed.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iriencode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linenumbers" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ljust" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="lower" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="make_list" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rjust" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slugify" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stringformat" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="title" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="truncatewords" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="truncatewords_html" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="upper" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlencode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlize" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlizetrunc" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="' + middle + '&quot; rel=&quot;nofollow&quot;&gt;' + trimmed + '&lt;/a&gt;';"/>
        </return-types>
      </method>
      <method name="wordcount" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wordwrap" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_fix_ampersands" scope="instance" type="RegExp"/>
      <property name="_strings" scope="instance" type="Object"/>
      <property name="_truncatewords" scope="instance" type="RegExp"/>
      <property name="_truncate_words" scope="instance" type="RegExp"/>
      <property name="_truncate_tag" scope="instance" type="RegExp"/>
      <property name="_urlize" scope="instance" type="RegExp"/>
      <property name="_urlize2" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.strings._truncate_singlets">
    <properties>
      <property name="br" scope="instance" type="Object"/>
      <property name="col" scope="instance" type="Object"/>
      <property name="link" scope="instance" type="Object"/>
      <property name="base" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
      <property name="param" scope="instance" type="Object"/>
      <property name="area" scope="instance" type="Object"/>
      <property name="hr" scope="instance" type="Object"/>
      <property name="input" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render.dom"/>
  <class type="dojox.dtl.render.dom.Render">
    <methods/>
    <properties>
      <property name="_tpl" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render.dom.Render.setAttachPoint">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render.dom.Render.render">
    <methods/>
    <properties>
      <property name="_tpl" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render"/>
  <class type="dojox.dtl.render.html">
    <properties>
      <property name="Render" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.date">
    <methods>
      <method name="now" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.tag.date.NowNode">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_format" scope="instance" type="Object"/>
      <property name="format" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag"/>
  <class type="dojox.dtl.tag.loader">
    <methods>
      <method name="block" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="extends_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="include" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ssi" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="BlockNode" scope="instance" type="Object"/>
      <property name="ExtendsNode" scope="instance" type="Object"/>
      <property name="IncludeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.logic">
    <methods>
      <method name="if_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ifequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="negate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifnotequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="for_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="IfNode" scope="instance" type="Object"/>
      <property name="IfEqualNode" scope="instance" type="Object"/>
      <property name="ForNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loop">
    <methods>
      <method name="cycle" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifchanged" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="regroup" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="CycleNode" scope="instance" type="Object"/>
      <property name="IfChangedNode" scope="instance" type="Object"/>
      <property name="RegroupNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc">
    <methods>
      <method name="comment" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="debug" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="firstof" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="spaceless" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="templatetag" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="widthratio" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="with_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="DebugNode" scope="instance" type="Object"/>
      <property name="FilterNode" scope="instance" type="Object"/>
      <property name="FirstOfNode" scope="instance" type="Object"/>
      <property name="SpacelessNode" scope="instance" type="Object"/>
      <property name="TemplateTagNode" scope="instance" type="Object"/>
      <property name="WidthRatioNode" scope="instance" type="Object"/>
      <property name="WithNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.utils.date">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="timesince" scope="instance">
        <description>Adapted from http://blog.natbat.co.uk/archive/2003/Jun/14/time_since</description>
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
          <parameter name="now" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_chunks" scope="instance" type="Array"/>
      <property name="_months_ap" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dtl.utils.date.DateFormat" superclass="dojox.date.php.DateFormat.prototype">
    <methods>
      <method name="f" scope="instance">
        <description>Examples: '1', '1:30', '2:05', '2'
	Proprietary extension.</description>
      </method>
      <method name="N" scope="instance"/>
      <method name="P" scope="instance">
        <description>Examples: '1 a.m.', '1:30 p.m.', 'midnight', 'noon', '12:30 p.m.'
	Proprietary extension.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.utils"/>
  <class type="dojox.editor.plugins"/>
  <class type="dojox.editor.plugins._AutoSaveSettingDialog" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="onOk" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_isValidValue" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="dialogTitle" scope="instance" type="String"/>
      <property name="dialogDescription" scope="instance" type="String"/>
      <property name="paramName" scope="instance" type="String"/>
      <property name="paramLabel" scope="instance" type="String"/>
      <property name="btnOk" scope="instance" type="String"/>
      <property name="btnCancel" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="dialogId" scope="instance" type="String"/>
      <property name="textBoxId" scope="instance" type="String"/>
      <property name="_value" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.AutoSave" superclass="dojox.editor.plugins.Save">
    <methods>
      <method name="_setIntervalAttr" scope="instance">
        <parameters>
          <parameter name="val" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_getIntervalAttr" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_showAutSaveSettingDialog" scope="instance"/>
      <method name="_onDialogOk" scope="instance"/>
      <method name="_onStopClick" scope="instance"/>
      <method name="_setSaveInterval" scope="instance">
        <parameters>
          <parameter name="interval" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_clearSaveInterval" scope="instance"/>
      <method name="onSuccess" scope="instance">
        <parameters>
          <parameter name="resp" type="The" usage="required"/>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.Save" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="logResults" scope="instance" type="Object"/>
      <property name="interval" scope="instance" type="Number"/>
      <property name="_iconClassPrefix" scope="instance" type="String"/>
      <property name="_MIN" scope="instance" type="Number"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="_strings" scope="instance" type="Object"/>
      <property name="_saveSettingDialog" scope="instance" type="Object"/>
      <property name="_promDialog" scope="instance" type="Object"/>
      <property name="_menuItemAutoSave" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_menuItemAutoSaveClickHandler" scope="instance" type="Object"/>
      <property name="_intervalHandler" scope="instance" type="Object"/>
      <property name="_promDialogTimeout" scope="instance" type="Object"/>
      <property name="_isWorking" scope="instance" type="bool"/>
      <property name="_destroyRecursive" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor"/>
  <class type="dojox.editor.plugins.AutoUrlLink" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="_keyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_recognize" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_inLink" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_findLastEditingNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_findUrls" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="bm" type="DomNode" usage="required"/>
          <parameter name="bmOff" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_template" scope="instance" type="String"/>
      <property name="_saved" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.AutoUrlLink.editor">
    <properties>
      <property name="editNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Blockquote" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleQuote" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_findBlockQuotes" scope="instance">
        <parameters>
          <parameter name="nodeList" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_getTagName" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isRootInline" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isTextElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isInlineFormat" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="_nlsResources" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._BreadcrumbMenuTitle" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setMenuTitleAttr" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenuTitleAttr" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="menuTitle" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._BreadcrumbMenuTitle.title">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Breadcrumb" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectContents" scope="instance"/>
      <method name="_deleteContents" scope="instance"/>
      <method name="_selectElement" scope="instance"/>
      <method name="_deleteElement" scope="instance"/>
      <method name="_moveCToStart" scope="instance"/>
      <method name="_moveCToEnd" scope="instance"/>
      <method name="_updateBreadcrumb" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_menu" scope="instance" type="The"/>
      <property name="breadcrumbBar" scope="instance" type="The"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="_buttons" scope="instance" type="Object"/>
      <property name="_titleTemplate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Breadcrumb.breadcrumbBar.domNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._CollapsibleToolbarButton" superclass="dijit._Widget">
    <methods>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
      <property name="buttonClass" scope="instance" type="String"/>
      <property name="text" scope="instance" type="String"/>
      <property name="textClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.CollapsibleToolbar" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_constructContainer" scope="instance"/>
      <method name="_onClose" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_onOpen" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_myWidgets" scope="instance" type="array"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="openTd" scope="instance" type="Object"/>
      <property name="closeTd" scope="instance" type="Object"/>
      <property name="menu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.CollapsibleToolbar.editor.header">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.CollapsibleToolbar.editor.footer">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette" superclass="dijit._Widget">
    <description>Grid showing various entities, so the user can pick a certain entity.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_onCellMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_setCurrent" scope="instance">
        <description>Removes highlight of the old entity, and highlights
	the new entity.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_displayDetails" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="showPreview" scope="instance" type="Boolean"/>
      <property name="showCode" scope="instance" type="boolean"/>
      <property name="showEntityName" scope="instance" type="bool"/>
      <property name="palette" scope="instance" type="String"/>
      <property name="dyeClass" scope="instance" type="String"/>
      <property name="paletteClass" scope="instance" type="String"/>
      <property name="cellClass" scope="instance" type="String"/>
      <property name="_palette" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.previewNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.codeNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.entityNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.descNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.LatinEntity">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_alias" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCloseBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onClick" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="btnId" scope="instance" type="String"/>
      <property name="widget" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceTextBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="textId" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="toolTip" scope="instance" type="String"/>
      <property name="widget" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCheckBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="checkId" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="widget" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCheckBox.checkBox">
    <methods>
      <method name="isFocusable" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.editor.plugins._FindReplaceToolbar" superclass="dijit.Toolbar">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_onToolbarEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Toolbar" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.FindReplace" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
      <method name="_toggleFindReplace" scope="instance">
        <parameters>
          <parameter name="show" type="Boolean" usage="required"/>
          <parameter name="ignoreState" type="Boolean" usage="optional"/>
          <parameter name="buttonDisabled" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_populateFindField" scope="instance"/>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit.Toolbar" usage="required"/>
        </parameters>
      </method>
      <method name="_checkButtons" scope="instance"/>
      <method name="_onFindKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onReplaceKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_find" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_replace" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>Boolean indicating if the content was replaced or not.</return-description>
      </method>
      <method name="_replaceAll" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_findText" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required"/>
          <parameter name="caseSensitive" type="Boolean" usage="required"/>
          <parameter name="backwards" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_filterRegexp" scope="instance">
        <description>Returns a regular expression object that conforms to the defined conversion rules.
	For example:
	ca*   -&gt; /^ca.*$/
	*ca*  -&gt; /^.*ca.*$/
	*c\*a*  -&gt; /^.*c\*a.*$/
	*c\*a?*  -&gt; /^.*c\*a..*$/
	and so on.</description>
        <parameters>
          <parameter name="pattern" type="String" usage="required"/>
          <parameter name="ignoreCase" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="RegExp"/>
        </return-types>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="instance" type="Define"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="button" scope="instance" type="The"/>
      <property name="_frToolbar" scope="instance" type="The"/>
      <property name="_closeBox" scope="instance" type="The"/>
      <property name="_findField" scope="instance" type="The"/>
      <property name="_replaceField" scope="instance" type="The"/>
      <property name="_findButton" scope="instance" type="The"/>
      <property name="_replaceButton" scope="instance" type="The"/>
      <property name="_replaceAllButton" scope="instance" type="The"/>
      <property name="_caseSensitive" scope="instance" type="The"/>
      <property name="_backwards" scope="instance" type="The"/>
      <property name="_promDialog" scope="instance" type="The"/>
      <property name="_promDialogTimeout" scope="instance" type="Object"/>
      <property name="_strings" scope="instance" type="The"/>
      <property name="_displayed" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace.editor">
    <properties>
      <property name="window" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace._findButton.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace._replaceButton.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace._replaceAllButton.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertAnchor" superclass="dijit._editor._Plugin">
    <description>The command provided by this plugin is:
	* insertAnchor</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkInput" scope="instance"/>
      <method name="_setup" scope="instance"/>
      <method name="getAnchorStyle" scope="instance"/>
      <method name="_applyStyles" scope="instance"/>
      <method name="_calcBaseUrl" scope="instance">
        <parameters>
          <parameter name="fullUrl" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseDialog" scope="instance"/>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="a" type="The" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object;"/>
        </return-types>
      </method>
      <method name="_onOpenDialog" scope="instance"/>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_preDomFilter" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_postDomFilter" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="htmlTemplate" scope="instance" type="String"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="_template" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Object"/>
      <property name="_anchorInput" scope="instance" type="Object"/>
      <property name="_textInput" scope="instance" type="Object"/>
      <property name="_setButton" scope="instance" type="Object"/>
      <property name="_styled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertAnchor.editor">
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertEntity" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* insertEntity - inserts the selected HTML entity character</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_preFilterEntities" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_postFilterEntities" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.LocalImage" superclass="dijit._editor.plugins.ImgLinkDialog">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="_initialFileUploader" scope="instance"/>
      <method name="_checkAndFixInput" scope="instance"/>
      <method name="_isValid" scope="instance"/>
      <method name="_cancelFileUpload" scope="instance"/>
      <method name="_checkAndSetValue" scope="instance"/>
      <method name="_setDialogStatus" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins.ImgLinkDialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="uploadable" scope="instance" type="bool"/>
      <property name="uploadUrl" scope="instance" type="String"/>
      <property name="baseImageUrl" scope="instance" type="String"/>
      <property name="fileMask" scope="instance" type="String"/>
      <property name="urlRegExp" scope="instance" type="Object"/>
      <property name="_fileUploader" scope="instance" type="Object"/>
      <property name="htmlFieldName" scope="instance" type="String"/>
      <property name="_isLocalFile" scope="instance" type="bool"/>
      <property name="_messages" scope="instance" type="Object"/>
      <property name="_cssPrefix" scope="instance" type="String"/>
      <property name="_closable" scope="instance" type="Object"/>
      <property name="linkDialogTemplate" scope="instance" type="Object"/>
      <property name="tag" scope="instance" type="String"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Object"/>
      <property name="_urlInput" scope="instance" type="Object"/>
      <property name="_textInput" scope="instance" type="Object"/>
      <property name="_setButton" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeIndentOutdent" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="command" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_indentImpl" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_indentElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Return the node that was indented."/>
        </return-types>
      </method>
      <method name="_outdentElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_outdentImpl" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_indentList" scope="instance">
        <parameters>
          <parameter name="listItem" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_outdentList" scope="instance">
        <parameters>
          <parameter name="listItem" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isIndentableElement" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_convertIndent" scope="instance">
        <parameters>
          <parameter name="indent" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isLtr" scope="instance"/>
      <method name="_isInlineFormat" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_getTagName" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isRootInline" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isTextElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="indentBy" scope="instance" type="number"/>
      <property name="indentUnits" scope="instance" type="String"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeIndentOutdent.editor.document">
    <properties>
      <property name="body" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeStyle" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_convertToSemantic" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeTags" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_convertToCss" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_condenseSpans" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_isInline" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_inserthtmlImpl" scope="instance">
        <parameters>
          <parameter name="html" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="mode" scope="instance" type="String"/>
      <property name="condenseSpans" scope="instance" type="Object"/>
      <property name="_browserFilter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeStyle.editor">
    <properties>
      <property name="_oldInsertHtmlImpl" scope="instance" type="Object"/>
      <property name="_inserthtmlImpl" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PageBreak" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_style" scope="instance"/>
      <method name="_insertPageBreak" scope="instance"/>
      <method name="_allowBreak" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="_unbreakableNodes" scope="instance" type="Array"/>
      <property name="_pbContent" scope="instance" type="String"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_styled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PageBreak.editor">
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PasteFromWord" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_openDialog" scope="instance"/>
      <method name="_paste" scope="instance"/>
      <method name="_cancel" scope="instance"/>
      <method name="_clearDialog" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
      <property name="_template" scope="instance" type="Object"/>
      <property name="_filters" scope="instance" type="Array"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_uId" scope="instance" type="Object"/>
      <property name="_dialog" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PrettyPrint" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="indentBy" scope="instance" type="Number"/>
      <property name="lineLength" scope="instance" type="Number"/>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="entityMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Preview" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_preview" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="styles" scope="instance" type="String"/>
      <property name="stylesheets" scope="instance" type="Array"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="_nlsResources" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ResizeTableColumn" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="ruleDiv" scope="instance-prototype" type="Object"/>
      <property name="isLtr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ResizeTableColumn.editor">
    <properties>
      <property name="customUndo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Save" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_save" scope="instance"/>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSuccess" scope="instance">
        <parameters>
          <parameter name="resp" type="The" usage="required"/>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="url" scope="instance" type="String"/>
      <property name="logResults" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ShowBlockNodes" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
      <method name="_showBlocks" scope="instance">
        <parameters>
          <parameter name="show" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcBaseUrl" scope="instance">
        <parameters>
          <parameter name="fullUrl" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="_styled" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ShowBlockNodes.editor">
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Smiley" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* smiley - inserts the selected emoticon</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_preFilterEntities" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_postFilterEntities" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_decode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
          <parameter name="ascii" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="emoticonMarker" scope="instance" type="String"/>
      <property name="emoticonImageClass" scope="instance" type="String"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="i18n" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="emoticonImageRegexp" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onSkip" scope="instance"/>
      <method name="onSkipAll" scope="instance"/>
      <method name="onAddToDic" scope="instance"/>
      <method name="onReplace" scope="instance"/>
      <method name="onReplaceAll" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onEnter" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_cancel" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_enter" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_unfoundTextBoxChange" scope="instance"/>
      <method name="_setUnfoundWordAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getUnfoundWordAttr" scope="instance"/>
      <method name="_setSuggestionListAttr" scope="instance">
        <parameters>
          <parameter name="values" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_getSelectedWordAttr" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setInProgressAttr" scope="instance">
        <parameters>
          <parameter name="show" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="textId" scope="instance" type="String"/>
      <property name="selectId" scope="instance" type="String"/>
      <property name="isChanged" scope="instance-prototype" type="bool"/>
      <property name="ignoreChange" scope="instance" type="bool"/>
      <property name="isOpen" scope="instance" type="bool"/>
      <property name="closable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl.suggestionSelect">
    <methods>
      <method name="addItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="removeItems" scope="instance"/>
      <method name="deselectAll" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl.containerNode">
    <properties>
      <property name="selectedIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._SpellCheckScriptMultiPart">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="send" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
          <parameter name="action" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_finalizeCollection" scope="instance">
        <parameters>
          <parameter name="action" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setWaitingTime" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="ACTION_QUERY" scope="instance" type="Object"/>
      <property name="ACTION_UPDATE" scope="instance" type="String"/>
      <property name="callbackHandle" scope="instance" type="String"/>
      <property name="maxBufferLength" scope="instance" type="Number"/>
      <property name="delimiter" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="_timeout" scope="instance" type="Number"/>
      <property name="SEC" scope="instance" type="Number"/>
      <property name="serviceEndPoint" scope="instance-prototype" type="String"/>
      <property name="exArgs" scope="instance-prototype" type="Object"/>
      <property name="_result" scope="instance" type="Array"/>
      <property name="_counter" scope="instance-prototype" type="Number"/>
      <property name="_queue" scope="instance" type="Array"/>
      <property name="isWorking" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck" superclass="dijit._editor._Plugin">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_setNetwork" scope="instance"/>
      <method name="_connectUp" scope="instance"/>
      <method name="_disabled" scope="instance">
        <parameters>
          <parameter name="name" type="Command" usage="required"/>
          <parameter name="disabled" type="Command" usage="required"/>
        </parameters>
      </method>
      <method name="_keyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadData" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_openDialog" scope="instance"/>
      <method name="_skip" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="optional"/>
          <parameter name="noUpdate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_skipAll" scope="instance"/>
      <method name="_add" scope="instance"/>
      <method name="_replace" scope="instance"/>
      <method name="_replaceAll" scope="instance"/>
      <method name="_cancel" scope="instance"/>
      <method name="_enter" scope="instance"/>
      <method name="_query" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_html2Text" scope="instance">
        <parameters>
          <parameter name="html" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_getBookmark" scope="instance">
        <parameters>
          <parameter name="eValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToBookmark" scope="instance"/>
      <method name="_submitContent" scope="instance">
        <parameters>
          <parameter name="delay" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_populateDialog" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_markIncorrectWords" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
          <parameter name="cache" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_replaceWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required"/>
          <parameter name="text" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_skipWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_skipWordAll" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required"/>
          <parameter name="word" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_addWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required"/>
          <parameter name="word" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_findText" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required"/>
          <parameter name="caseSensitive" type="Boolean" usage="required"/>
          <parameter name="backwards" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_spellCheckFilter" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="bufferLength" scope="instance" type="Number"/>
      <property name="interactive" scope="instance" type="bool"/>
      <property name="timeout" scope="instance" type="Number"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="exArgs" scope="instance" type="Object"/>
      <property name="_cursorSpan" scope="instance" type="String"/>
      <property name="_cursorSelector" scope="instance" type="String"/>
      <property name="_incorrectWordsSpan" scope="instance" type="String"/>
      <property name="_selector" scope="instance" type="String"/>
      <property name="_maxItemNumber" scope="instance" type="Number"/>
      <property name="_strings" scope="instance" type="Object"/>
      <property name="_dialog" scope="instance" type="Object"/>
      <property name="_service" scope="instance" type="Object"/>
      <property name="_iterator" scope="instance-prototype" type="Number"/>
      <property name="_enabled" scope="instance-prototype" type="Object"/>
      <property name="_cache" scope="instance-prototype" type="Object"/>
      <property name="_delayHandler" scope="instance" type="Object"/>
      <property name="parser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._ignoredIncorrectStyle">
    <properties>
      <property name="cursor" scope="instance" type="String"/>
      <property name="borderBottom" scope="instance" type="String"/>
      <property name="backgroundColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._normalIncorrectStyle">
    <properties>
      <property name="cursor" scope="instance" type="String"/>
      <property name="borderBottom" scope="instance" type="String"/>
      <property name="backgroundColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._highlightedIncorrectStyle">
    <properties>
      <property name="borderBottom" scope="instance" type="String"/>
      <property name="backgroundColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._dialogContent">
    <properties>
      <property name="closable" scope="instance" type="Object"/>
      <property name="ignoreChange" scope="instance" type="Object"/>
      <property name="isOpen" scope="instance" type="Object"/>
      <property name="isChanged" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._spanList">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._editor">
    <properties>
      <property name="_cursorToStart" scope="instance" type="bool"/>
      <property name="window" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._StatusBar" superclass="dijit._Widget">
    <methods>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._StatusBar.barContent">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.StatusBar" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="attr" type="The" usage="required"/>
          <parameter name="val" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="attr" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="statusBar" scope="instance" type="The"/>
      <property name="resizer" scope="instance" type="Boolean"/>
      <property name="resizeHandle" scope="instance" type="Object"/>
      <property name="_msgListener" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.StatusBar.editor">
    <properties>
      <property name="statusBar" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TableHandler" superclass="dijit._editor._Plugin">
    <methods>
      <method name="doMixins" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTableInfo" scope="instance">
        <parameters>
          <parameter name="forceNewData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectDraggable" scope="instance"/>
      <method name="onDragStart" scope="instance"/>
      <method name="onDragEnd" scope="instance"/>
      <method name="checkAvailable" scope="instance"/>
      <method name="_prepareTable" scope="instance">
        <parameters>
          <parameter name="tbl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTimeStamp" scope="instance">
        <return-types>
          <return-type type="Fixed the bug that this method always returns the same timestamp"/>
        </return-types>
      </method>
      <method name="_tempStoreTableData" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_tempAvailability" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectTableKeys" scope="instance"/>
      <method name="disconnectTableKeys" scope="instance"/>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplayChanged" scope="instance"/>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="editor" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="tablesConnected" scope="instance" type="bool"/>
      <property name="currentlyAvailable" scope="instance" type="bool"/>
      <property name="alwaysAvailable" scope="instance" type="bool"/>
      <property name="availableCurrentlySet" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="bool"/>
      <property name="tableData" scope="instance" type="Object"/>
      <property name="shiftKeyDown" scope="instance" type="bool"/>
      <property name="undoEnabled" scope="instance" type="Object"/>
      <property name="refCount" scope="instance" type="Number"/>
      <property name="cnKeyDn" scope="instance" type="Object"/>
      <property name="cnKeyUp" scope="instance" type="Object"/>
      <property name="stopEvent" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TableHandler.editor">
    <properties>
      <property name="_tablePluginHandler" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TableHandler.editorDomNode">
    <properties>
      <property name="ondragstart" scope="instance" type="Object"/>
      <property name="ondragend" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TablePlugins" superclass="dijit._editor._Plugin">
    <methods>
      <method name="onDisplayChanged" scope="instance">
        <parameters>
          <parameter name="withinTable" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEditorLoaded" scope="instance"/>
      <method name="selectTable" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="modTable" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="begEdit" scope="instance"/>
      <method name="endEdit" scope="instance"/>
      <method name="makeColumnsEven" scope="instance"/>
      <method name="getTableInfo" scope="instance">
        <parameters>
          <parameter name="forceNewData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeTitle" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedCells" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="commandName" scope="instance" type="String"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="alwaysAvailable" scope="instance" type="bool"/>
      <property name="undoEnabled" scope="instance" type="Object"/>
      <property name="available" scope="instance" type="Object"/>
      <property name="_availableTopic" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="valBeforeUndo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TablePlugins.editor">
    <properties>
      <property name="customUndo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TableContextMenu" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_createContextMenu" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="menu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TableContextMenu.button.domNode">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertTable" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="modTable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="alwaysAvailable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ModifyTable" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="modTable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._CellColorDropDown" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Value" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="setColor" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ColorTableCell" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="modTable" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="command" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="closable" scope="instance" type="Object"/>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EditorTableDialog" superclass="dijit.Dialog">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onInsert" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onBuildTable" scope="instance">
        <parameters>
          <parameter name="tableText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EditorModifyTableDialog" superclass="dijit.Dialog">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="setBrdColor" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBkColor" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onSetTable" scope="instance">
        <parameters>
          <parameter name="tableText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="table" scope="instance" type="Object"/>
      <property name="tableAtts" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_cleanupWidgets" scope="instance" type="Array"/>
      <property name="brdColor" scope="instance" type="Object"/>
      <property name="bkColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TextColorDropDown" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Value" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TextColor" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="useDefaultCommand" scope="instance" type="Boolean"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="_picker" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ToolbarLineBreak" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.UploadImage" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="createFileInput" scope="instance"/>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="ioArgs" type="Object" usage="required"/>
          <parameter name="widgetRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertTempImage" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="tempImageUrl" scope="instance" type="String"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="uploadUrl" scope="instance" type="String"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="String"/>
      <property name="command" scope="instance" type="String"/>
      <property name="currentImageId" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._SmileyPalette" superclass="dijit._Widget">
    <description>Grid showing various emoticons.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_palette" scope="instance" type="Array"/>
      <property name="dyeClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Emoticon">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="imgHtml" scope="instance">
        <parameters>
          <parameter name="clazz" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
          <parameter name="blankGif" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="fromAscii" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Emoticon.ascii">
    <properties>
      <property name="smile" scope="instance" type="String"/>
      <property name="laughing" scope="instance" type="String"/>
      <property name="wink" scope="instance" type="String"/>
      <property name="grin" scope="instance" type="String"/>
      <property name="cool" scope="instance" type="String"/>
      <property name="angry" scope="instance" type="String"/>
      <property name="half" scope="instance" type="String"/>
      <property name="eyebrow" scope="instance" type="String"/>
      <property name="frown" scope="instance" type="String"/>
      <property name="shy" scope="instance" type="String"/>
      <property name="goofy" scope="instance" type="String"/>
      <property name="oops" scope="instance" type="String"/>
      <property name="tongue" scope="instance" type="String"/>
      <property name="idea" scope="instance" type="String"/>
      <property name="yes" scope="instance" type="String"/>
      <property name="no" scope="instance" type="String"/>
      <property name="angel" scope="instance" type="String"/>
      <property name="crying" scope="instance" type="String"/>
      <property name="happy" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._SpellCheckParser">
    <methods>
      <method name="parseIntoWords" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-description>Array holding all the words</return-description>
      </method>
      <method name="getIndices" scope="instance">
        <return-description>Index array</return-description>
      </method>
    </methods>
    <properties>
      <property name="lang" scope="instance" type="String"/>
      <property name="words" scope="instance" type="Array"/>
      <property name="indices" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.embed.Flash">
    <description>Creates a wrapper object around a Flash movie.  Wrapper object will
	insert the movie reference in node; when the browser first starts
	grabbing the movie, onReady will be fired; when the movie has finished
	loading, it will fire onLoad.
	If your movie uses ExternalInterface, you should use the onLoad event
	to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
	to be the only consistent time calling EI methods are stable (since the
	Flash movie will shoot several methods into the window object before
	EI callbacks can be used properly).
	*Important note*:  this code includes a workaround for the Eolas "fix" from
	Microsoft; in order to work around the "click to activate this control" message
	on any embedded Flash movie, this code will load a separate, non-dojo.require
	javascript file in order to write the Flash movie into the document.  As such
	it cannot be used with Dojo's scope map techniques for working with multiple
	versions of Dojo on the same page.</description>
    <methods>
      <method name="onInitialize" scope="instance"/>
      <method name="__ie_markup__" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="proxy" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.embed.Flash" usage="required"/>
          <parameter name="methods" type="Array|String" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onload" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="byId" scope="instance">
        <description>Probably includes methods for outdated
	browsers, but this should catch all cases.
	arguments:</description>
        <parameters>
          <parameter name="movieName" type="String" usage="required"/>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="minSupported" scope="instance" type="Number"/>
      <property name="available" scope="instance" type="Number"/>
      <property name="supported" scope="instance" type="Boolean"/>
      <property name="minimumRequired" scope="instance" type="Object"/>
      <property name="version" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="Boolean"/>
      <property name="minimumVersion" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="movie" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed"/>
  <class type="dojox.embed.Flash.init">
    <methods/>
    <properties>
      <property name="_poller" scope="instance" type="Object"/>
      <property name="_pollCount" scope="instance" type="Number"/>
      <property name="_pollMax" scope="instance" type="Number"/>
      <property name="pollTime" scope="instance" type="Number"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Flash._destroy">
    <methods/>
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="movie" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.__flashArgs">
    <methods/>
    <properties>
      <property name="id" scope="instance" type="String"/>
      <property name="path" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="minimumVersion" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="String"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="vars" scope="instance" type="Object"/>
      <property name="expressInstall" scope="instance" type="Boolean"/>
      <property name="redirect" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.embed.Object" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="src" scope="instance" type="String"/>
      <property name="movie" scope="instance" type="HTMLEmbed"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="reFlash" scope="instance" type="RegExp"/>
      <property name="reQtMovie" scope="instance" type="RegExp"/>
      <property name="reQtAudio" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.embed.Object.domNode"/>
  <class type="dojox.embed.Object.domNode.attributes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Quicktime">
    <methods>
      <method name="onInitialize" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="QuickTimeObject"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="minSupported" scope="instance" type="Number"/>
      <property name="available" scope="instance" type="Boolean"/>
      <property name="supported" scope="instance" type="Boolean"/>
      <property name="version" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojox.embed.__QTArgs">
    <methods/>
    <properties>
      <property name="id" scope="instance" type="String"/>
      <property name="path" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="redirect" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.embed.flashVars">
    <description>JSON could be done, but Deft does not yet have a JSON parser, and quotes are
	very problematic since Flash cannot use eval(); JSON parsing was successful
	when it was fully escaped, but that made it very large anyway. flashvar
	serialization at most is 200% larger than JSON.
	See:
	Deft/common/flashVars.as</description>
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="n" type="String" usage="required"/>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding">
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.ascii85">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Array:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="String:" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.base64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="ba" type="byte[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="byte[]"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.bits"/>
  <class type="dojox.encoding.bits.OutputStream">
    <methods>
      <method name="getWidth" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.encoding.bits.OutputStream.reset">
    <methods/>
    <properties>
      <property name="buffer" scope="instance" type="Array"/>
      <property name="accumulator" scope="instance" type="Number"/>
      <property name="available" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.OutputStream.putBits">
    <methods/>
    <properties>
      <property name="accumulator" scope="instance" type="Number"/>
      <property name="available" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.OutputStream.getBuffer">
    <methods/>
    <properties>
      <property name="buffer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.InputStream">
    <methods>
      <method name="getWidth" scope="instance"/>
    </methods>
    <properties>
      <property name="buffer" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="bbyte" scope="instance" type="Number"/>
      <property name="bit" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.InputStream.getBits">
    <methods/>
    <properties>
      <property name="bit" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw"/>
  <class type="dojox.encoding.compression.lzw.Encoder">
    <methods/>
    <properties>
      <property name="size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.init">
    <methods/>
    <properties>
      <property name="dict" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="code" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.encode">
    <methods/>
    <properties>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.flush">
    <methods/>
    <properties>
      <property name="p" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder">
    <methods/>
    <properties>
      <property name="size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder.init">
    <methods/>
    <properties>
      <property name="codes" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder.decode">
    <methods/>
    <properties>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression">
    <properties>
      <property name="splay" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.Splay">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="splay" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="up" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto">
    <properties>
      <property name="Blowfish" scope="instance" type="Object"/>
      <property name="RSAKey-ext" scope="instance" type="Object"/>
      <property name="SimpleAES" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.RSAKey">
    <methods>
      <method name="decrypt" scope="instance">
        <parameters>
          <parameter name="ctext" type="String:" usage="required"/>
        </parameters>
        <return-description>a plain string.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rngf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPublic" scope="instance">
        <parameters>
          <parameter name="N" type="Object" usage="required"/>
          <parameter name="E" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encrypt" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="n" scope="instance-prototype" type="Object"/>
      <property name="e" scope="instance-prototype" type="Number"/>
      <property name="rngf" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.RSAKey.setPrivate">
    <methods/>
    <properties>
      <property name="n" scope="instance" type="Object"/>
      <property name="e" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.RSAKey.setPrivateEx">
    <methods/>
    <properties>
      <property name="n" scope="instance" type="Object"/>
      <property name="e" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.RSAKey.generate">
    <methods/>
    <properties>
      <property name="e" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="n" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.BigInteger">
    <methods/>
    <properties>
      <property name="_nbi" scope="instance" type="Object"/>
      <property name="_nbv" scope="instance" type="Object"/>
      <property name="_nbits" scope="instance" type="Object"/>
      <property name="_Montgomery" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.random">
    <methods>
      <method name="prng4" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.math.random.Simple">
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="nextBytes" scope="instance">
        <parameters>
          <parameter name="byteArray" type="Array" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.crypto.cipherModes">
    <properties>
      <property name="ECB" scope="instance" type="Number"/>
      <property name="CBC" scope="instance" type="Number"/>
      <property name="PCBC" scope="instance" type="Number"/>
      <property name="CFB" scope="instance" type="Number"/>
      <property name="OFB" scope="instance" type="Number"/>
      <property name="CTR" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.outputTypes">
    <properties>
      <property name="Base64" scope="instance" type="Number"/>
      <property name="Hex" scope="instance" type="Number"/>
      <property name="String" scope="instance" type="Number"/>
      <property name="Raw" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.digests">
    <methods>
      <method name="addWords" scope="instance">
        <parameters>
          <parameter name="a" type="word" usage="required"/>
          <parameter name="b" type="word" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="word"/>
        </return-types>
      </method>
      <method name="stringToWord" scope="instance">
        <parameters>
          <parameter name="s" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="word[]"/>
        </return-types>
      </method>
      <method name="wordToString" scope="instance">
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToHex" scope="instance">
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToBase64" scope="instance">
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.digests.MD5">
    <methods>
      <method name="_hmac" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="word[]"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.digests.SHA1">
    <methods>
      <method name="_hmac" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="word[]"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.digests.outputTypes">
    <properties>
      <property name="Base64" scope="instance" type="Number"/>
      <property name="Hex" scope="instance" type="Number"/>
      <property name="String" scope="instance" type="Number"/>
      <property name="Raw" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.easy64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Array:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="String:" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash">
    <description>The goal of dojox.flash is to make it easy to extend Flash's capabilities
	into an Ajax/DHTML environment.
	dojox.flash provides an easy object for interacting with the Flash plugin.
	This object provides methods to determine the current version of the Flash
	plugin (dojox.flash.info); write out the necessary markup to
	dynamically insert a Flash object into the page (dojox.flash.Embed; and
	do dynamic installation and upgrading of the current Flash plugin in
	use (dojox.flash.Install). If you want to call methods on the Flash object
	embedded into the page it is your responsibility to use Flash's ExternalInterface
	API and get a reference to the Flash object yourself.
	To use dojox.flash, you must first wait until Flash is finished loading
	and initializing before you attempt communication or interaction.
	To know when Flash is finished use dojo.connect:
		dojo.connect(dojox.flash, "loaded", myInstance, "myCallback");
	Then, while the page is still loading provide the file name:
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"));
	If no SWF files are specified, then Flash is not initialized.
	Your Flash must use Flash's ExternalInterface to expose Flash methods and
	to call JavaScript.
	setSwf can take an optional 'visible' attribute to control whether
	the Flash object is visible or not on the page; the default is visible:
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"),
	false);
	Once finished, you can query Flash version information:
		dojox.flash.info.version
	Or can communicate with Flash methods that were exposed:
		var f = dojox.flash.get();
		var results = f.sayHello("Some Message");
	Your Flash files should use DojoExternalInterface.as to register methods;
	this file wraps Flash's normal ExternalInterface but correct various
	serialization bugs that ExternalInterface has.
	Note that dojox.flash is not meant to be a generic Flash embedding
	mechanism; it is as generic as necessary to make Dojo Storage's
	Flash Storage Provider as clean and modular as possible. If you want
	a generic Flash embed mechanism see [SWFObject](http://blog.deconcept.com/swfobject/).
	Notes:
	Note that dojox.flash can currently only work with one Flash object
	on the page; it does not yet support multiple Flash objects on
	the same page.
	Your code can detect whether the Flash player is installing or having
	its version revved in two ways. First, if dojox.flash detects that
	Flash installation needs to occur, it sets dojox.flash.info.installing
	to true. Second, you can detect if installation is necessary with the
	following callback:
		dojo.connect(dojox.flash, "installing", myInstance, "myCallback");
	You can use this callback to delay further actions that might need Flash;
	when installation is finished the full page will be refreshed and the
	user will be placed back on your page with Flash installed.
	-------------------
	Todo/Known Issues
	-------------------
	* On Internet Explorer, after doing a basic install, the page is
	not refreshed or does not detect that Flash is now available. The way
	to fix this is to create a custom small Flash file that is pointed to
	during installation; when it is finished loading, it does a callback
	that says that Flash installation is complete on IE, and we can proceed
	to initialize the dojox.flash subsystem.
	* Things aren't super tested for sending complex objects to Flash
	methods, since Dojo Storage only needs strings
	Author- Brad Neuberg, http://codinginparadise.org</description>
    <methods>
      <method name="addLoadedListener" scope="instance">
        <parameters>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="addInstallingListener" scope="instance">
        <parameters>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="loaded" scope="instance">
        <description>A callback when the Flash subsystem is finished loading and can be
	worked with. To be notified when Flash is finished loading, add a
	loaded listener:
	dojox.flash.addLoadedListener(loadedListener);</description>
      </method>
      <method name="installing" scope="instance">
        <description>A callback to know if Flash is currently being installed or
	having its version revved. To be notified if Flash is installing, connect
	your callback to this method using the following:
	dojo.event.connect(dojox.flash, "installing", myInstance, "myCallback");</description>
      </method>
      <method name="_initialize" scope="instance"/>
    </methods>
    <properties>
      <property name="ready" scope="instance" type="bool"/>
      <property name="url" scope="instance" type="Object"/>
      <property name="_visible" scope="instance" type="Object"/>
      <property name="_loadedListeners" scope="instance" type="Array"/>
      <property name="_installingListeners" scope="instance" type="Array"/>
      <property name="info" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.setSwf">
    <methods/>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="_visible" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Info">
    <description>A class that helps us determine whether Flash is available,
	it's major and minor versions, and what Flash version features should
	be used for Flash/JavaScript communication. Parts of this code
	are adapted from the automatic Flash plugin detection code autogenerated
	by the Macromedia Flash 8 authoring environment.
	An instance of this class can be accessed on dojox.flash.info after
	the page is finished loading.</description>
    <methods>
      <method name="isVersionOrAbove" scope="instance">
        <description>Asserts that this environment has the given major, minor, and revision
	numbers for the Flash player.
	Example- To test for Flash Player 7r14:
	dojox.flash.info.isVersionOrAbove(7, 0, 14)</description>
        <parameters>
          <parameter name="reqMajorVer" type="int" usage="required"/>
          <parameter name="reqMinorVer" type="int" usage="required"/>
          <parameter name="reqVer" type="int" usage="required"/>
        </parameters>
        <return-description>Returns true if the player is equal
	or above the given version, false otherwise.</return-description>
      </method>
      <method name="_JSFlashInfo" scope="instance">
        <parameters>
          <parameter name="testVersion" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="version" scope="instance" type="String"/>
      <property name="versionMajor" scope="instance" type="Number"/>
      <property name="versionMinor" scope="instance" type="Number"/>
      <property name="versionRevision" scope="instance" type="Number"/>
      <property name="capable" scope="instance" type="Boolean"/>
      <property name="installing" scope="instance" type="Boolean"/>
    </properties>
  </class>
  <class type="dojox.flash.Info._detectVersion">
    <methods/>
    <properties>
      <property name="capable" scope="instance" type="Object"/>
      <property name="versionMajor" scope="instance" type="Object"/>
      <property name="versionMinor" scope="instance" type="Object"/>
      <property name="versionRevision" scope="instance" type="Object"/>
      <property name="version" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Embed">
    <description>Writes out the necessary tags to embed a Flash file into the page. Note that
	these tags are written out as the page is loaded using document.write, so
	you must call this class before the page has finished loading.</description>
    <methods>
      <method name="protocol" scope="instance"/>
      <method name="write" scope="instance">
        <description>This must be called before the page
	is finished loading.</description>
        <parameters>
          <parameter name="doExpressInstall" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance"/>
      <method name="setVisible" scope="instance">
        <parameters>
          <parameter name="visible" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_visible" scope="instance-prototype" type="Object"/>
      <property name="width" scope="instance" type="int"/>
      <property name="height" scope="instance" type="int"/>
      <property name="id" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.flash.Embed.center">
    <methods/>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Communicator">
    <description>This class helps mediate Flash and JavaScript communication. Internally
	it uses Flash 8's ExternalInterface API, but adds functionality to fix
	various encoding bugs that ExternalInterface has.</description>
    <methods>
      <method name="_addExternalInterfaceCallback" scope="instance">
        <parameters>
          <parameter name="methodName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encodeData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decodeData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execFlash" scope="instance">
        <parameters>
          <parameter name="methodName" type="Object" usage="required"/>
          <parameter name="methodArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash.Install">
    <description>Figures out the best way to automatically install the Flash plugin
	for this browser and platform. Also determines if installation or
	revving of the current plugin is needed on this platform.</description>
    <methods>
      <method name="needed" scope="instance"/>
      <method name="install" scope="instance"/>
      <method name="_onInstallStatus" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form">
    <methods>
      <method name="addUploaderPlugin" scope="instance">
        <parameters>
          <parameter name="plug" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="DropDownSelect" scope="instance" type="Object"/>
      <property name="RangeSlider" scope="instance" type="Object"/>
      <property name="UploaderOrg" scope="instance" type="Object"/>
      <property name="_FormSelectWidget" scope="instance" type="Object"/>
      <property name="_HasDropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._BusyButtonMixin">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="makeBusy" scope="instance"/>
      <method name="cancel" scope="instance"/>
      <method name="resetTimeout" scope="instance">
        <parameters>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="isBusy" scope="instance" type="bool"/>
      <property name="busyLabel" scope="instance" type="String"/>
      <property name="timeout" scope="instance" type="Object"/>
      <property name="useIcon" scope="instance" type="Object"/>
      <property name="_label" scope="instance" type="Object"/>
      <property name="_initTimeout" scope="instance" type="Object"/>
      <property name="_timeout" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._BusyButtonMixin.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._BusyButtonMixin.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.BusyButton" superclass="dijit.form.Button">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dojox.form._BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.BusyComboButton" superclass="dijit.form.ComboButton">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboButton" scope="instance"/>
      <mixin type="dojox.form._BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.BusyDropDownButton" superclass="dijit.form.DropDownButton">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.DropDownButton" scope="instance"/>
      <mixin type="dojox.form._BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_changeBox" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateBox" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="boolean"/>
      <property name="readOnly" scope="instance" type="boolean"/>
      <property name="_type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem.option">
    <properties>
      <property name="disabled" scope="instance" type="bool"/>
      <property name="selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem.labelNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.CheckedMultiSelect" superclass="dijit.form._FormSelectWidget">
    <methods>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="instance"/>
      <method name="validate" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterAddOptionItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_updateSelection" scope="instance"/>
      <method name="_getChildren" scope="instance"/>
      <method name="invertSelection" scope="instance">
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormSelectWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="required" scope="instance" type="Boolean"/>
      <property name="invalidMessage" scope="instance" type="String"/>
      <property name="_message" scope="instance" type="String"/>
      <property name="tooltipPosition" scope="instance" type="String[]"/>
      <property name="readOnly" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DateTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods>
      <method name="openDropDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="instance" type="String"/>
      <property name="_selector" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.DayTextBox" superclass="dojox.form.DateTextBox">
    <methods>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="displayVal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.DayTextBox.dropDown">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox" superclass="dojox.form.DateTextBox">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="instance" type="String"/>
      <property name="selector" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox.constraints">
    <properties>
      <property name="datePattern" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox.dropDown">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.YearTextBox" superclass="dojox.form.DateTextBox">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.YearTextBox.dropDown">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DropDownStack" superclass="dijit.form.Select">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._SelectStackMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Select" scope="instance"/>
      <mixin type="dojox.form._SelectStackMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.FileInput" superclass="dijit.form._FormWidget">
    <description>A input type="file" form widget, with a button for uploading to be styled via css,
	a cancel button to clear selection, and FormWidget mixin to provide standard dijit.form.Form
	support (FIXME: maybe not fully implemented)</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_matchValue" scope="instance"/>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="cssClass" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String"/>
      <property name="cancelText" scope="instance" type="String"/>
      <property name="name" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_listener" scope="instance" type="Object"/>
      <property name="_keyListener" scope="instance" type="Object"/>
      <property name="fileInput" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.inputNode">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.cancelNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto" superclass="dojox.form.FileInput">
    <description>An extended version of FileInput - when the user focuses away from the input
	the selected file is posted via dojo.io.iframe to the url. example implementation
	comes with PHP solution for handling upload, and returning required data.
	notes: the return data from the io.iframe is used to populate the input element with
	data regarding the results. it will be a JSON object, like:
	results = { size: "1024", filename: "file.txt" }
	all the parameters allowed to dojox.form.FileInput apply</description>
    <methods>
      <method name="onBeforeSend" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_onFocus" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="setMessage" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_sendFile" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleSend" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="data" type="the" usage="required"/>
          <parameter name="ioArgs" type="the" usage="required"/>
          <parameter name="widgetRef" type="this" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.FileInput" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="blurDelay" scope="instance" type="Integer"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="uploadMessage" scope="instance" type="String"/>
      <property name="triggerEvent" scope="instance" type="String"/>
      <property name="_sent" scope="instance" type="bool"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_blurListener" scope="instance" type="Object"/>
      <property name="_focusListener" scope="instance" type="Object"/>
      <property name="_blurTimer" scope="instance" type="Object"/>
      <property name="_sending" scope="instance" type="bool"/>
      <property name="fileInput" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.overlay.style">
    <properties>
      <property name="backgroundImage" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.fileInput.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.fakeNodeHolder.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputBlind" superclass="dojox.form.FileInputAuto">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_fixPosition" scope="instance"/>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.FileInputAuto" scope="instance"/>
    </mixins>
    <properties>
      <property name="_off" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputBlind.inputNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="string" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="fromWidget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onWidgetChange" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="openDropDown" scope="instance"/>
      <method name="toggleDropDown" scope="instance"/>
      <method name="_focusBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_setBlurValue" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearchFromInput" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="searchDelay" scope="instance" type="Integer"/>
      <property name="valueItem" scope="instance" type="item"/>
      <property name="numPanes" scope="instance" type="number"/>
      <property name="_skip" scope="instance" type="Object"/>
      <property name="_hasValidPath" scope="instance" type="bool"/>
      <property name="_menuFocus" scope="instance" type="Object"/>
      <property name="_allowBlur" scope="instance" type="Object"/>
      <property name="_settingBlurValue" scope="instance" type="Object"/>
      <property name="_hasSelection" scope="instance" type="bool"/>
      <property name="_searchTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox.focusNode">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox.dropDown.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox.dropDown">
    <properties>
      <property name="topDir" scope="instance" type="Object"/>
      <property name="pathSeparator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader" superclass="dijit._Widget">
    <description>If the correct version of Flash Player is available (&gt; 9.0) , a SWF
	is used. If Flash Player is not installed or is outdated, a typical
	html fileInput is used. This process can be overridden with</description>
    <methods>
      <method name="flashMovie" scope="instance"/>
      <method name="log" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="getHiddenWidget" scope="instance"/>
      <method name="getHiddenNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getButtonStyle" scope="instance"/>
      <method name="setButtonStyle" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onProgress" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evtObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="submit" scope="instance">
        <parameters>
          <parameter name="form" type="form" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeFile" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="noListEdit" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_displayProgress" scope="instance">
        <parameters>
          <parameter name="display" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_animateProgress" scope="instance"/>
      <method name="_error" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addToFileList" scope="instance"/>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_complete" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisabledAttr" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFlashBlur" scope="instance"/>
      <method name="_disconnect" scope="instance"/>
      <method name="uploadHTML" scope="instance"/>
      <method name="createHtmlUploader" scope="instance"/>
      <method name="_connectInput" scope="instance"/>
      <method name="_checkHtmlCancel" scope="instance">
        <parameters>
          <parameter name="mouseType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_styleContent" scope="instance"/>
      <method name="_resetHTML" scope="instance"/>
      <method name="_buildForm" scope="instance"/>
      <method name="_buildFileInput" scope="instance"/>
      <method name="_renumberInputs" scope="instance"/>
      <method name="_setFormStyle" scope="instance"/>
      <method name="_setHtmlPostData" scope="instance"/>
      <method name="uploadFlash" scope="instance"/>
      <method name="createFlashUploader" scope="instance"/>
      <method name="_connectFlash" scope="instance">
        <description>Sacrificing some readbilty for compactness. this.id
	will be on the beginning of the topic, so more than
	one uploader can be on a page and can have unique calls.</description>
      </method>
      <method name="_doSub" scope="instance">
        <parameters>
          <parameter name="subStr" type="Object" usage="required"/>
          <parameter name="funcStr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlencode" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isButton" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTempNodeStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="_class" type="Object" usage="required"/>
          <parameter name="isDijitButton" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="swfPath" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="uploadUrl" scope="instance" type="String"/>
      <property name="isDebug" scope="instance" type="Boolean"/>
      <property name="devMode" scope="instance" type="Boolean."/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="hoverClass" scope="instance" type="String"/>
      <property name="activeClass" scope="instance" type="String"/>
      <property name="disabledClass" scope="instance" type="String"/>
      <property name="force" scope="instance" type="String"/>
      <property name="uploaderType" scope="instance" type="String"/>
      <property name="deferredUploading" scope="instance" type="Number"/>
      <property name="fileListId" scope="instance" type="String"/>
      <property name="uploadOnChange" scope="instance" type="Boolean"/>
      <property name="selectMultipleFiles" scope="instance" type="Boolean"/>
      <property name="htmlFieldName" scope="instance" type="String"/>
      <property name="flashFieldName" scope="instance" type="String"/>
      <property name="fileMask" scope="instance" type="Array["/>
      <property name="minFlashVersion" scope="instance" type="Number"/>
      <property name="tabIndex" scope="instance" type="Number|String"/>
      <property name="showProgress" scope="instance" type="Boolean"/>
      <property name="progressMessage" scope="instance" type="String"/>
      <property name="progressBackgroundUrl" scope="instance" type="String|Uri"/>
      <property name="progressBackgroundColor" scope="instance" type="String|Number"/>
      <property name="progressWidgetId" scope="instance" type="String"/>
      <property name="skipServerCheck" scope="instance" type="Boolean"/>
      <property name="serverTimeout" scope="instance" type="Number"/>
      <property name="fileList" scope="instance" type="Array"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="fileInputs" scope="instance" type="Array"/>
      <property name="fileCount" scope="instance" type="Number"/>
      <property name="flashReady" scope="instance" type="bool"/>
      <property name="_disabled" scope="instance" type="bool"/>
      <property name="_refNode" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_hiddenNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="pressClass" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="over" scope="instance" type="Object"/>
      <property name="down" scope="instance" type="Object"/>
      <property name="dsbl" scope="instance" type="Object"/>
      <property name="restoreProgDisplay" scope="instance" type="String"/>
      <property name="postData" scope="instance" type="Object"/>
      <property name="nextFocusObject" scope="instance" type="Object"/>
      <property name="dialogIsOpen" scope="instance" type="bool"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_subs" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.norm">
    <properties>
      <property name="lh" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.progTextNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.insideNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.fhtml"/>
  <class type="dojox.form.FileUploader._formNode">
    <properties>
      <property name="encoding" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader._fileInput">
    <properties>
      <property name="id" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.fhtml.nr">
    <properties>
      <property name="w" scope="instance" type="Object"/>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.flashObject">
    <properties>
      <property name="onError" scope="instance" type="Object"/>
      <property name="onReady" scope="instance" type="Object"/>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.ListInput" superclass="dijit.form._FormValueWidget">
    <description>you can add value to list with add method.
	you can only remove by clicking close button</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setReadOnlyInputAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyItemAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_createInputBox" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="Array" usage="required"/>
          <parameter name="val2" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="values" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyWhenMaxItemsReached" scope="instance"/>
      <method name="_setSelectNode" scope="instance"/>
      <method name="_placeItem" scope="instance">
        <parameters>
          <parameter name="node" type="domNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getCursorPos" scope="instance">
        <parameters>
          <parameter name="node" type="domNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClose" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemKeyDown" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_editBefore" scope="instance">
        <parameters>
          <parameter name="item" type="widget" usage="required"/>
        </parameters>
      </method>
      <method name="_editAfter" scope="instance">
        <parameters>
          <parameter name="item" type="widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemEdit" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_testItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_parseValue" scope="instance">
        <parameters>
          <parameter name="newValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandler" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusInput" scope="instance"/>
      <method name="_inputOnKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_inputOnBlur" scope="instance"/>
      <method name="_getMatchedValueAttr" scope="instance"/>
      <method name="_getMismatchedValueAttr" scope="instance"/>
      <method name="_getValues" scope="instance">
        <parameters>
          <parameter name="validator" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="_nullValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_matchValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_mismatchValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getLastItemAttr" scope="instance"/>
      <method name="_getSomeItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getPreviousItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="updateValue" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_updateValues" scope="instance"/>
      <method name="_destroyAllItems" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputClass" scope="instance" type="String"/>
      <property name="inputHandler" scope="instance" type="String"/>
      <property name="submitOnlyValidValue" scope="instance" type="Boolean"/>
      <property name="useOnBlur" scope="instance" type="Boolean"/>
      <property name="readOnlyInput" scope="instance" type="Boolean"/>
      <property name="maxItems" scope="instance" type="Int"/>
      <property name="showCloseButtonWhenValid" scope="instance" type="Boolean"/>
      <property name="showCloseButtonWhenInvalid" scope="instance" type="Boolean"/>
      <property name="regExp" scope="instance-prototype" type="String"/>
      <property name="delimiter" scope="instance-prototype" type="String"/>
      <property name="constraints" scope="instance" type="dijit.form.ValidationTextBox.__Constraints"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="useAnim" scope="instance" type="Boolean"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="easingIn" scope="instance" type="function"/>
      <property name="easingOut" scope="instance" type="function"/>
      <property name="readOnlyItem" scope="instance" type="Boolean"/>
      <property name="useArrowForEdit" scope="instance" type="Boolean"/>
      <property name="_items" scope="instance-prototype" type="Array"/>
      <property name="_currentItem" scope="instance" type="Widget"/>
      <property name="_input" scope="instance" type="Widget"/>
      <property name="_count" scope="instance" type="Int"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.ListInput.inputProperties">
    <properties>
      <property name="minWidth" scope="instance" type="Number"/>
      <property name="regExp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.ListInput._lastAddedItem">
    <properties>
      <property name="onClose" scope="instance" type="Object"/>
      <property name="onChange" scope="instance" type="Object"/>
      <property name="onEdit" scope="instance" type="Object"/>
      <property name="onKeyDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.ListInput._selectNode.options">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputItem" superclass="dijit._Widget">
    <description>Simple &lt;li&gt; with close button added to ListInputInput when delimiter is found</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setReadOnlyItemAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_createInlineEditBox" scope="instance"/>
      <method name="edit" scope="instance"/>
      <method name="_onCloseEdit" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onEdit" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_onCloseEnter" scope="instance"/>
      <method name="_onCloseLeave" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onEdit" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="closeButtonNode" scope="instance" type="domNode"/>
      <property name="readOnlyItem" scope="instance" type="Boolean"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
      <property name="regExp" scope="instance" type="String"/>
      <property name="_editBox" scope="instance" type="Widget"/>
      <property name="_handleKeyDown" scope="instance" type="handle"/>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputItem.attributeMap"/>
  <class type="dojox.form._ListInputInputItem.attributeMap.value">
    <properties>
      <property name="node" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputBox" superclass="dijit.form.ValidationTextBox">
    <description>Auto sized textbox based on dijit.form.TextBox</description>
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="minWidth" scope="instance" type="Integer"/>
      <property name="intermediateChanges" scope="instance" type="Boolean"/>
      <property name="regExp" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputBox._sizer">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.Manager" superclass="dijit._Widget">
    <description>This widget hosts dojox.form.manager mixins.
	See dojox.form.manager._Mixin for more info.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="destroyRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.manager._Mixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._NodeMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._FormMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._ValueMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._EnableMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._DisplayMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._ClassMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dojox.form.manager._Mixin" scope="instance"/>
      <mixin type="dojox.form.manager._NodeMixin" scope="instance"/>
      <mixin type="dojox.form.manager._FormMixin" scope="instance"/>
      <mixin type="dojox.form.manager._ValueMixin" scope="instance"/>
      <mixin type="dojox.form.manager._EnableMixin" scope="instance"/>
      <mixin type="dojox.form.manager._DisplayMixin" scope="instance"/>
      <mixin type="dojox.form.manager._ClassMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_attachPoints" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.form.MultiComboBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addPreviousMatches" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cleanupDelimiters" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_autoCompleteText" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearch" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="delimiter" scope="instance" type="String"/>
      <property name="_previousMatches" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._ChildTextBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onChildKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerWidget" scope="instance" type="widget"/>
      <property name="type" scope="instance" type="string"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.form._OldPWBox" superclass="dojox.form._ChildTextBox">
    <methods>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="newVal" type="anything" usage="required"/>
          <parameter name="priority" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setBlurValue" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form._ChildTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="_isPWValid" scope="instance" type="boolean"/>
    </properties>
  </class>
  <class type="dojox.form._NewPWBox" superclass="dojox.form._ChildTextBox">
    <methods>
      <method name="onChange" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form._ChildTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="boolean"/>
    </properties>
  </class>
  <class type="dojox.form._VerifyPWBox" superclass="dojox.form._ChildTextBox">
    <methods>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form._ChildTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.PasswordValidator" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_createSubWidgets" scope="instance"/>
      <method name="pwCheck" scope="instance">
        <parameters>
          <parameter name="password" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_childValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttribute" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="focus" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="boolean"/>
      <property name="_inputWidgets" scope="instance" type="Array"/>
      <property name="oldName" scope="instance" type="string"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.RadioStack" superclass="dojox.form.CheckedMultiSelect">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._SelectStackMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.form.CheckedMultiSelect" scope="instance"/>
      <mixin type="dojox.form._SelectStackMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._RangeSliderMixin">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClickMax" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="instance"/>
      <method name="_bumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="useMaxValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="useMaxValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRemainingBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
          <parameter name="isMaxVal" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueByPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Array" usage="required"/>
          <parameter name="priorityChange" type="Boolean," usage="required"/>
          <parameter name="isMaxVal" type="Boolean," usage="required"/>
        </parameters>
      </method>
      <method name="_printSliderBar" scope="instance">
        <parameters>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="isMaxVal" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="value" scope="instance" type="Object"/>
      <property name="_movableMax" scope="instance" type="Object"/>
      <property name="_movableBar" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form._RangeSliderMixin.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SliderMoverMax" superclass="dijit.form._SliderMover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._SliderMover" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._SliderMoverMax.widget">
    <properties>
      <property name="_abspos" scope="instance" type="Object"/>
      <property name="_setPixelValue_" scope="instance" type="Object"/>
      <property name="_isReversed_" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SliderBarMover" superclass="dojo.dnd.Mover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Mover" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._SliderBarMover.widget">
    <properties>
      <property name="_abspos" scope="instance" type="Object"/>
      <property name="_setPixelValue_" scope="instance" type="Object"/>
      <property name="_getValueByPixelValue_" scope="instance" type="Object"/>
      <property name="_isReversed_" scope="instance" type="Object"/>
      <property name="_bar" scope="instance" type="Object"/>
      <property name="_mouseOffset" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.HorizontalRangeSlider" superclass="dijit.form.HorizontalSlider">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._RangeSliderMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalSlider" scope="instance"/>
      <mixin type="dojox.form._RangeSliderMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.VerticalRangeSlider" superclass="dijit.form.VerticalSlider">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._RangeSliderMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.VerticalSlider" scope="instance"/>
      <mixin type="dojox.form._RangeSliderMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.Rating" superclass="dijit.form._FormWidget">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStars" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="hover" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStarClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance"/>
      <method name="setAttribute" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance-prototype" type="Object"/>
      <property name="numStars" scope="instance" type="Integer/Float"/>
      <property name="value" scope="instance" type="Integer/Float"/>
    </properties>
  </class>
  <class type="dojox.form.TimeSpinner" superclass="dijit.form._Spinner">
    <description>This widget is the same as a normal NumberSpinner, but for the time component of a date object instead</description>
    <methods>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._Spinner" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="bool"/>
      <property name="smallDelta" scope="instance" type="Number"/>
      <property name="largeDelta" scope="instance" type="Number"/>
      <property name="timeoutChangeRate" scope="instance" type="Number"/>
      <property name="serialize" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.Uploader" superclass="dojox.form.uploader.Base">
    <description>A bare-bones, stylable file-input button, with optional multi-file selection. The list
	of files is not displayed, that is for you to handle by connecting to the onChange
	event, or use the dojox.form.uploader.FileList.
	Uploader without plugins does not have any ability to upload - it is for use in forms
	where you handle the upload either by a standard POST or with Ajax using an iFrame. This
	class is for convenience of multiple files only. No progress events are available.
	If the browser supports a file-input with the "multiple" attribute, that will be used.
	If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
	one for each selection.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onBegin" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onProgress" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="onAbort" scope="instance"/>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evtObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="formData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="submit" scope="instance">
        <parameters>
          <parameter name="form" type="form" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="getFileList" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisabledAttr" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getNodePosition" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getButtonStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setButtonStyle" scope="instance"/>
      <method name="_createInput" scope="instance"/>
      <method name="_connectButton" scope="instance"/>
      <method name="_disconnectButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.uploader.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="uploadOnSelect" scope="instance" type="Boolean"/>
      <property name="tabIndex" scope="instance" type="Number|String"/>
      <property name="multiple" scope="instance" type="Boolean"/>
      <property name="label" scope="instance" type="String"/>
      <property name="url" scope="instance" type="String"/>
      <property name="name" scope="instance" type="String"/>
      <property name="flashFieldName" scope="instance" type="String"/>
      <property name="uploadType" scope="instance" type="String"/>
      <property name="_nameIndex" scope="instance" type="Number"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_inputs" scope="instance" type="Array"/>
      <property name="btnSize" scope="instance" type="Object"/>
      <property name="inputNodeFontSize" scope="instance" type="Object"/>
      <property name="_cons" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.form.Uploader.domNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.Uploader.inputNode">
    <properties>
      <property name="tabIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._SelectStackMixin">
    <methods>
      <method name="_paneIdFromOption" scope="instance">
        <parameters>
          <parameter name="oVal" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_optionValFromPane" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_togglePane" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="shown" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_connectTitle" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="name" type="String|Object" usage="required"/>
          <parameter name="value" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onStartup" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_handleSelfOnChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="stackId" scope="instance" type="string"/>
      <property name="stackPrefix" scope="instance" type="string"/>
      <property name="_savedValue" scope="instance" type="Object"/>
      <property name="_panes" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.form.manager">
    <methods>
      <method name="actionAdapter" scope="instance">
        <parameters>
          <parameter name="action" type="Function:" usage="required"/>
        </parameters>
      </method>
      <method name="inspectorAdapter" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function:" usage="required"/>
        </parameters>
      </method>
      <method name="_keys" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changeEvent" scope="instance">
        <parameters>
          <parameter name="node" type="Node:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._ClassMixin">
    <description>This mixin provides unified way to check/add/remove a class
	of controlled elements.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="gatherClassState" scope="instance">
        <parameters>
          <parameter name="className" type="String:" usage="required"/>
          <parameter name="names" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <parameters>
          <parameter name="className" type="String:" usage="required"/>
          <parameter name="names" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeClass" scope="instance">
        <parameters>
          <parameter name="className" type="String:" usage="required"/>
          <parameter name="names" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._DisplayMixin">
    <description>This mixin provides unified show/hide functionality for
	controlled elements (indicated by dojoAttachPoint attribute).
	Essentially it provides a way to change "style.display"
	parameter of controlled nodes.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="gatherDisplayState" scope="instance">
        <parameters>
          <parameter name="names" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="state" type="Object:" usage="optional"/>
          <parameter name="defaultState" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="state" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._EnableMixin">
    <description>This mixin provides unified enable/disable functionality for
	form widgets and form elements. It should be used together
	with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="gatherEnableState" scope="instance">
        <parameters>
          <parameter name="names" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="state" type="Object:" usage="optional"/>
          <parameter name="defaultState" type="Boolean:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="disable" scope="instance">
        <parameters>
          <parameter name="state" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._FormMixin">
    <description>This mixin adds automated "onreset", and "onsubmit" event processing
	if we are based on a form node, defines onReset(), onSubmit(),
	reset(), submit(), and isValid() methods like dijit.form.Form.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_onReset" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReset" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_onSubmit" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSubmit" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="submit" scope="instance"/>
      <method name="isValid" scope="instance"/>
      <method name="validate" scope="instance"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="action" scope="instance" type="String"/>
      <property name="method" scope="instance" type="String"/>
      <property name="encType" scope="instance" type="String"/>
      <property name="accept-charset" scope="instance" type="String"/>
      <property name="accept" scope="instance" type="String"/>
      <property name="target" scope="instance" type="String"/>
      <property name="isForm" scope="instance" type="bool"/>
      <property name="formWidgets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.manager._Mixin">
    <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, general event
	processing, I/O orchestration, and common form-related
	functionality. See additional mixins in dojox.form.manager
	namespace.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="registerWidget" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit.form._FormWidget:" usage="required"/>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterWidget" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="registerWidgetDescendants" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit._Widget:" usage="required"/>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterWidgetDescendants" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit._Widget:" usage="required"/>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="formWidgetValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Object|Array:" usage="required"/>
          <parameter name="value" type="Object:" usage="optional"/>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formPointValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Object|Array:" usage="required"/>
          <parameter name="value" type="Object:" usage="optional"/>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="inspectFormWidgets" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function:" usage="required"/>
          <parameter name="state" type="Object:" usage="optional"/>
          <parameter name="defaultValue" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspectAttachedPoints" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function:" usage="required"/>
          <parameter name="state" type="Object:" usage="optional"/>
          <parameter name="defaultValue" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspect" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function:" usage="required"/>
          <parameter name="state" type="Object:" usage="optional"/>
          <parameter name="defaultValue" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="watching" scope="instance" type="Object"/>
      <property name="formWidgets" scope="instance" type="Object"/>
      <property name="formNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.manager._NodeMixin">
    <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, and general event
	processing. It complements dojox.form.manager._Mixin
	extending the functionality to DOM nodes.</description>
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="registerNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node:" usage="required"/>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterNode" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="registerNodeDescendants" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node:" usage="required"/>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterNodeDescendants" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node:" usage="required"/>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="formNodeValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Node|Array:" usage="required"/>
          <parameter name="value" type="Object:" usage="optional"/>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="inspectFormNodes" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function:" usage="required"/>
          <parameter name="state" type="Object:" usage="optional"/>
          <parameter name="defaultValue" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="formNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.manager._ValueMixin">
    <description>This mixin adds unified access to form widgets and form elements
	in terms of name-value regardless of the underlying type of
	an element. It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="elementValue" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
          <parameter name="value" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="gatherFormValues" scope="instance">
        <parameters>
          <parameter name="names" type="Object:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFormValues" scope="instance">
        <parameters>
          <parameter name="values" type="Object:" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form.uploader"/>
  <class type="dojox.form.uploader.Base" superclass="dijit._Widget">
    <description>Should not be used as a standalone. To be mixed in with other classes.</description>
    <methods>
      <method name="getForm" scope="instance">
        <return-types>
          <return-type type="Node;"/>
        </return-types>
      </method>
      <method name="getUrl" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="connectForm" scope="instance"/>
      <method name="supports" scope="instance">
        <parameters>
          <parameter name="what" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="IE will be undefined"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getMimeType" scope="instance">
        <return-types>
          <return-type type="image/gif"/>
        </return-types>
      </method>
      <method name="getFileType" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="convertBytes" scope="instance">
        <parameters>
          <parameter name="bytes" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="form" scope="instance" type="Object"/>
      <property name="url" scope="instance" type="Object"/>
      <property name="_fcon" scope="instance" type="Object"/>
      <property name="_hascache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.FileList" superclass="dojox.form.uploader.Base">
    <description>There is a required CSS file: resources/UploaderFileList.css.
	This is a very simple widget, and not beautifully styled. It is here mainly for test
	cases, but could very easily be used, extended, modified, or copied.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="setUploader" scope="instance"/>
      <method name="hideProgress" scope="instance">
        <parameters>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="showProgress" scope="instance">
        <parameters>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideShowProgress" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUploaderChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addRow" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.uploader.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="uploaderId" scope="instance" type="String"/>
      <property name="uploader" scope="instance" type="dojox.form.Uploader"/>
      <property name="headerIndex" scope="instance" type="String"/>
      <property name="headerType" scope="instance" type="String"/>
      <property name="headerFilename" scope="instance" type="String"/>
      <property name="headerFilesize" scope="instance" type="String"/>
      <property name="_upCheckCnt" scope="instance" type="Number"/>
      <property name="rowAmt" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="progressNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.FileList.percentTextNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins"/>
  <class type="dojox.form.uploader.plugins.Flash">
    <description>Inherits all properties from dojox.form.Uploader and dojox.form.uploader.plugins.HTML5.
	All properties and methods listed here are specific to the Flash plugin only.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onFileChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFileProgress" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFlashFileList" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="flashReset" scope="instance"/>
      <method name="uploadFlash" scope="instance"/>
      <method name="submitFlash" scope="instance">
        <parameters>
          <parameter name="formParams" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_complete" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_error" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFlashBlur" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCustomEvent" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_connectFlash" scope="instance">
        <description>Sacrificing some readbilty for compactness. this.id
	will be on the beginning of the topic, so more than
	one uploader can be on a page and can have unique calls.</description>
      </method>
      <method name="_createFlashUploader" scope="instance"/>
    </methods>
    <properties>
      <property name="swfPath" scope="instance" type="String"/>
      <property name="skipServerCheck" scope="instance" type="Boolean"/>
      <property name="serverTimeout" scope="instance" type="Number"/>
      <property name="isDebug" scope="instance" type="Boolean"/>
      <property name="devMode" scope="instance" type="Boolean."/>
      <property name="deferredUploading" scope="instance" type="Number"/>
      <property name="force" scope="instance" type="String"/>
      <property name="uploadType" scope="instance" type="String"/>
      <property name="_files" scope="instance" type="Object"/>
      <property name="_fileMap" scope="instance" type="Object"/>
      <property name="_createInput" scope="instance" type="Object"/>
      <property name="getFileList" scope="instance" type="Object"/>
      <property name="reset" scope="instance" type="Object"/>
      <property name="upload" scope="instance" type="Object"/>
      <property name="submit" scope="instance" type="Object"/>
      <property name="fieldname" scope="instance" type="String"/>
      <property name="_subs" scope="instance" type="Array"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="inputNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.Flash.btnSize">
    <properties>
      <property name="w" scope="instance" type="Object"/>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.Flash.flashObject">
    <properties>
      <property name="onError" scope="instance" type="Object"/>
      <property name="onReady" scope="instance" type="Object"/>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.HTML5">
    <description>Add this plugin to have HTML5 capabilities in the Uploader. Note that it does not add
	these capabilities to browsers that don't support them. For IE or older browsers, add
	additional plugins: IFrame or Flash.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="formData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="submit" scope="instance">
        <parameters>
          <parameter name="form" type="form" usage="required"/>
        </parameters>
      </method>
      <method name="sendAsBinary" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uploadWithFormData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xhrProgress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createXhr" scope="instance"/>
      <method name="_buildRequestBody" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="boundary" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="errMsg" scope="instance" type="String"/>
      <property name="uploadType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.IFrame">
    <description>Only supported by IE, due to the specifc iFrame hack used. The
	dojox.form.uploader.plugins.HTML5 plugin should be used along with this to add HTML5
	capabilities to browsers that support them. Progress events are not supported.
	Inherits all properties from dojox.form.Uploader and dojox.form.uploader.plugins.HTML5.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uploadIFrame" scope="instance"/>
    </methods>
    <properties>
      <property name="force" scope="instance" type="String"/>
      <property name="uploadType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.fx">
    <description>A package of animations, and FX-related code, extending Dojo Core fx.
	Including this package includes all the Base and Core fx packages.</description>
    <methods>
      <method name="animateTimeline" scope="instance">
        <description>The Timeline is a replacement for the default dojo._Line.
	Instead of _Line.getValue returning a float between 0-1,
	_Timeline.getValue returns an object with all properties and
	their current values.
	A property does not have to appear in every keyframe.
	As in the example below, "height" is transitioned from the first
	keyframe to the third. "width" is transitioned from the first
	to the second to the third.
	Each keyframe can accept the following custom properties:
	step: String
	The start, finish or percentage that this keyframe represents.
	Allowed parameters are:
	0%-100%
	from (same as 0%, used to conform with the Webkit animation spec)
	to (same as 100%, used to conform with the Webkit animation spec)
	ease: String
	The string name of a dojo.fx.easing ease. Defaults to "linear". Use
	the suffix name of the ease, like: "quadIn", not: "dojo.fx.quadIn".</description>
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="anim" scope="instance"/>
      <method name="animateProperty" scope="instance"/>
      <method name="fadeTo" scope="instance"/>
      <method name="fadeIn" scope="instance"/>
      <method name="fadeOut" scope="instance"/>
      <method name="combine" scope="instance"/>
      <method name="chain" scope="instance"/>
      <method name="slideTo" scope="instance"/>
      <method name="wipeIn" scope="instance"/>
      <method name="wipeOut" scope="instance"/>
      <method name="sizeTo" scope="instance">
        <description>Returns an animation that will size the target node
	defined in args Object about it's center to
	a width and height defined by (args.width, args.height),
	supporting an optional method: chain||combine mixin
	(defaults to chain).
	- works best on absolutely or relatively positioned elements</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="instance">
        <description>Returns an animation that will slide a node (args.node) from it's
	current position to it's current posision plus the numbers defined
	in args.top and args.left. standard dojo.fx mixin's apply.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="crossFade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="highlight" scope="instance">
        <description>Returns an animation that sets the node background to args.color
	then gradually fades back the original node background color</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeTo" scope="instance">
        <description>Returns an animation that will expand the
	node defined in 'args' object from it's current to
	the height or width value given by the args object.
	default to height:, so leave height null and specify width:
	to wipeTo a width. note: this may be deprecated by a
	Note that the final value should not include
	units and should be an integer.  Thus a valid args object
	would look something like this:
		dojox.fx.wipeTo({ node: "nodeId", height: 200 }).play();
	Node must have no margin/border/padding, so put another
	node inside your target node for additional styling.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="flip" scope="instance">
        <description>Returns an animation that will flip the
	node around a central axis:
	if args.dir is "left" or "right" --&gt; y axis
	if args.dir is "top" or "bottom" --&gt; x axis
	This effect is obtained using a border distorsion applied to a helper node.
	The user can specify three background colors for the helper node:
	darkColor: the darkest color reached during the animation
	lightColor: the brightest color
	endColor: the final backgroundColor for the node
	depth: Float
	0 &lt;= depth &lt;= 1 overrides the computed "depth"
	(0: min distorsion, 1: max distorsion)
	whichAnim: String
	"first"          : the first half animation
	"last"           : the second one
	"both" (default) : both
	axis: String
	"center" (default)    : the node is flipped around his center
	"shortside"           : the node is flipped around his "short" (in perspective) side
	"longside"            : the node is flipped around his "long" (in perspective) side
	"cube"                : the node flips around the central axis of the cube
	shift: Integer
	node translation, perpendicular to the rotation axis</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="flipCube" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a more 3d-like rotation.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flipPage" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a page flip effect.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flipGrid" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a page flip effect.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties and
	cols: Integer columns
	rows: Integer rows
	duration: the single flip duration</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="smoothScroll" scope="instance">
        <description>This implementation support either horizontal or vertical scroll, as well as
	both. In addition, element in iframe can be scrolled to correctly.
	offset: {x: int, y: int} this will be added to the target position
	duration: Duration of the animation in milliseconds.
	win: a node or window object to scroll</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_split" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that move independently.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="explode" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that fly away from the center.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="converge" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disintegrate" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that drop.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="build" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shear" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that slide in alternating directions.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="unShear" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pinwheel" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that wipe in alternating directions.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="unPinwheel" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeOut" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that fade in or out.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <description>Creates an animation that will animate
	the properties of a node to the properties
	defined in a standard CSS .class definition.
	(calculating the differences itself)</description>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
          <parameter name="cssClass" type="String" usage="required"/>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="removeClass" scope="instance">
        <description>Creates an animation that will animate the properties of a
	node (args.node) to the properties calculated after removing
	a standard CSS className from a that node.
	calls dojo.removeClass(args.cssClass) onEnd of animation
	standard dojo.Animation object rules apply.</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="toggleClass" scope="instance">
        <description>creates an animation that will animate the effect of
	toggling a class on or off of a node.
	Adds a class to node if not present, or removes if present.
	Pass a boolean condition if you want to explicitly add or remove.</description>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
          <parameter name="cssClass" type="String" usage="required"/>
          <parameter name="condition" type="Boolean" usage="optional"/>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="Timeline" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="_core" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="scroll" scope="instance" type="Object"/>
      <property name="split" scope="instance" type="Object"/>
      <property name="_allowedProperties" scope="instance" type="Array"/>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx.Shadow" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_makePiece" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="vertAttach" type="Object" usage="required"/>
          <parameter name="vertCoord" type="Object" usage="required"/>
          <parameter name="horzAttach" type="Object" usage="required"/>
          <parameter name="horzCoord" type="Object" usage="required"/>
          <parameter name="sizing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpacity" scope="instance">
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
          <parameter name="animArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.fx._arg.ShadowResizeArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="shadowPng" scope="instance" type="String"/>
      <property name="shadowThickness" scope="instance" type="Integer"/>
      <property name="shadowOffset" scope="instance" type="Integer"/>
      <property name="opacity" scope="instance" type="Float"/>
      <property name="animate" scope="instance" type="Boolean"/>
      <property name="node" scope="instance" type="DomNode"/>
      <property name="pieces" scope="instance" type="Object"/>
      <property name="nodeList" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.fx.Shadow.node.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.fx._Timeline">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="p" type="float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="keys" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx._Timeline.flatten">
    <methods/>
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx._arg"/>
  <class type="dojox.fx._arg.StyleArgs">
    <methods/>
    <properties>
      <property name="node" scope="instance" type="DOMNode"/>
      <property name="cssClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.fx._arg.ShadowResizeArgs">
    <methods/>
    <properties>
      <property name="x" scope="instance" type="Integer"/>
      <property name="y" scope="instance" type="Integer"/>
    </properties>
  </class>
  <class type="dojox.fx._Line">
    <description>a normal dojo._Line is the curve, and does Line(start,end)
	for propertyAnimation. as we make more complicatied animations, we realize
	some properties can have 2, or 4 values relevant (x,y) or (t,l,r,b) for example
	this function provides support for those Lines, and is ported directly from 0.4
	this is a lot of extra code for something so seldom used, so we'll put it here as
	and optional core addition. you can create a new line, and use it during onAnimate
	as you see fit.</description>
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="float" usage="required"/>
        </parameters>
        <return-description>Mixed</return-description>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="Integer|Array"/>
      <property name="end" scope="instance" type="Integer|Array"/>
    </properties>
  </class>
  <class type="dojox.fx.ext-dojo">
    <properties>
      <property name="NodeList-style" scope="instance" type="Object"/>
      <property name="NodeList" scope="instance" type="Object"/>
      <property name="complex" scope="instance" type="Object"/>
      <property name="reverse" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx._Complex">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="r" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makePropObject" scope="instance">
        <parameters>
          <parameter name="beg" type="String" usage="required"/>
          <parameter name="end" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getProps" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getNumAndUnits" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="PROP" scope="instance" type="RegExp"/>
      <property name="_properties" scope="instance" type="Object"/>
      <property name="strProp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Animation.reverse">
    <methods/>
    <properties>
      <property name="_reversed" scope="instance" type="bool"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="properties" scope="instance" type="Object"/>
      <property name="_endTime" scope="instance" type="String"/>
      <property name="_startTime" scope="instance" type="Number"/>
      <property name="fEase" scope="instance" type="Object"/>
      <property name="rEase" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Animation.reverse.curve">
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx.text">
    <methods>
      <method name="_split" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that move independently.
	NOTE:
	In some rendering engines, the text will appear to "jump" from its initial position
	when the animation begins.	To work around this bug, enclose the node's text in a &lt;p&gt; or &lt;div&gt;.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="explode" scope="instance">
        <description>Returns an animation that will split the text into a spans
	of words or characters that fly away from the center.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="converge" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disintegrate" scope="instance">
        <description>Returns an animation that will split the text into spans of words
	or characters that drop.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="build" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="blockFadeOut" scope="instance">
        <description>Returns an animation that will split the text into spans of words
	or characters that fade in or out.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="backspace" scope="instance">
        <description>Returns an animation that will split the text into spans of words
	or characters that appear as if they were being backspaced (or typed) in real-time.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="type" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gantt"/>
  <class type="dojox.gantt.GanttChart">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosPreviousTask" scope="instance">
        <parameters>
          <parameter name="predTask" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="correctPosPreviousTask" scope="instance">
        <parameters>
          <parameter name="predTask" type="Object" usage="required"/>
          <parameter name="ctask" type="Object" usage="required"/>
          <parameter name="ctaskObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="correctPosParentTask" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="ctask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosParentTaskInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPreviousTask" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPreviousTaskInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosParentTask" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addProject" scope="instance">
        <parameters>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="startDate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openNode" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastCloseParent" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getProjectItemById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearAll" scope="instance"/>
      <method name="clearEvents" scope="instance"/>
      <method name="clearData" scope="instance"/>
      <method name="clearItems" scope="instance"/>
      <method name="buildUIContent" scope="instance"/>
      <method name="loadJSONData" scope="instance">
        <parameters>
          <parameter name="filename" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadJSONString" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildChildTasksData" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="childTaskItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getJSONData" scope="instance"/>
      <method name="getChildTasksData" scope="instance">
        <parameters>
          <parameter name="childTasks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saveJSONData" scope="instance">
        <parameters>
          <parameter name="fileName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortTaskStartTime" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortProjStartDate" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartTimeChild" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createPanelTasks" scope="instance"/>
      <method name="refreshParams" scope="instance">
        <parameters>
          <parameter name="pixelsPerDay" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createPanelNamesTasksHeader" scope="instance"/>
      <method name="createPanelNamesTasks" scope="instance"/>
      <method name="createPanelTime" scope="instance"/>
      <method name="adjustPanelTime" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addYearInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addMonthInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="month" type="Object" usage="required"/>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addWeekInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="week" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addDayInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addHourInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="incHeightPanelTasks" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="incHeightPanelNames" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosition" scope="instance"/>
      <method name="checkHeighPanelTasks" scope="instance"/>
      <method name="sortTasksByStartTime" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortChildTasks" scope="instance">
        <parameters>
          <parameter name="parenttask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance">
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="current" type="Object" usage="required"/>
          <parameter name="multi" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="switchTeleMicroView" scope="instance">
        <parameters>
          <parameter name="dip" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshController" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="postLoadData" scope="instance"/>
      <method name="postBindEvents" scope="instance"/>
      <method name="getStartDate" scope="instance"/>
      <method name="getCountDays" scope="instance"/>
      <method name="createTasks" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createChildItemControls" scope="instance">
        <parameters>
          <parameter name="arrChildTasks" type="Object" usage="required"/>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPosOnDate" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidthOnDuration" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeCell" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="project" scope="instance-prototype" type="Array"/>
      <property name="contentDataHeight" scope="instance-prototype" type="Number"/>
      <property name="startDate" scope="instance-prototype" type="Object"/>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="arrProjects" scope="instance-prototype" type="Array"/>
      <property name="pixelsPerDay" scope="instance-prototype" type="Number"/>
      <property name="pixelsPerWorkHour" scope="instance-prototype" type="Number"/>
      <property name="pixelsPerHour" scope="instance-prototype" type="Number"/>
      <property name="zoomInClickEvent" scope="instance" type="Object"/>
      <property name="zoomInKeyEvent" scope="instance" type="Object"/>
      <property name="zoomOutClickEvent" scope="instance" type="Object"/>
      <property name="zoomOutKeyEvent" scope="instance" type="Object"/>
      <property name="microClickEvent" scope="instance" type="Object"/>
      <property name="microKeyEvent" scope="instance" type="Object"/>
      <property name="teleClickEvent" scope="instance" type="Object"/>
      <property name="teleKeyEvent" scope="instance" type="Object"/>
      <property name="saveClickEvent" scope="instance" type="Object"/>
      <property name="saveKeyEvent" scope="instance" type="Object"/>
      <property name="loadClickEvent" scope="instance" type="Object"/>
      <property name="loadKeyEvent" scope="instance" type="Object"/>
      <property name="totalDays" scope="instance-prototype" type="Number"/>
      <property name="maxTaskEndPos" scope="instance" type="Object"/>
      <property name="tempDayInPixels" scope="instance-prototype" type="Number"/>
      <property name="tableControl" scope="instance" type="Object"/>
      <property name="countDays" scope="instance-prototype" type="Number"/>
      <property name="panelTime" scope="instance-prototype" type="Object"/>
      <property name="panelNameHeaders" scope="instance" type="Object"/>
      <property name="tabMenu" scope="instance-prototype" type="Object"/>
      <property name="resource" scope="instance-prototype" type="Object"/>
      <property name="panelNameHeadersCover" scope="instance" type="Object"/>
      <property name="initialPos" scope="instance-prototype" type="Number"/>
      <property name="resourceChartHeight" scope="instance" type="Object"/>
      <property name="withResource" scope="instance" type="Object"/>
      <property name="correctError" scope="instance" type="Object"/>
      <property name="isShowConMenu" scope="instance" type="bool"/>
      <property name="isContentEditable" scope="instance" type="bool"/>
      <property name="withTaskId" scope="instance" type="Object"/>
      <property name="animation" scope="instance" type="Object"/>
      <property name="saveProgramPath" scope="instance" type="String"/>
      <property name="dataFilePath" scope="instance" type="String"/>
      <property name="contentHeight" scope="instance" type="Number"/>
      <property name="contentWidth" scope="instance" type="Number"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="scrollBarWidth" scope="instance" type="Number"/>
      <property name="panelTimeHeight" scope="instance" type="Number"/>
      <property name="maxWidthPanelNames" scope="instance" type="Number"/>
      <property name="maxWidthTaskNames" scope="instance" type="Number"/>
      <property name="minWorkLength" scope="instance" type="Number"/>
      <property name="heightTaskItem" scope="instance" type="Number"/>
      <property name="heightTaskItemExtra" scope="instance" type="Number"/>
      <property name="hsPerDay" scope="instance" type="Number"/>
      <property name="panelTimeExpandDelta" scope="instance" type="Number"/>
      <property name="divTimeInfo" scope="instance" type="Object"/>
      <property name="xmlLoader" scope="instance" type="Object"/>
      <property name="isMoving" scope="instance" type="bool"/>
      <property name="isResizing" scope="instance" type="bool"/>
      <property name="animationNodes" scope="instance" type="Array"/>
      <property name="scale" scope="instance" type="Number"/>
      <property name="months" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.firstChild">
    <properties>
      <property name="rows" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.contentData.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.contentData">
    <methods>
      <method name="onscroll" scope="instance"/>
    </methods>
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelNames">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelNames.firstChild.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild"/>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="ganttChart" type="Object" usage="required"/>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkWidthProjectNameItem" scope="instance"/>
      <method name="refreshProjectItem" scope="instance">
        <parameters>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshDescrProject" scope="instance">
        <parameters>
          <parameter name="divDesc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postLoadData" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="getTaskById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="searchTaskInTree" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftProjectItem" scope="instance"/>
      <method name="adjustPanelTime" scope="instance"/>
      <method name="resizeProjectItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftDescrProject" scope="instance"/>
      <method name="showDescrProject" scope="instance"/>
      <method name="hideDescrProject" scope="instance"/>
      <method name="getDescStr" scope="instance"/>
      <method name="createDescrProject" scope="instance"/>
      <method name="createProjectItem" scope="instance"/>
      <method name="createProjectNameItem" scope="instance"/>
      <method name="getPercentCompleted" scope="instance"/>
      <method name="getDuration" scope="instance"/>
      <method name="deleteTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPercentCompleted" scope="instance">
        <parameters>
          <parameter name="percentage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="startTime" type="Object" usage="required"/>
          <parameter name="duration" type="Object" usage="required"/>
          <parameter name="percentage" type="Object" usage="required"/>
          <parameter name="previousTaskId" type="Object" usage="required"/>
          <parameter name="taskOwner" type="Object" usage="required"/>
          <parameter name="parentTaskId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextProject" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftProject" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextParentTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="percentage" scope="instance-prototype" type="Number"/>
      <property name="posX" scope="instance-prototype" type="Number"/>
      <property name="posY" scope="instance-prototype" type="Number"/>
      <property name="duration" scope="instance-prototype" type="Number"/>
      <property name="nextProject" scope="instance" type="Object"/>
      <property name="previousProject" scope="instance" type="Object"/>
      <property name="arrTasks" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectNameItem">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.descrProject.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.ganttChart.contentData">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.ganttChart.panelNames">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.project">
    <properties>
      <property name="startDate" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.0.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.1.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.lastChild.firstChild">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.descrProject">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.0">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.1">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.ganttChart">
    <properties>
      <property name="minWorkLength" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectNameItem.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectItem">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTaskById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTaskByIdInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
      <property name="startDate" scope="instance" type="Object"/>
      <property name="parentTasks" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="ganttchart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearAll" scope="instance"/>
      <method name="clearData" scope="instance"/>
      <method name="clearItems" scope="instance"/>
      <method name="buildResource" scope="instance"/>
      <method name="buildOwnerTimeConsume" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="reConstruct" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="postAdjustment" scope="instance"/>
      <method name="refreshOwnerEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOwnerEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOwnerNameItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshOwnerItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOwnerItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshDetailedTaskEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createDetailedTaskEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="parentNode" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTaskNameItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshTaskItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTaskItem" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createConnectingLinesPN" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Object" usage="required"/>
          <parameter name="currentNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTreeImg" scope="instance">
        <parameters>
          <parameter name="ownerNameItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleOwnerItem" scope="instance">
        <parameters>
          <parameter name="tItem" type="Object" usage="required"/>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="displayType" type="Object" usage="required"/>
          <parameter name="topOffset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkWidthTaskNameItem" scope="instance">
        <parameters>
          <parameter name="taskNameItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createPanelOwners" scope="instance"/>
      <method name="createPanelNamesOwners" scope="instance"/>
    </methods>
    <properties>
      <property name="ownerItem" scope="instance-prototype" type="Array"/>
      <property name="ownerNameItem" scope="instance-prototype" type="Array"/>
      <property name="ownerTaskNodeMapping" scope="instance-prototype" type="Object"/>
      <property name="ownerTaskNodeMapping_time" scope="instance-prototype" type="Object"/>
      <property name="resourceInfo" scope="instance-prototype" type="Object"/>
      <property name="ownerTimeConsume" scope="instance-prototype" type="Object"/>
      <property name="tableControl" scope="instance" type="Object"/>
      <property name="contentHeight" scope="instance" type="Object"/>
      <property name="contentWidth" scope="instance" type="Object"/>
      <property name="panelNames" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="ganttChart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.contentData.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.contentData.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.contentData">
    <methods>
      <method name="onscroll" scope="instance"/>
    </methods>
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.panelNames.firstChild.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="taskInfo" type="Object" usage="required"/>
          <parameter name="project" type="Object" usage="required"/>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createConnectingLinesPN" scope="instance"/>
      <method name="createConnectingLinesDS" scope="instance"/>
      <method name="showChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="isOpen" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hideChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftCurrentTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endMove" scope="instance"/>
      <method name="checkPos" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMaxPosPredChildTaskItem" scope="instance"/>
      <method name="getMaxPosPredChildTaskItemInTree" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveCurrentTaskItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="moveChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveChildTaskItems" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="moveChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustPanelTime" scope="instance"/>
      <method name="getDateOnPosition" scope="instance">
        <parameters>
          <parameter name="position" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveItem" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveTaskItem" scope="instance">
        <parameters>
          <parameter name="posX" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resizeItem" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resizeTaskItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endResizeItem" scope="instance"/>
      <method name="startMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showDescTask" scope="instance"/>
      <method name="hideDescTask" scope="instance"/>
      <method name="buildResourceInfo" scope="instance">
        <parameters>
          <parameter name="resourceInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="objKeyToStr" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="delm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTaskOwner" scope="instance"/>
      <method name="moveDescTask" scope="instance"/>
      <method name="getMoveInfo" scope="instance"/>
      <method name="startResize" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getResizeInfo" scope="instance"/>
      <method name="createTaskItem" scope="instance"/>
      <method name="createTaskNameItem" scope="instance"/>
      <method name="createTaskDescItem" scope="instance"/>
      <method name="checkWidthTaskNameItem" scope="instance"/>
      <method name="refreshTaskItem" scope="instance">
        <parameters>
          <parameter name="itemControl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshTaskDesc" scope="instance">
        <parameters>
          <parameter name="divDesc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshConnectingLinesDS" scope="instance">
        <parameters>
          <parameter name="arrLines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postLoadData" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="checkPosition" scope="instance"/>
      <method name="createTreeImg" scope="instance"/>
      <method name="setPreviousTask" scope="instance">
        <parameters>
          <parameter name="previousTaskId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearPredTask" scope="instance"/>
      <method name="setStartTime" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
          <parameter name="shiftChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDuration" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTaskOwner" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPercentCompleted" scope="instance">
        <parameters>
          <parameter name="percentage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="checkMove" scope="instance-prototype" type="bool"/>
      <property name="posX" scope="instance-prototype" type="Number"/>
      <property name="maxPosXMove" scope="instance-prototype" type="Number"/>
      <property name="minPosXMove" scope="instance-prototype" type="Number"/>
      <property name="checkResize" scope="instance-prototype" type="bool"/>
      <property name="taskItemWidth" scope="instance-prototype" type="Number"/>
      <property name="mouseX" scope="instance-prototype" type="Number"/>
      <property name="moveChild" scope="instance-prototype" type="bool"/>
      <property name="minWidthResize" scope="instance-prototype" type="Number"/>
      <property name="maxWidthResize" scope="instance-prototype" type="Number"/>
      <property name="posY" scope="instance-prototype" type="Number"/>
      <property name="parentTask" scope="instance-prototype" type="Object"/>
      <property name="taskIdentifier" scope="instance" type="Object"/>
      <property name="ganttChart" scope="instance" type="Object"/>
      <property name="project" scope="instance" type="Object"/>
      <property name="isHide" scope="instance" type="bool"/>
      <property name="hideTasksHeight" scope="instance" type="Number"/>
      <property name="isExpanded" scope="instance" type="Object"/>
      <property name="childTask" scope="instance" type="Array"/>
      <property name="childPredTask" scope="instance" type="Array"/>
      <property name="nextChildTask" scope="instance" type="Object"/>
      <property name="nextParentTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem"/>
  <class type="dojox.gantt.GanttTaskControl.parentTask.cTaskNameItem">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.ganttChart.contentData">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem">
    <properties>
      <property name="1" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.1.firstChild.rows.0.cells.0">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.taskItem">
    <properties>
      <property name="startTime" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="previousTask" scope="instance" type="Object"/>
      <property name="parentTask" scope="instance" type="Object"/>
      <property name="previousTaskId" scope="instance" type="Object"/>
      <property name="taskOwner" scope="instance" type="Object"/>
      <property name="percentage" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.1.2.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.1.1.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.0.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.1.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.1.firstChild">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes">
    <properties>
      <property name="2" scope="instance" type="Object"/>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.2.childNodes.0.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.2.childNodes.1.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0">
    <properties>
      <property name="offsetLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.descrTask.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.descrTask">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem.0">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.ganttChart.panelNames">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.previousParentTask">
    <properties>
      <property name="nextParentTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.previousChildTask">
    <properties>
      <property name="nextChildTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem.0.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.predTask">
    <properties>
      <property name="childPredTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.0">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.1">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskItem">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setProject" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="project" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
      <property name="startTime" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Number"/>
      <property name="percentage" scope="instance" type="Number"/>
      <property name="previousTaskId" scope="instance" type="String"/>
      <property name="taskOwner" scope="instance" type="String"/>
      <property name="cldTasks" scope="instance" type="Array"/>
      <property name="cldPreTasks" scope="instance" type="Array"/>
      <property name="parentTask" scope="instance" type="Object"/>
      <property name="previousTask" scope="instance" type="Object"/>
      <property name="nextChildTask" scope="instance" type="Object"/>
      <property name="previousChildTask" scope="instance" type="Object"/>
      <property name="nextParentTask" scope="instance" type="Object"/>
      <property name="previousParentTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildContent" scope="instance"/>
      <method name="createMenuPanel" scope="instance"/>
      <method name="createTabPanel" scope="instance"/>
      <method name="addItemMenuPanel" scope="instance">
        <parameters>
          <parameter name="tab" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="clear" scope="instance"/>
      <method name="createTab" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="desc" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="showOInfo" type="Object" usage="required"/>
          <parameter name="menu" type="Object" usage="required"/>
          <parameter name="withDefaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tabPanelDlgId" scope="instance-prototype" type="Object"/>
      <property name="paneActionBar" scope="instance-prototype" type="Object"/>
      <property name="ok" scope="instance" type="Object"/>
      <property name="cancel" scope="instance" type="Object"/>
      <property name="isShow" scope="instance-prototype" type="bool"/>
      <property name="ganttChart" scope="instance" type="Object"/>
      <property name="arrTabs" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.menuPanel.firstChild">
    <properties>
      <property name="cellPadding" scope="instance" type="Number"/>
      <property name="cellSpacing" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.tabPanelDlg.closeButtonNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.tabPanelDlg">
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.paneContentArea">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.0.cells"/>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.0.cells.0">
    <properties>
      <property name="colSpan" scope="instance" type="Number"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.1.cells"/>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.1.cells.0">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
      <property name="align" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.menuPanel.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.menuPanel">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="description" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="showOInfo" type="Object" usage="required"/>
          <parameter name="tabMenu" type="Object" usage="required"/>
          <parameter name="withDefaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preValueValidation" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encodeDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeDate" scope="instance">
        <parameters>
          <parameter name="dateStr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameTaskAction" scope="instance"/>
      <method name="deleteAction" scope="instance"/>
      <method name="durationUpdateAction" scope="instance"/>
      <method name="cpUpdateAction" scope="instance"/>
      <method name="ownerUpdateAction" scope="instance"/>
      <method name="ptUpdateAction" scope="instance"/>
      <method name="renameProjectAction" scope="instance"/>
      <method name="deleteProjectAction" scope="instance"/>
      <method name="cpProjectAction" scope="instance"/>
      <method name="addTaskAction" scope="instance"/>
      <method name="addSuccessorTaskAction" scope="instance"/>
      <method name="addChildTaskAction" scope="instance"/>
      <method name="addProjectAction" scope="instance"/>
      <method name="addAction" scope="instance">
        <parameters>
          <parameter name="handler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addItem" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="required" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="insertData" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="actionFunc" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="arrItems" scope="instance" type="Array"/>
      <property name="TabItemContainer" scope="instance" type="Object"/>
      <property name="Description" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
      <property name="showObjectInfo" scope="instance" type="Object"/>
      <property name="withDefaultValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.0.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.1.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.3.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.4.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.5.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.6.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.7.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.object">
    <properties>
      <property name="project" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.object.taskItem">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu">
    <properties>
      <property name="tabPanelDlg" scope="instance" type="Object"/>
      <property name="paneActionBar" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.tabPanelDlg.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.paneContentArea.firstChild.rows.1.cells.0">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.ok">
    <properties>
      <property name="onClick" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.cancel">
    <properties>
      <property name="onClick" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.paneContentArea.firstChild.rows.1.cells"/>
  <class type="dojox.geo.charting">
    <methods>
      <method name="showTooltip" scope="instance">
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="gfxObject" type="dojox.gfx.shape" usage="required"/>
          <parameter name="position" type="String[]" usage="optional"/>
        </parameters>
      </method>
      <method name="hideTooltip" scope="instance">
        <parameters>
          <parameter name="gfxObject" type="dojox.gfx.shape" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeArround" scope="instance">
        <parameters>
          <parameter name="gfxObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getGfxContainer" scope="instance">
        <parameters>
          <parameter name="gfxObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRealBBox" scope="instance">
        <parameters>
          <parameter name="gfxObject" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.Map">
    <description>Support rendering Americas, AsiaPacific, ContinentalEurope, EuropeMiddleEastAfrica,
	USStates, WorldCountries, and WorldCountriesMercator by default.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="container" type="HTML" usage="required"/>
          <parameter name="shapeFile" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setMarkerData" scope="instance">
        <parameters>
          <parameter name="markerFile" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="ItemFileReadStore" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="shapeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_appendMarker" scope="instance">
        <parameters>
          <parameter name="markerData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createZoomingCursor" scope="instance"/>
      <method name="onFeatureClick" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFeatureOver" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onZoomEnd" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="defaultColor" scope="instance" type="String"/>
      <property name="highlightColor" scope="instance" type="String"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="dataStore" scope="instance" type="Object"/>
      <property name="containerSize" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="container" scope="instance" type="map"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.Map.mapObj">
    <properties>
      <property name="scale" scope="instance" type="Object"/>
      <property name="currentScale" scope="instance" type="Object"/>
      <property name="boundBox" scope="instance" type="Object"/>
      <property name="currentBBox" scope="instance" type="Object"/>
      <property name="marker" scope="instance" type="Object"/>
      <property name="features" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo"/>
  <class type="dojox.geo.charting._Feature">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="parent" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="shapeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFillWith" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStrokeWith" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeStrokeWeight" scope="instance">
        <parameters>
          <parameter name="weight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmouseoverHandler" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmouseoutHandler" scope="instance"/>
      <method name="_onmousemoveHandler" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onclickHandler" scope="instance"/>
      <method name="_focus" scope="instance"/>
      <method name="_zoomIn" scope="instance"/>
      <method name="_zoomOut" scope="instance"/>
      <method name="init" scope="instance"/>
    </methods>
    <properties>
      <property name="_isZoomIn" scope="instance" type="bool"/>
      <property name="_isFocused" scope="instance" type="Object"/>
      <property name="markerText" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="_defaultFill" scope="instance-prototype" type="Object"/>
      <property name="tooltip" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="_bbox" scope="instance" type="Object"/>
      <property name="_center" scope="instance" type="Object"/>
      <property name="_highlightFill" scope="instance" type="Object"/>
      <property name="_defaultStroke" scope="instance" type="Object"/>
      <property name="_scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting._Feature.mapObj">
    <properties>
      <property name="currentScale" scope="instance" type="Object"/>
      <property name="currentBBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting._Feature.shape.rawNode">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting._Marker">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="markerData" type="Object" usage="required"/>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="featureId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="_getGroupBoundingBox" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toWindowCoords" scope="instance">
        <parameters>
          <parameter name="arround" type="Object" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="containerSize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="markerText" scope="instance" type="Object"/>
      <property name="currentFeature" scope="instance" type="Object"/>
      <property name="_arround" scope="instance" type="Object"/>
      <property name="features" scope="instance" type="Object"/>
      <property name="markerData" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.widget"/>
  <class type="dojox.geo.charting.widget.Legend" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="legendNode" scope="instance" type="Object"/>
      <property name="legendBody" scope="instance" type="Object"/>
      <property name="swatchSize" scope="instance" type="Number"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="_tr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Moveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required"/>
          <parameter name="params" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event:" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event:" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event:" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStart" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoving" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="shape" scope="instance-prototype" type="dojox.gfx.Shape:"/>
      <property name="_lastX" scope="instance" type="Object"/>
      <property name="_lastY" scope="instance" type="Object"/>
      <property name="delay" scope="instance" type="Number:"/>
      <property name="mover" scope="instance" type="Object:"/>
    </properties>
  </class>
  <class type="dojox.gfx.Mover">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required"/>
          <parameter name="e" type="Event:" usage="required"/>
          <parameter name="host" type="Object:" usage="optional"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event:" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="lastX" scope="instance-prototype" type="Object"/>
      <property name="lastY" scope="instance-prototype" type="Object"/>
      <property name="host" scope="instance-prototype" type="Object:"/>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="shape" scope="instance-prototype" type="dojox.gfx.Shape:"/>
    </properties>
  </class>
  <class type="dojox.gfx.vectorFontFitting">
    <properties>
      <property name="NONE" scope="instance" type="Number"/>
      <property name="FLOW" scope="instance" type="Number"/>
      <property name="FIT" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultVectorText">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="String"/>
      <property name="align" scope="instance" type="String"/>
      <property name="decoration" scope="instance" type="String"/>
      <property name="fitting" scope="instance" type="Number"/>
      <property name="leading" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultVectorFont">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="size" scope="instance" type="String"/>
      <property name="family" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.VectorFont">
    <methods>
      <method name="_decodeEntitySequence" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="svg" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.VectorFont"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_round" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_leading" scope="instance">
        <parameters>
          <parameter name="unit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalize" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getWidth" scope="instance">
        <parameters>
          <parameter name="glyphs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLongestLine" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_trim" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_split" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="nLines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getSizeFactor" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFitFactor" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
          <parameter name="l" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFit" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
          <parameter name="ldng" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFlow" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getLineHeight" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="getCenterline" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getBaseline" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="draw" scope="instance">
        <description>The main method of a VectorFont, draw() will take a text fragment
	and render it in a set of groups and paths based on the parameters
	passed.
	The basics of drawing text are simple enough: pass it your text as
	part of the textArgs object, pass size and family info as part of
	the fontArgs object, pass at least a color as the fillArgs object,
	and if you are looking to create an outline, pass the strokeArgs
	object as well. fillArgs and strokeArgs are the same as any other
	gfx fill and stroke arguments; they are simply applied to any path
	object generated by this method.
	Resulting GFX structure
	-----------------------
	The result of this function is a set of gfx objects in the following
	structure:
		dojox.gfx.Group 			//	the parent group generated by this function
		+	dojox.gfx.Group[]		//	a group generated for each line of text
			+	dojox.gfx.Path[]	//	each glyph/character in the text
	Scaling transformations (i.e. making the generated text the correct size)
	are always applied to the parent Group that is generated (i.e. the top
	node in the above example).  In theory, if you are looking to do any kind
	of other transformations (such as a translation), you should apply it to
	the group reference you pass to this method.  If you find that you need
	to apply transformations to the group that is returned by this method,
	you will need to reapply the scaling transformation as the *last* transform,
	like so:
		textGroup.setTransform(new dojox.gfx.Matrix2D([
			dojox.gfx.matrix.translate({ dx: dx, dy: dy }),
			textGroup.getTransform()
		]));
	In general, this should never be necessary unless you are doing advanced
	placement of your text.
	Advanced Layout Functionality
	-----------------------------
	In addition to straight text fragments, draw() supports a few advanced
	operations not normally available with vector graphics:
	* Flow operations (i.e. wrap to a given width)
	* Fitting operations (i.e. find a best fit to a given rectangle)
	To enable either, pass a `fitting` property along with the textArgs object.
	The possible values are contained in the dojox.gfx.vectorFontFitting enum
	(NONE, FLOW, FIT).
	`Flow fitting`
	Flow fitting requires both a passed size (in the fontArgs object) and a
	width (passed with the textArgs object).  draw() will attempt to split the
	passed text up into lines, at the closest whitespace according to the
	passed width.  If a width is missing, it will revert to NONE.
	`Best fit fitting`
	Doing a "best fit" means taking the passed text, and finding the largest
	size and line breaks so that it is the closest fit possible.  With best
	fit, any size arguments are ignored; if a height is missing, it will revert
	to NONE.
	Other notes
	-----------
	`a11y`
	Since the results of this method are rendering using pure paths (think
	"convert to outlines" in Adobe Illustrator), any text rendered by this
	code is NOT considered a11y-friendly.  If a11y is a requirement, we
	suggest using other, more a11y-friendly methods.
	`Font sources`
	Always make sure that you are legally allowed to use any fonts that you
	convert to SVG format; we claim no responsibility for any licensing
	infractions that may be caused by the use of this code.</description>
        <parameters>
          <parameter name="group" type="dojox.gfx.Container" usage="required"/>
          <parameter name="textArgs" type="dojox.gfx.__TextArgs" usage="required"/>
          <parameter name="fontArgs" type="dojox.gfx.__FontArgs" usage="required"/>
          <parameter name="fillArgs" type="dojox.gfx.__FillArgs" usage="required"/>
          <parameter name="strokeArgs" type="dojox.gfx.__StrokeArgs" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="onLoadBegin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="font" type="dojox.gfx.VectorFont" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_entityRe" scope="instance" type="RegExp"/>
      <property name="name" scope="instance" type="Object"/>
      <property name="family" scope="instance" type="Object"/>
      <property name="_defaultLeading" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.VectorFont.viewbox">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPath">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="path" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPolyline">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultRect">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultEllipse">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="rx" scope="instance" type="Number"/>
      <property name="ry" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultCircle">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultLine">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultImage">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="src" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="text" scope="instance" type="String"/>
      <property name="align" scope="instance" type="String"/>
      <property name="decoration" scope="instance" type="String"/>
      <property name="rotated" scope="instance" type="bool"/>
      <property name="kerning" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultTextPath">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="text" scope="instance" type="String"/>
      <property name="align" scope="instance" type="String"/>
      <property name="decoration" scope="instance" type="String"/>
      <property name="rotated" scope="instance" type="bool"/>
      <property name="kerning" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultStroke">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="join" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultLinearGradient">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultRadialGradient">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPattern">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="src" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultFont">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="variant" scope="instance" type="String"/>
      <property name="weight" scope="instance" type="String"/>
      <property name="size" scope="instance" type="String"/>
      <property name="family" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx._base">
    <methods>
      <method name="_getFontMeasurements" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getCachedFontMeasurements" scope="instance">
        <parameters>
          <parameter name="recalculate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getTextBox" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
          <parameter name="className" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getUniqueId" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx.arc">
    <methods>
      <method name="arcAsBezier" scope="instance">
        <parameters>
          <parameter name="last" type="Object:" usage="required"/>
          <parameter name="rx" type="Number:" usage="required"/>
          <parameter name="ry" type="Number:" usage="required"/>
          <parameter name="xRotg" type="Number:" usage="required"/>
          <parameter name="large" type="Boolean:" usage="required"/>
          <parameter name="sweep" type="Boolean:" usage="required"/>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="y" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="unitArcAsBezier" scope="instance" type="Object"/>
      <property name="curvePI4" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.gfx">
    <properties>
      <property name="attachSurface" scope="instance" type="Object"/>
      <property name="attachNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas">
    <methods>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Node:" usage="required"/>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance"/>
      <method name="attachNode" scope="instance">
        <return-types>
          <return-type type="for now"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.canvas.Group" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Surface" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_render" scope="instance"/>
      <method name="makeDirty" scope="instance"/>
      <method name="downloadImage" scope="instance">
        <parameters>
          <parameter name="img" type="Image:" usage="required"/>
          <parameter name="url" type="String:" usage="required"/>
        </parameters>
      </method>
      <method name="onImageLoad" scope="instance"/>
      <method name="getEventSource" scope="instance"/>
      <method name="connect" scope="instance"/>
      <method name="disconnect" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="pendingRender" scope="instance" type="Object"/>
      <property name="pendingImageCount" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Shape" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderTransform" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderFill" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStroke" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getEventSource" scope="instance"/>
      <method name="connect" scope="instance"/>
      <method name="disconnect" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasTransform" scope="instance" type="Object"/>
      <property name="canvasFill" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Shape.fillStyle">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Shape.canvasFillImage">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Rect" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Rect.shape">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Ellipse" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="canvasEllipse" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Circle" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Line" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Polyline" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasPolyline" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Polyline.shape"/>
  <class type="dojox.gfx.canvas.Polyline.shape.points">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Image" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasImage" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Text" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_setFont" scope="instance"/>
      <method name="getTextWidth" scope="instance"/>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasFont" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Path" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setShape" scope="instance"/>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_arcTo" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closePath" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasPath" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Path.last">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Path.lastControl">
    <properties>
      <property name="x" scope="instance" type="String"/>
      <property name="y" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.TextPath" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance"/>
      <method name="_setFont" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Surface.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.matrix">
    <methods>
      <method name="multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required"/>
          <parameter name="a" type="Number||Point" usage="required"/>
          <parameter name="b" type="Number," usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Point"/>
        </return-types>
      </method>
      <method name="translate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <description>The resulting matrix is used to scale (magnify) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotate" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotateg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.rotate() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewX" scope="instance">
        <description>The resulting matrix is used to skew points in the x dimension
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXg" scope="instance">
        <description>The resulting matrix is used to skew points in the x dimension
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.skewX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewY" scope="instance">
        <description>The resulting matrix is used to skew points in the y dimension
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYg" scope="instance">
        <description>The resulting matrix is used to skew points in the y dimension
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.skewY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="reflect" scope="instance">
        <description>The resulting matrix is used to reflect points around a vector,
	which goes through the origin.</description>
        <parameters>
          <parameter name="a" type="dojox.gfx.Point:" usage="required"/>
          <parameter name="b" type="null" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="project" scope="instance">
        <description>The resulting matrix is used to project points orthogonally on a vector,
	which goes through the origin.</description>
        <parameters>
          <parameter name="a" type="dojox.gfx.Point:" usage="required"/>
          <parameter name="b" type="null" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <description>Converts any 2D matrix-like object or an array of
	such objects to a valid dojox.gfx.matrix.Matrix2D object.</description>
        <parameters>
          <parameter name="matrix" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="invert" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required"/>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="y" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Point"/>
        </return-types>
      </method>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_sandwich" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required"/>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="y" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="scaleAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.scale().</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
          <parameter name="c" type="Number:" usage="required"/>
          <parameter name="d" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotateAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.rotate().</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotategAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.rotateg().</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewX().</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXgAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewXg().</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewY().</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYgAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewYg().</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required"/>
          <parameter name="a" type="Number||Point" usage="required"/>
          <parameter name="b" type="Number," usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_degToRad" scope="instance">
        <parameters>
          <parameter name="degree" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_radToDeg" scope="instance">
        <parameters>
          <parameter name="radian" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="identity" scope="instance" type="dojox.gfx.matrix.Matrix2D"/>
      <property name="flipX" scope="instance" type="dojox.gfx.matrix.Matrix2D"/>
      <property name="flipY" scope="instance" type="dojox.gfx.matrix.Matrix2D"/>
      <property name="flipXY" scope="instance" type="dojox.gfx.matrix.Matrix2D"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape"/>
  <class type="dojox.gfx.fx">
    <methods>
      <method name="animateStroke" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateFill" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateFont" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateTransform" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.gradient">
    <methods>
      <method name="rescale" scope="instance">
        <parameters>
          <parameter name="stops" type="Array:" usage="required"/>
          <parameter name="from" type="Number:" usage="required"/>
          <parameter name="to" type="Number:" usage="required"/>
        </parameters>
      </method>
      <method name="project" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D|Null:" usage="required"/>
          <parameter name="grad" type="Object:" usage="required"/>
          <parameter name="tl" type="dojox.gfx.Point:" usage="required"/>
          <parameter name="rb" type="dojox.gfx.Point:" usage="required"/>
          <parameter name="ttl" type="dojox.gfx.Point:" usage="required"/>
          <parameter name="trb" type="dojox.gfx.Point:" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.gradutils">
    <methods>
      <method name="getColor" scope="instance">
        <parameters>
          <parameter name="fill" type="Object:" usage="required"/>
          <parameter name="pt" type="dojox.gfx.Point:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="reverse" scope="instance">
        <parameters>
          <parameter name="fill" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.matrix.Matrix2D">
    <description>Normalizes a 2D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
    <methods/>
    <properties>
      <property name="xx" scope="instance-prototype" type="Number"/>
      <property name="xy" scope="instance" type="Number"/>
      <property name="yx" scope="instance" type="Number"/>
      <property name="yy" scope="instance-prototype" type="Number"/>
      <property name="dx" scope="instance" type="Number"/>
      <property name="dy" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.path"/>
  <class type="dojox.gfx.path.Path" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="setAbsoluteMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Boolean:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getAbsoluteMode" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="_getRealBBox" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getLastPosition" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance"/>
      <method name="_updateBBox" scope="instance">
        <parameters>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="y" type="Number:" usage="required"/>
          <parameter name="matrix" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object:" usage="required"/>
          <parameter name="matrix" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pushSegment" scope="instance">
        <parameters>
          <parameter name="action" type="String:" usage="required"/>
          <parameter name="args" type="Array:" usage="required"/>
        </parameters>
      </method>
      <method name="_collectArgs" scope="instance">
        <parameters>
          <parameter name="array" type="Array:" usage="required"/>
          <parameter name="args" type="Array:" usage="required"/>
        </parameters>
      </method>
      <method name="moveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hLineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="vLineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="curveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="smoothCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qSmoothCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="arcTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="closePath" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_confirmSegmented" scope="instance"/>
      <method name="_setPath" scope="instance">
        <parameters>
          <parameter name="path" type="String:" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="absolute" scope="instance-prototype" type="Object"/>
      <property name="tbbox" scope="instance-prototype" type="Object"/>
      <property name="segmented" scope="instance-prototype" type="bool"/>
      <property name="_2PI" scope="instance" type="Number"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.segments">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.bbox">
    <properties>
      <property name="l" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.last">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path._validSegments">
    <properties>
      <property name="m" scope="instance" type="Number"/>
      <property name="l" scope="instance" type="Number"/>
      <property name="h" scope="instance" type="Number"/>
      <property name="v" scope="instance" type="Number"/>
      <property name="c" scope="instance" type="Number"/>
      <property name="s" scope="instance" type="Number"/>
      <property name="q" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.shape">
    <properties>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.TextPath" superclass="dojox.gfx.path.Path">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="getText" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getFont" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="text" scope="instance-prototype" type="Object"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Shape" superclass="dojox.gfx.shape._eventsProcessing">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="getNode" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="getShape" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransform" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="getFill" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getStroke" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getParent" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="getTransformedBoundingBox" scope="instance">
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getEventSource" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToBack" scope="instance"/>
      <method name="_moveToFront" scope="instance"/>
      <method name="_moveToBack" scope="instance"/>
      <method name="applyRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeShape" scope="instance">
        <parameters>
          <parameter name="silently" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setParent" scope="instance">
        <parameters>
          <parameter name="parent" type="Object:" usage="required"/>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateParentMatrix" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance-prototype" type="Object"/>
      <property name="fillStyle" scope="instance-prototype" type="Object"/>
      <property name="strokeStyle" scope="instance-prototype" type="Object"/>
      <property name="matrix" scope="instance-prototype" type="Object"/>
      <property name="parent" scope="instance-prototype" type="Object"/>
      <property name="parentMatrix" scope="instance-prototype" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Surface" superclass="dojox.gfx.shape._eventsProcessing">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="getEventSource" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="surface" type="dojox.gfx.Surface" usage="required"/>
        </parameters>
      </method>
      <method name="whenLoaded" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="optional"/>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_nodes" scope="instance-prototype" type="Array"/>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="rawNode" scope="instance-prototype" type="Object"/>
      <property name="isLoaded" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Surface._parent">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.Point">
    <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2}.</description>
    <methods/>
  </class>
  <class type="dojox.gfx.Rectangle">
    <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2, width: 100, height: 200}.</description>
    <methods/>
  </class>
  <class type="dojox.gfx.shape.Rect" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Ellipse" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Circle" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Line" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Polyline" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object:" usage="required"/>
          <parameter name="closed" type="Boolean:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_normalizePoints" scope="instance"/>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Polyline.shape"/>
  <class type="dojox.gfx.shape.Polyline.shape.points">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Image" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Text" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
      <method name="getFont" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape._eventsProcessing">
    <methods>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape.Container">
    <methods>
      <method name="openBatch" scope="instance"/>
      <method name="closeBatch" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="silently" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveChildToFront" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveChildToBack" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape.Container._init">
    <methods/>
    <properties>
      <property name="children" scope="instance" type="Array:"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Container.clear">
    <methods/>
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Creator">
    <methods>
      <method name="createShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="createGroup" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="createRect" scope="instance">
        <parameters>
          <parameter name="rect" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Rect"/>
        </return-types>
      </method>
      <method name="createEllipse" scope="instance">
        <parameters>
          <parameter name="ellipse" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Ellipse"/>
        </return-types>
      </method>
      <method name="createCircle" scope="instance">
        <parameters>
          <parameter name="circle" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Circle"/>
        </return-types>
      </method>
      <method name="createLine" scope="instance">
        <parameters>
          <parameter name="line" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Line"/>
        </return-types>
      </method>
      <method name="createPolyline" scope="instance">
        <parameters>
          <parameter name="points" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Polyline"/>
        </return-types>
      </method>
      <method name="createImage" scope="instance">
        <parameters>
          <parameter name="image" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Image"/>
        </return-types>
      </method>
      <method name="createText" scope="instance">
        <parameters>
          <parameter name="text" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Text"/>
        </return-types>
      </method>
      <method name="createPath" scope="instance">
        <parameters>
          <parameter name="path" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Path"/>
        </return-types>
      </method>
      <method name="createTextPath" scope="instance">
        <parameters>
          <parameter name="text" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.TextPath"/>
        </return-types>
      </method>
      <method name="createObject" scope="instance">
        <parameters>
          <parameter name="shapeType" type="Function:" usage="required"/>
          <parameter name="rawShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.silverlight">
    <methods>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Node:" usage="required"/>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="not implemented"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.silverlight.Text" superclass="Font">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_delayAlignment" scope="instance"/>
      <method name="_getAdjustedMatrix" scope="instance"/>
      <method name="setStroke" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFillAttr" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="_delay" scope="instance" type="Object"/>
      <property name="_delta" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Group" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Surface" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="eventsProcessing" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Shape" superclass="eventsProcessing">
    <methods>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFillAttr" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getParentSurface" scope="instance"/>
      <method name="_applyTransform" scope="instance"/>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToBack" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Shape.rawNode">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="strokeThickness" scope="instance" type="Object"/>
      <property name="strokeStartLineCap" scope="instance" type="Object"/>
      <property name="strokeEndLineCap" scope="instance" type="Object"/>
      <property name="strokeDashCap" scope="instance" type="Object"/>
      <property name="strokeLineJoin" scope="instance" type="String"/>
      <property name="strokeMiterLimit" scope="instance" type="Object"/>
      <property name="strokeDashArray" scope="instance" type="Object"/>
      <property name="renderTransform" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Shape.parent.rawNode">
    <properties>
      <property name="children" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Rect" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Rect.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="radiusX" scope="instance" type="Object"/>
      <property name="radiusY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Ellipse" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Ellipse.rawNode">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Circle" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Circle.rawNode">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Line" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Line.rawNode">
    <properties>
      <property name="x1" scope="instance" type="Object"/>
      <property name="y1" scope="instance" type="Object"/>
      <property name="x2" scope="instance" type="Object"/>
      <property name="y2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Polyline" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object:" usage="required"/>
          <parameter name="closed" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Polyline.shape">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Polyline.rawNode">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Image" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Image.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Text.rawNode">
    <properties>
      <property name="text" scope="instance" type="Object"/>
      <property name="textDecorations" scope="instance" type="Object"/>
      <property name="actualWidth" scope="instance" type="Object"/>
      <property name="actualHeight" scope="instance" type="Object"/>
      <property name="foreground" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Text.rawNode.Canvas">
    <properties>
      <property name="Left" scope="instance" type="Number"/>
      <property name="Top" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Text.shape">
    <properties>
      <property name="x" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Path" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Path.shape">
    <properties>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Path.rawNode">
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.TextPath" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Surface.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg">
    <methods>
      <method name="getRef" scope="instance">
        <parameters>
          <parameter name="name" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Node:" usage="required"/>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="useSvgWeb" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Text" superclass="Font">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getTextWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.TextPath" superclass="Font">
    <methods>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setTextPath" scope="instance"/>
      <method name="_setText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Group" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Surface" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="_eventsProcessing" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="defNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Shape" superclass="_eventsProcessing">
    <methods>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getParentSurface" scope="instance"/>
      <method name="_setFillObject" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="nodeType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyTransform" scope="instance"/>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToBack" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Rect" superclass="dojox.gfx.svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Ellipse" superclass="dojox.gfx.svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Circle" superclass="dojox.gfx.svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Line" superclass="dojox.gfx.svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Polyline" superclass="dojox.gfx.svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object:" usage="required"/>
          <parameter name="closed" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Polyline.shape">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Image" superclass="dojox.gfx.svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Text.rawNode.firstChild">
    <properties>
      <property name="nodeValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Text.rawNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Path" superclass="dojox.gfx.svg.Shape">
    <methods>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.xmlns">
    <properties>
      <property name="xlink" scope="instance" type="String"/>
      <property name="svg" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.dasharray">
    <properties>
      <property name="solid" scope="instance" type="String"/>
      <property name="shortdash" scope="instance" type="Array"/>
      <property name="shortdot" scope="instance" type="Array"/>
      <property name="shortdashdot" scope="instance" type="Array"/>
      <property name="shortdashdotdot" scope="instance" type="Array"/>
      <property name="dot" scope="instance" type="Array"/>
      <property name="dash" scope="instance" type="Array"/>
      <property name="longdash" scope="instance" type="Array"/>
      <property name="dashdot" scope="instance" type="Array"/>
      <property name="longdashdot" scope="instance" type="Array"/>
      <property name="longdashdotdot" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.utils">
    <methods>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toJson" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required"/>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="deserialize" scope="instance">
        <parameters>
          <parameter name="parent" type="dojox.gfx.Surface" usage="required"/>
          <parameter name="object" type="dojox.gfx.Shape" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="fromJson" scope="instance">
        <parameters>
          <parameter name="parent" type="dojox.gfx.Surface" usage="required"/>
          <parameter name="json" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="toSvg" scope="instance">
        <description>Function to serialize a GFX surface to SVG text.  The value of this output
	is that there are numerous serverside parser libraries that can render
	SVG into images in various formats.  This provides a way that GFX objects
	can be captured in a known format and sent serverside for serialization
	into an image.</description>
        <parameters>
          <parameter name="surface" type="GFX" usage="required"/>
        </parameters>
        <return-description>Deferred object that will be called when SVG serialization is complete.</return-description>
        <return-types>
          <return-type type="dojo.Deferred that will be called when serialization finishes."/>
        </return-types>
      </method>
      <method name="_svgSerializerInitialized" scope="instance"/>
      <method name="_initSvgSerializer" scope="instance"/>
      <method name="_innerXML" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cleanSvg" scope="instance">
        <parameters>
          <parameter name="svg" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Cleaned SVG text."/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_gfxSvgProxy" scope="instance" type="Object"/>
      <property name="_initSvgSerializerDeferred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml">
    <methods>
      <method name="_parseFloat" scope="instance">
        <parameters>
          <parameter name="str" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Node:" usage="required"/>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="xmlns" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_translate" scope="instance">
        <parameters>
          <parameter name="dict" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyTransform" scope="instance"/>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToFront" scope="instance"/>
      <method name="_moveToBack" scope="instance"/>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode">
    <properties>
      <property name="filled" scope="instance" type="Object"/>
      <property name="fillcolor" scope="instance" type="Object"/>
      <property name="stroked" scope="instance" type="Object"/>
      <property name="strokecolor" scope="instance" type="Object"/>
      <property name="strokeweight" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.fill">
    <properties>
      <property name="opacity" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.filters.DXImageTransform.Microsoft"/>
  <class type="dojox.gfx.vml.Shape.rawNode.filters.DXImageTransform.Microsoft.Alpha">
    <properties>
      <property name="opacity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.stroke">
    <properties>
      <property name="opacity" scope="instance" type="Object"/>
      <property name="endcap" scope="instance" type="Object"/>
      <property name="joinstyle" scope="instance" type="String"/>
      <property name="miterlimit" scope="instance" type="Object"/>
      <property name="dashstyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape._capMap">
    <properties>
      <property name="butt" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape._capMapReversed">
    <properties>
      <property name="flat" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.parentNode">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.rawNode">
    <properties>
      <property name="coordsize" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.bgNode"/>
  <class type="dojox.gfx.vml.Group.rawNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.bgNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Rect" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Rect.rawNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
      <property name="arcsize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Rect.rawNode.style">
    <properties>
      <property name="left" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Ellipse" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Ellipse.rawNode"/>
  <class type="dojox.gfx.vml.Ellipse.rawNode.style">
    <properties>
      <property name="left" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Circle" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Circle.rawNode"/>
  <class type="dojox.gfx.vml.Circle.rawNode.style">
    <properties>
      <property name="left" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Line" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Line.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Polyline" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object:" usage="required"/>
          <parameter name="closed" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Polyline.shape">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Polyline.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String:" usage="required"/>
          <parameter name="height" type="String:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.firstChild">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode"/>
  <class type="dojox.gfx.vml.Image.rawNode.style">
    <properties>
      <property name="filter" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.parentNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.filters.DXImageTransform.Microsoft"/>
  <class type="dojox.gfx.vml.Image.rawNode.filters.DXImageTransform.Microsoft.Matrix">
    <properties>
      <property name="M11" scope="instance" type="Object"/>
      <property name="M12" scope="instance" type="Object"/>
      <property name="M21" scope="instance" type="Object"/>
      <property name="M22" scope="instance" type="Object"/>
      <property name="Dx" scope="instance" type="Object"/>
      <property name="Dy" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFont" scope="instance"/>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="getTextWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text._alignment">
    <properties>
      <property name="start" scope="instance" type="String"/>
      <property name="middle" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text.shape">
    <properties>
      <property name="x" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text.rawNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text.rawNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="skip transfomed bbox calculations"/>
        </return-types>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="_addArgs" scope="instance">
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="upto" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelCrd" scope="instance">
        <parameters>
          <parameter name="last" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelPos" scope="instance">
        <parameters>
          <parameter name="last" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_arcTo" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closePath" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="vmlPath" scope="instance-prototype" type="String"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path.lastControl">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path._pathVmlToSvgMap">
    <properties>
      <property name="m" scope="instance" type="String"/>
      <property name="l" scope="instance" type="String"/>
      <property name="t" scope="instance" type="String"/>
      <property name="r" scope="instance" type="String"/>
      <property name="c" scope="instance" type="String"/>
      <property name="v" scope="instance" type="String"/>
      <property name="qb" scope="instance" type="String"/>
      <property name="x" scope="instance" type="String"/>
      <property name="e" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path.renderers">
    <properties>
      <property name="M" scope="instance" type="String"/>
      <property name="m" scope="instance" type="String"/>
      <property name="L" scope="instance" type="String"/>
      <property name="l" scope="instance" type="String"/>
      <property name="H" scope="instance" type="String"/>
      <property name="h" scope="instance" type="String"/>
      <property name="V" scope="instance" type="String"/>
      <property name="v" scope="instance" type="String"/>
      <property name="C" scope="instance" type="String"/>
      <property name="c" scope="instance" type="String"/>
      <property name="S" scope="instance" type="String"/>
      <property name="s" scope="instance" type="String"/>
      <property name="Q" scope="instance" type="String"/>
      <property name="q" scope="instance" type="String"/>
      <property name="T" scope="instance" type="String"/>
      <property name="t" scope="instance" type="String"/>
      <property name="A" scope="instance" type="String"/>
      <property name="a" scope="instance" type="String"/>
      <property name="Z" scope="instance" type="String"/>
      <property name="z" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.TextPath" superclass="dojox.gfx.vml.Path">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setText" scope="instance"/>
      <method name="_setFont" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Path" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="text" scope="instance-prototype" type="Object"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.TextPath.rawNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.clipNode"/>
  <class type="dojox.gfx.vml.Surface.rawNode">
    <properties>
      <property name="coordsize" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.bgNode"/>
  <class type="dojox.gfx.vml.Surface._parent"/>
  <class type="dojox.gfx.vml.Surface._parent.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.clipNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="clip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.rawNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.bgNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.text_alignment">
    <properties>
      <property name="start" scope="instance" type="String"/>
      <property name="middle" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml._bool">
    <properties>
      <property name="t" scope="instance" type="Number"/>
      <property name="true" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultEdges">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultTriangles">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultQuads">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultOrbit">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="radius" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultOrbit.center">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultPath3d">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="path" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultPolygon">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="path" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube">
    <properties>
      <property name="type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube.bottom">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube.top">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCylinder">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="radius" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCylinder.center">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting">
    <methods>
      <method name="black" scope="instance"/>
      <method name="white" scope="instance"/>
      <method name="toStdColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fromStdColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scaleColor" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addColor" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="multiplyColor" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saturateColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixColor" scope="instance">
        <parameters>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="diff2Color" scope="instance">
        <parameters>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length2Color" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dot" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scale" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saturate" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalize" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="faceforward" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reflect" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="diffuse" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="specular" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="roughness" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="phong" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.lighting.Model">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="incident" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
          <parameter name="ambient" type="Object" usage="required"/>
          <parameter name="specular" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constant" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="matte" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="metal" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="plastic" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="npr" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="incident" scope="instance" type="Object"/>
      <property name="lights" scope="instance" type="Array"/>
      <property name="npr_cool" scope="instance" type="Object"/>
      <property name="npr_warm" scope="instance" type="Object"/>
      <property name="npr_alpha" scope="instance" type="Number"/>
      <property name="npr_beta" scope="instance" type="Number"/>
      <property name="npr_scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.Model.ambient">
    <properties>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.Model.specular">
    <properties>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish"/>
  <class type="dojox.gfx3d.lighting.finish.defaults">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.dull">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.shiny">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.glossy">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_dull">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="phong" scope="instance" type="Number"/>
      <property name="phong_size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_shiny">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="phong" scope="instance" type="Number"/>
      <property name="phong_size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_glossy">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="phong" scope="instance" type="Number"/>
      <property name="phong_size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.luminous">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalA">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalB">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalC">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalD">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalE">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.matrix">
    <methods>
      <method name="translate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
          <parameter name="c" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <description>The resulting matrix is used to scale (magnify) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
          <parameter name="c" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateX" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateXg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateY" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateYg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZ" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateZ() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraTranslate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required"/>
          <parameter name="b" type="Number:" usage="required"/>
          <parameter name="c" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateX" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateXg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateY" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateYg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZ" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateZ() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <description>Converts any 3D matrix-like object or an array of
	such objects to a valid dojox.gfx3d.matrix.Matrix3D object.</description>
        <parameters>
          <parameter name="matrix" type="Object:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="invert" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix3D:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_multiplyPoint" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="y" type="Number:" usage="required"/>
          <parameter name="z" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D:" usage="required"/>
          <parameter name="a" type="Number||Point" usage="required"/>
          <parameter name="b" type="Number," usage="required"/>
          <parameter name="c" type="Number," usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D:" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_project" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="y" type="Number:" usage="required"/>
          <parameter name="z" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="project" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D:" usage="required"/>
          <parameter name="a" type="Number||Point" usage="required"/>
          <parameter name="b" type="Number," usage="required"/>
          <parameter name="c" type="Number," usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_degToRad" scope="instance">
        <parameters>
          <parameter name="degree" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_radToDeg" scope="instance">
        <parameters>
          <parameter name="radian" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="identity" scope="instance" type="dojox.gfx3d.matrix.Matrix3D"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.matrix.Matrix3D">
    <description>Normalizes a 3D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
    <methods/>
    <properties>
      <property name="xx" scope="instance-prototype" type="Number"/>
      <property name="xy" scope="instance" type="Number"/>
      <property name="xz" scope="instance" type="Number"/>
      <property name="yx" scope="instance" type="Number"/>
      <property name="yy" scope="instance-prototype" type="Number"/>
      <property name="yz" scope="instance" type="Number"/>
      <property name="zx" scope="instance" type="Number"/>
      <property name="zy" scope="instance" type="Number"/>
      <property name="zz" scope="instance-prototype" type="Number"/>
      <property name="dx" scope="instance" type="Number"/>
      <property name="dy" scope="instance" type="Number"/>
      <property name="dz" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Viewport" superclass="dojox.gfx3d._creators">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setCameraTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setLights" scope="instance">
        <parameters>
          <parameter name="lights" type="Array" usage="required"/>
          <parameter name="ambient" type="Color," usage="required"/>
          <parameter name="specular" type="Color," usage="required"/>
        </parameters>
      </method>
      <method name="addLights" scope="instance">
        <parameters>
          <parameter name="lights" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="addTodo" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.Group" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.Group" scope="instance"/>
    </mixins>
    <properties>
      <property name="camera" scope="instance" type="Object"/>
      <property name="lights" scope="instance-prototype" type="Array"/>
      <property name="lighting" scope="instance-prototype" type="Object"/>
      <property name="deep" scope="instance-prototype" type="bool"/>
      <property name="todos" scope="instance-prototype" type="Array"/>
      <property name="dimension" scope="instance-prototype" type="Object:"/>
      <property name="objects" scope="instance-prototype" type="Array"/>
      <property name="renderer" scope="instance" type="Object"/>
      <property name="schedule" scope="instance" type="Object"/>
      <property name="draw" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Scene" superclass="dojox.gfx3d._creators">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
          <parameter name="deep" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTodo" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="getZOrder" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
      <property name="todos" scope="instance-prototype" type="Array"/>
      <property name="objects" scope="instance-prototype" type="Array"/>
      <property name="schedule" scope="instance" type="Object"/>
      <property name="_draw" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Surface">
    <methods>
      <method name="createViewport" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object:" usage="required"/>
        </parameters>
      </method>
      <method name="toStdFill" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
          <parameter name="normal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="getOutline" scope="instance"/>
    </methods>
    <properties>
      <property name="object" scope="instance-prototype" type="Object:"/>
      <property name="matrix" scope="instance-prototype" type="Object"/>
      <property name="fillStyle" scope="instance-prototype" type="Object"/>
      <property name="strokeStyle" scope="instance-prototype" type="Object"/>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="renderer" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Edges" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required"/>
          <parameter name="style" type="String," usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Orbit" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Path3d" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_collectArgs" scope="instance">
        <parameters>
          <parameter name="array" type="Array:" usage="required"/>
          <parameter name="args" type="Array:" usage="required"/>
        </parameters>
      </method>
      <method name="_pushSegment" scope="instance">
        <parameters>
          <parameter name="action" type="String:" usage="required"/>
          <parameter name="args" type="Array:" usage="required"/>
        </parameters>
      </method>
      <method name="moveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="closePath" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_draw" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
      <property name="segments" scope="instance" type="Array"/>
      <property name="absolute" scope="instance" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Path3d._validSegments">
    <properties>
      <property name="m" scope="instance" type="Number"/>
      <property name="l" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Triangles" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required"/>
          <parameter name="style" type="String," usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Quads" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required"/>
          <parameter name="style" type="String," usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Polygon" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="getOutline" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cube" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="polygons" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cube.cache.0">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cube.cache.1">
    <properties>
      <property name="2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cylinder" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cylinder.object">
    <properties>
      <property name="radius" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Viewport.rawNode"/>
  <class type="dojox.gfx3d.Viewport.rawNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d._creators">
    <methods>
      <method name="createEdges" scope="instance">
        <parameters>
          <parameter name="edges" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createTriangles" scope="instance">
        <parameters>
          <parameter name="tris" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createQuads" scope="instance">
        <parameters>
          <parameter name="quads" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createPolygon" scope="instance">
        <parameters>
          <parameter name="points" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Polygon"/>
        </return-types>
      </method>
      <method name="createOrbit" scope="instance">
        <parameters>
          <parameter name="orbit" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCube" scope="instance">
        <parameters>
          <parameter name="cube" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCylinder" scope="instance">
        <parameters>
          <parameter name="cylinder" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createPath3d" scope="instance">
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createScene" scope="instance">
        <return-types>
          <return-type type="dojox.gfx3d.Scene"/>
        </return-types>
      </method>
      <method name="create3DObject" scope="instance">
        <parameters>
          <parameter name="objectType" type="Object" usage="required"/>
          <parameter name="rawObject" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Object"/>
        </return-types>
      </method>
      <method name="adopt" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="abandon" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="silently" type="Boolean:" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d._creators.setScheduler">
    <methods/>
    <properties>
      <property name="schedule" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d._creators.setDrawer">
    <methods/>
    <properties>
      <property name="draw" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.scheduler">
    <methods>
      <method name="zOrder" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="order" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bsp" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="order" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="outline" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.drawer">
    <methods>
      <method name="conservative" scope="instance">
        <parameters>
          <parameter name="todos" type="Object" usage="required"/>
          <parameter name="objects" type="Object" usage="required"/>
          <parameter name="viewport" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="chart" scope="instance">
        <parameters>
          <parameter name="todos" type="Object" usage="required"/>
          <parameter name="objects" type="Object" usage="required"/>
          <parameter name="viewport" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.scheduler.BinarySearchTree">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="obj" type="object:" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iterate" scope="instance">
        <parameters>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="normal" scope="instance-prototype" type="Object"/>
      <property name="orient" scope="instance-prototype" type="Object"/>
      <property name="minus" scope="instance-prototype" type="Object"/>
      <property name="plus" scope="instance-prototype" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.vector">
    <methods>
      <method name="sum" scope="instance"/>
      <method name="center" scope="instance"/>
      <method name="substract" scope="instance">
        <parameters>
          <parameter name="a" type="Pointer" usage="required"/>
          <parameter name="b" type="Pointer" usage="required"/>
        </parameters>
      </method>
      <method name="_crossProduct" scope="instance">
        <parameters>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="y" type="Number:" usage="required"/>
          <parameter name="z" type="Number:" usage="required"/>
          <parameter name="u" type="Number:" usage="required"/>
          <parameter name="v" type="Number:" usage="required"/>
          <parameter name="w" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="crossProduct" scope="instance">
        <parameters>
          <parameter name="a" type="Number||Point" usage="required"/>
          <parameter name="b" type="Number||Point" usage="required"/>
          <parameter name="c" type="Number," usage="required"/>
          <parameter name="d" type="Number," usage="required"/>
          <parameter name="e" type="Number," usage="required"/>
          <parameter name="f" type="Number," usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_dotProduct" scope="instance">
        <parameters>
          <parameter name="x" type="Number:" usage="required"/>
          <parameter name="y" type="Number:" usage="required"/>
          <parameter name="z" type="Number:" usage="required"/>
          <parameter name="u" type="Number:" usage="required"/>
          <parameter name="v" type="Number:" usage="required"/>
          <parameter name="w" type="Number:" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="dotProduct" scope="instance">
        <parameters>
          <parameter name="a" type="Number||Point" usage="required"/>
          <parameter name="b" type="Number||Point" usage="required"/>
          <parameter name="c" type="Number," usage="required"/>
          <parameter name="d" type="Number," usage="required"/>
          <parameter name="e" type="Number," usage="required"/>
          <parameter name="f" type="Number," usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <parameters>
          <parameter name="a" type="Point||Array" usage="required"/>
          <parameter name="b" type="Point" usage="required"/>
          <parameter name="c" type="Point" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid">
    <properties>
      <property name="_Builder" scope="instance" type="Object"/>
      <property name="_ContentBuilder" scope="instance" type="Object"/>
      <property name="_HeaderBuilder" scope="instance" type="Object"/>
      <property name="_TableMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.__DataCellDef" superclass="dojox.grid.__CellDef">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.__CellDef" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.__DataViewDef" superclass="dojox.grid.__ViewDef">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.__ViewDef" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.DataGrid" superclass="dojox.grid._Grid">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="get" scope="instance">
        <description>Provides data to display in a grid cell. Called in grid cell context.
	So this.cell.index is the column index.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
        <return-description>Data to display for a given grid cell.</return-description>
      </method>
      <method name="_checkUpdateStatus" scope="instance"/>
      <method name="_onSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="noUpdate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRevert" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setItems" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearData" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isDeleted" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="reRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_render" scope="instance"/>
      <method name="_requestsPending" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_rowToPage" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pageToRow" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePage" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_requestPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sort" scope="instance"/>
      <method name="canSort" scope="instance"/>
      <method name="getSortProps" scope="instance"/>
      <method name="styleRowState" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDataAttr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSelectedRows" scope="instance"/>
      <method name="cell_markupFactory" scope="instance">
        <parameters>
          <parameter name="cellFunc" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Grid" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="queryOptions" scope="instance" type="Object"/>
      <property name="fetchText" scope="instance" type="String"/>
      <property name="sortFields" scope="instance" type="Object"/>
      <property name="updateDelay" scope="instance" type="int"/>
      <property name="structure" scope="instance" type="dojox.grid.__DataViewDef|dojox.grid.__DataViewDef[]|dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]"/>
      <property name="items" scope="instance" type="Object"/>
      <property name="_store_connects" scope="instance" type="Array"/>
      <property name="_by_idty" scope="instance" type="Object"/>
      <property name="_cache" scope="instance" type="Array"/>
      <property name="_pages" scope="instance" type="Array"/>
      <property name="_pending_requests" scope="instance" type="Object"/>
      <property name="_bop" scope="instance" type="Number"/>
      <property name="_eop" scope="instance" type="String"/>
      <property name="_requests" scope="instance" type="Number"/>
      <property name="rowCount" scope="instance" type="Number"/>
      <property name="_isLoaded" scope="instance" type="bool"/>
      <property name="_isLoading" scope="instance" type="bool"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_endUpdateDelay" scope="instance" type="Object"/>
      <property name="_addingItem" scope="instance" type="bool"/>
      <property name="_canEdit" scope="instance" type="Object"/>
      <property name="_hasIdentity" scope="instance" type="bool"/>
      <property name="_skipRowRenormalize" scope="instance" type="bool"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="_lastScrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataGrid.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataGrid._by_idx">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataSelection" superclass="dojox.grid.Selection">
    <methods>
      <method name="getFirstSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance"/>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.Selection" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.DataSelection.selected">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.EnhancedGrid" superclass="dojox.grid.DataGrid">
    <description>EnhancedGrid features are implemented as plugins that could be loaded on demand.
	Explicit dojo.require() is needed to use these feature plugins.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="plugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="canSort" scope="instance">
        <parameters>
          <parameter name="colIndex" type="Object" usage="required"/>
          <parameter name="field" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHeaderHeight" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_storeLayerFetch" scope="instance">
        <parameters>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellByField" scope="instance">
        <parameters>
          <parameter name="field" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createView" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerPlugin" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.DataGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="plugins" scope="instance" type="Object"/>
      <property name="pluginMgr" scope="instance" type="Object"/>
      <property name="keepSelection" scope="instance" type="Boolean"/>
      <property name="_pluginMgrClass" scope="instance" type="Object"/>
      <property name="_nls" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_isLoading" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.EnhancedGrid.focus">
    <properties>
      <property name="focusView" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced"/>
  <class type="dojox.grid.enhanced.DataSelection" superclass="dojox.grid.DataSelection">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.DataSelection" scope="instance"/>
    </mixins>
    <properties>
      <property name="preserver" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.DataSelection.grid">
    <properties>
      <property name="_selectingRange" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell"/>
  <class type="dojox.grid.cells.TreeCell.formatAtLevel">
    <methods/>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAtLevel.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatIndexes">
    <methods/>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatIndexes.grid.edit">
    <properties>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyExpando" superclass="dijit._Widget">
    <methods>
      <method name="onToggle" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateOpenState" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRowNode" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="itemId" scope="instance" type="String"/>
      <property name="cellIdx" scope="instance" type="Number"/>
      <property name="rowIdx" scope="instance" type="Number"/>
      <property name="expandoCell" scope="instance" type="Object"/>
      <property name="level" scope="instance" type="Number"/>
      <property name="open" scope="instance" type="bool"/>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_tableRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyExpando.view"/>
  <class type="dojox.grid._LazyExpando.view.grid">
    <properties>
      <property name="stateChangeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyExpando.expandoInner">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridContentBuilder" superclass="dojox.grid._ContentBuilder">
    <methods>
      <method name="generateHtml" scope="instance">
        <parameters>
          <parameter name="inDataIndex" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getColSpans" scope="instance">
        <parameters>
          <parameter name="level" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCellWidth" scope="instance">
        <parameters>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._ContentBuilder" scope="instance"/>
    </mixins>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridContentBuilder.view.structure">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridContentBuilder.grid">
    <properties>
      <property name="colSpans" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridView" superclass="dojox.grid._View">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._View" scope="instance"/>
    </mixins>
    <properties>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
      <property name="_expandos" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyTreeLayout" superclass="dojox.grid._Layout">
    <methods>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Layout" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="_isCollapsable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGridItemCache">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildCache" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cacheItem" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
          <parameter name="cacheObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertItem" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
          <parameter name="cacheObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initCache" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItemByRowIndex" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
        </parameters>
      </method>
      <method name="getItemByTreePath" scope="instance">
        <parameters>
          <parameter name="treePath" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTreePathByRowIndex" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
        </parameters>
      </method>
      <method name="getExpandoStatusByRowIndex" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
        </parameters>
      </method>
      <method name="getInfoByItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateCache" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
          <parameter name="cacheObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cleanChildren" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="emptyCache" scope="instance"/>
      <method name="cleanupCache" scope="instance"/>
    </methods>
    <properties>
      <property name="unInit" scope="instance" type="Object"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGridItemCache.items">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid" superclass="dojox.grid.TreeGrid">
    <description>LazyTreeGrid inherits from dojo.grid.TreeGrid, and applies virtual scrolling mechanism
	to nested children rows so that it's possible to deal with large data set specifically
	in tree structure with large number of children rows. It's also compatible with dijit.tree.ForestStoreModel
	Most methods and properties pertaining to the dojox.grid.DataGrid
	and dojox.grid.TreeGrid also apply here
	LazyTreeGrid does not support summary row/items aggregate for the
	lazy-loading reason.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_cleanup" scope="instance"/>
      <method name="setSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inAsc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="onBegin" type="Object" usage="required"/>
          <parameter name="onComplete" type="Object" usage="required"/>
          <parameter name="onError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="expandoFetch" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onExpandoComplete" scope="instance">
        <parameters>
          <parameter name="childItems" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleLoadingClass" scope="instance">
        <parameters>
          <parameter name="flag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.TreeGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="_layoutClass" scope="instance" type="Object"/>
      <property name="colSpans" scope="instance" type="Object"/>
      <property name="rows" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_pages" scope="instance" type="Array"/>
      <property name="_bop" scope="instance" type="Number"/>
      <property name="_eop" scope="instance" type="Number"/>
      <property name="reqQueueIndex" scope="instance" type="Number"/>
      <property name="expandoRowIndex" scope="instance" type="Object"/>
      <property name="stateChangeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.treeModel">
    <properties>
      <property name="query" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.treeModel.root">
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.cache"/>
  <class type="dojox.grid.LazyTreeGrid.reqQueue">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.cache.items">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.queryObj">
    <properties>
      <property name="startRowIdx" scope="instance" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid._by_idx">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGridStoreModel" superclass="dijit.tree.ForestStoreModel">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items," usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
          <parameter name="queryObj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_isChildrenLoaded" scope="instance">
        <parameters>
          <parameter name="parentItem" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree.ForestStoreModel" scope="instance"/>
    </mixins>
    <properties>
      <property name="serverStore" scope="instance-prototype" type="bool"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="childrenSize" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGridStoreModel.root">
    <properties>
      <property name="size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.Selection">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanDeselect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChanging" scope="instance"/>
      <method name="onChanged" scope="instance"/>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance"/>
      <method name="getSelectedCount" scope="instance"/>
      <method name="_beginUpdate" scope="instance"/>
      <method name="_endUpdate" scope="instance"/>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectRange" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inExcept" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inCtrlKey" type="Object" usage="required"/>
          <parameter name="inShiftKey" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelectEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
    </methods>
    <properties>
      <property name="mode" scope="instance" type="String"/>
      <property name="updating" scope="instance" type="Number"/>
      <property name="selectedIndex" scope="instance" type="Number"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.Selection.selected">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeAggregator">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cacheValue" scope="instance">
        <parameters>
          <parameter name="cache" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSubtotalCache" scope="instance"/>
      <method name="cnt" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sum" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="value" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getForCell" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cells" scope="instance-prototype" type="Array"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="childFields" scope="instance-prototype" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeAggregator.store">
    <properties>
      <property name="_cachedAggregates" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeLayout" superclass="dojox.grid._Layout">
    <methods>
      <method name="_getInternalStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Layout" scope="instance"/>
    </mixins>
    <properties>
      <property name="_isCollapsable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeLayout.grid">
    <properties>
      <property name="aggregator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeLayout.grid.scroller">
    <properties>
      <property name="defaultRowHeight" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.TreePath">
    <methods>
      <method name="item" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="path" type="String|Integer[]|Integer|dojox.grid.TreePath" usage="required"/>
          <parameter name="grid" type="dojox.grid.TreeGrid" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="path" type="dojox.grid.TreePath|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="isOpen" scope="instance"/>
      <method name="previous" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="children" scope="instance">
        <parameters>
          <parameter name="alwaysReturn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="childPaths" scope="instance"/>
      <method name="parent" scope="instance"/>
      <method name="lastChild" scope="instance">
        <parameters>
          <parameter name="traverse" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="toString" scope="instance"/>
    </methods>
    <properties>
      <property name="level" scope="instance-prototype" type="Number"/>
      <property name="_str" scope="instance-prototype" type="Object"/>
      <property name="_arr" scope="instance-prototype" type="Object"/>
      <property name="store" scope="instance-prototype" type="Object"/>
      <property name="cell" scope="instance-prototype" type="Object"/>
      <property name="_item" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreePath.grid"/>
  <class type="dojox.grid.TreePath.grid.treeModel">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeFocusManager" superclass="dojox.grid._FocusManager">
    <methods>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLastFocusCell" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="previous" scope="instance"/>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="inRowDelta" type="Object" usage="required"/>
          <parameter name="inColDelta" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._FocusManager" scope="instance"/>
    </mixins>
    <properties>
      <property name="rowIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeFocusManager.grid">
    <properties>
      <property name="scroller" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeFocusManager.cell">
    <properties>
      <property name="index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid" superclass="dojox.grid.DataGrid">
    <description>TreeGrid currently only works on "simple" structures.  That is,
	single-view structures with a single row in them.
	The TreeGrid works using the concept of "levels" - level 0 are the
	top-level items.</description>
    <methods>
      <method name="createSelection" scope="instance"/>
      <method name="_childItemSorter" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="descending" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="noUpdate" type="Object" usage="required"/>
          <parameter name="dontUpdateRoot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="idx" type="integer|Array|String" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isDeleted" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createScroller" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultOpenState" scope="instance">
        <parameters>
          <parameter name="cellDef" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.DataGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultOpen" scope="instance" type="Boolean"/>
      <property name="sortChildItems" scope="instance" type="Boolean"/>
      <property name="openAtLevels" scope="instance" type="Array"/>
      <property name="expandoCell" scope="instance" type="Integer"/>
      <property name="_layoutClass" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_by_idty_paths" scope="instance" type="Object"/>
      <property name="rows" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.treeModel"/>
  <class type="dojox.grid.TreeGrid.treeModel.childrenAttrs">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.scroller">
    <properties>
      <property name="_origDefaultRowHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.treeModel.root">
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.aggregator">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeSelection" superclass="dojox.grid.DataSelection">
    <methods>
      <method name="setMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance"/>
      <method name="getSelectedCount" scope="instance"/>
      <method name="_bsearch" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_comparePaths" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_insertSortedSelection" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeSortedSelection" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.DataSelection" scope="instance"/>
    </mixins>
    <properties>
      <property name="selected" scope="instance" type="Object"/>
      <property name="sorted_sel" scope="instance" type="Array"/>
      <property name="sorted_ltos" scope="instance" type="Object"/>
      <property name="sorted_stol" scope="instance" type="Object"/>
      <property name="selectedIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeSelection.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeSelection.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.util">
    <methods>
      <method name="fire" scope="instance">
        <parameters>
          <parameter name="ob" type="Object" usage="required"/>
          <parameter name="ev" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStyleHeightPx" scope="instance">
        <parameters>
          <parameter name="inElement" type="Object" usage="required"/>
          <parameter name="inHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="funnelEvents" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inObject" type="Object" usage="required"/>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inEvents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayCompare" scope="instance">
        <parameters>
          <parameter name="inA" type="Object" usage="required"/>
          <parameter name="inB" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayInsert" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayRemove" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arraySwap" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inI" type="Object" usage="required"/>
          <parameter name="inJ" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rowIndexTag" scope="instance" type="String"/>
      <property name="gridViewTag" scope="instance" type="String"/>
      <property name="na" scope="instance" type="String"/>
      <property name="mouseEvents" scope="instance" type="Array"/>
      <property name="keyEvents" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._CheckBoxSelector" superclass="dojox.grid._Selector">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="renderHeader" scope="instance"/>
      <method name="_updateVisibility" scope="instance">
        <parameters>
          <parameter name="rowCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="_headerBuilderClass" scope="instance" type="Object"/>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._EditManager">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="dojox.Grid" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="cellFocus" scope="instance">
        <parameters>
          <parameter name="inCell" type="cell" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="rowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isEditing" scope="instance">
        <return-description>Boolean
	True if grid is actively editing</return-description>
      </method>
      <method name="isEditCell" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
          <parameter name="inCellIndex" type="Integer" usage="required"/>
        </parameters>
        <return-description>Boolean
	True if given cell is being edited</return-description>
      </method>
      <method name="isEditRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
        <return-description>Boolean
	True if given row is being edited</return-description>
      </method>
      <method name="setEditCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_focusEditor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusEditor" scope="instance"/>
      <method name="_shouldCatchBoomerang" scope="instance"/>
      <method name="_boomerangFocus" scope="instance"/>
      <method name="_doCatchBoomerang" scope="instance"/>
      <method name="start" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inEditing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_editorDo" scope="instance">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="editorApply" scope="instance"/>
      <method name="editorCancel" scope="instance"/>
      <method name="applyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyRowEdit" scope="instance"/>
      <method name="apply" scope="instance"/>
      <method name="cancel" scope="instance"/>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
          <parameter name="inView" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="restore" scope="instance">
        <parameters>
          <parameter name="inView" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_boomerangWindow" scope="instance" type="Number"/>
      <property name="_catchBoomerang" scope="instance" type="String"/>
      <property name="grid" scope="instance" type="Object"/>
      <property name="connections" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._EditManager.info">
    <properties>
      <property name="cell" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Events">
    <description>Default synthetic events dispatched for _Grid. dojo.connect to events to
	retain default implementation or override them for custom handling.</description>
    <methods>
      <method name="onKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOverRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOutRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDownRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellFocus" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onRowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onRowDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="String" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
          <parameter name="inFieldIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
        <return-description>Boolean
	true if the row can be selected</return-description>
      </method>
      <method name="onCanDeselect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
        <return-description>Boolean
	true if the row can be deselected</return-description>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="instance"/>
    </methods>
    <properties>
      <property name="cellOverClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Events.focus">
    <properties>
      <property name="focusView" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Events._click">
    <properties>
      <property name="0" scope="instance" type="Object"/>
      <property name="1" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="initFocusView" scope="instance"/>
      <method name="isFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="object" usage="required"/>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
        <return-description>true of the given grid cell is focused</return-description>
      </method>
      <method name="isLastFocusCell" scope="instance"/>
      <method name="isFirstFocusCell" scope="instance"/>
      <method name="isNoFocusCell" scope="instance"/>
      <method name="isNavHeader" scope="instance">
        <return-description>true if focus is on a column header; false otherwise.</return-description>
      </method>
      <method name="getHeaderIndex" scope="instance">
        <return-description>index of the focused column header, or -1 if none have focus.</return-description>
      </method>
      <method name="_focusifyCellNode" scope="instance">
        <parameters>
          <parameter name="inBork" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_delayedCellFocus" scope="instance"/>
      <method name="_delayedHeaderFocus" scope="instance"/>
      <method name="_initColumnHeaders" scope="instance"/>
      <method name="_findHeaderCells" scope="instance"/>
      <method name="_setActiveColHeader" scope="instance">
        <parameters>
          <parameter name="colHeaderNode" type="Node" usage="required"/>
          <parameter name="colFocusIdx" type="Integer" usage="required"/>
          <parameter name="prevColFocusIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance"/>
      <method name="_scrollInfo" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="domNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollHeader" scope="instance">
        <parameters>
          <parameter name="currentIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isHeaderHidden" scope="instance">
        <return-description>Boolean
	true if headers are hidden
	false if headers are not hidden</return-description>
      </method>
      <method name="colSizeAdjust" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="delta" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="can't adjust single col. grid"/>
        </return-types>
      </method>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusIndex" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
          <parameter name="inCellIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="object" usage="required"/>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance"/>
      <method name="previous" scope="instance"/>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="inRowDelta" type="int" usage="required"/>
          <parameter name="inColDelta" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="previousKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tabOut" scope="instance">
        <parameters>
          <parameter name="inFocusNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusGridView" scope="instance"/>
      <method name="focusGrid" scope="instance">
        <parameters>
          <parameter name="inSkipFocusCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findAndFocusGridCell" scope="instance">
        <return-description>Boolean
	true if focus was set to a cell
	false if no cell found to set focus onto</return-description>
      </method>
      <method name="focusHeader" scope="instance"/>
      <method name="blurHeader" scope="instance"/>
      <method name="doFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_colHeadNode" scope="instance" type="Object"/>
      <property name="_colHeadFocusIdx" scope="instance" type="Number"/>
      <property name="_contextMenuBindNode" scope="instance" type="Object"/>
      <property name="tabbingOut" scope="instance" type="bool"/>
      <property name="focusClass" scope="instance" type="String"/>
      <property name="focusView" scope="instance" type="Object"/>
      <property name="_headerConnects" scope="instance-prototype" type="Array"/>
      <property name="rowIndex" scope="instance-prototype" type="Number"/>
      <property name="_connects" scope="instance" type="Array"/>
      <property name="headerMenu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager.cell.view.scrollboxNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager.grid">
    <properties>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="viewsHeaderNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager.cell">
    <properties>
      <property name="index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid" superclass="dijit._Widget">
    <description>_Grid provides the full set of grid features without any
	direct connection to a data store.
	The grid exposes a get function for the grid, or optionally
	individual columns, to populate cell contents.
	The grid is rendered based on its structure, an object describing
	column and cell layout.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setAutoHeightAttr" scope="instance">
        <parameters>
          <parameter name="ah" type="Object" usage="required"/>
          <parameter name="skipRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowCountAttr" scope="instance"/>
      <method name="textSizeChanged" scope="instance"/>
      <method name="sizeChange" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="createScroller" scope="instance"/>
      <method name="createLayout" scope="instance"/>
      <method name="onMoveColumn" scope="instance"/>
      <method name="onResizeColumn" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="createViews" scope="instance"/>
      <method name="createView" scope="instance">
        <parameters>
          <parameter name="inClass" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildViews" scope="instance"/>
      <method name="_setStructureAttr" scope="instance">
        <parameters>
          <parameter name="structure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnTogglingItems" scope="instance"/>
      <method name="_setHeaderMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setHeaderMenu" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="setupHeaderMenu" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_structureChanged" scope="instance"/>
      <method name="hasLayout" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorder" scope="instance"/>
      <method name="_getHeaderHeight" scope="instance"/>
      <method name="_resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="instance"/>
      <method name="adaptHeight" scope="instance">
        <parameters>
          <parameter name="inHeaderHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_render" scope="instance"/>
      <method name="prerender" scope="instance"/>
      <method name="postrender" scope="instance"/>
      <method name="postresize" scope="instance"/>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginUpdate" scope="instance"/>
      <method name="endUpdate" scope="instance"/>
      <method name="defaultUpdate" scope="instance"/>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="updateRows" scope="instance">
        <parameters>
          <parameter name="startIndex" type="Integer" usage="required"/>
          <parameter name="howMany" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowCount" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="scrollTo" scope="instance">
        <parameters>
          <parameter name="inTop" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="finishScrollJob" scope="instance"/>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollToRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCell" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required"/>
        </parameters>
        <return-description>a grid cell</return-description>
      </method>
      <method name="setCellWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inUnitWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="canSort" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Integer" usage="required"/>
        </parameters>
        <return-description>Boolean
	True if grid can be sorted on the given column in the given direction</return-description>
      </method>
      <method name="sort" scope="instance"/>
      <method name="getSortAsc" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getSortIndex" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required"/>
          <parameter name="inAsc" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setSortInfo" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dispatch" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dodblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="docontextmenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderdblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheadercontextmenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inFieldIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRow" scope="instance"/>
      <method name="removeSelectedRows" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="for vendetta"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dojox.grid._Events.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dojox.grid._Events" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="classTag" scope="instance" type="String"/>
      <property name="rowCount" scope="instance" type="Integer"/>
      <property name="keepRows" scope="instance" type="Integer"/>
      <property name="rowsPerPage" scope="instance" type="Integer"/>
      <property name="autoWidth" scope="instance" type="Boolean"/>
      <property name="initialWidth" scope="instance" type="String"/>
      <property name="autoHeight" scope="instance" type="Boolean|Integer"/>
      <property name="rowHeight" scope="instance" type="Integer"/>
      <property name="autoRender" scope="instance" type="Boolean"/>
      <property name="defaultHeight" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
      <property name="structure" scope="instance" type="dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]"/>
      <property name="elasticView" scope="instance" type="Integer"/>
      <property name="singleClickEdit" scope="instance" type="boolean"/>
      <property name="selectionMode" scope="instance" type="String"/>
      <property name="rowSelector" scope="instance" type="Boolean|String"/>
      <property name="columnReordering" scope="instance" type="Boolean"/>
      <property name="headerMenu" scope="instance" type="dijit.Menu"/>
      <property name="placeholderLabel" scope="instance" type="String"/>
      <property name="selectable" scope="instance" type="Boolean"/>
      <property name="_click" scope="instance" type="Array"/>
      <property name="loadingMessage" scope="instance" type="String"/>
      <property name="errorMessage" scope="instance" type="String"/>
      <property name="noDataMessage" scope="instance" type="String"/>
      <property name="escapeHTMLInData" scope="instance" type="Boolean"/>
      <property name="formatterScope" scope="instance" type="Object"/>
      <property name="editable" scope="instance" type="boolean"/>
      <property name="sortInfo" scope="instance" type="Number"/>
      <property name="themeable" scope="instance" type="Object"/>
      <property name="_placeholders" scope="instance" type="Object"/>
      <property name="_layoutClass" scope="instance" type="Object"/>
      <property name="lastScrollTop" scope="instance" type="Number"/>
      <property name="scrollTop" scope="instance" type="Number"/>
      <property name="_autoHeight" scope="instance" type="bool"/>
      <property name="rows" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_pendingChangeSize" scope="instance" type="Object"/>
      <property name="_pendingResultSize" scope="instance" type="Object"/>
      <property name="_padBorder" scope="instance" type="Object"/>
      <property name="fitTo" scope="instance" type="String"/>
      <property name="_parentContentBoxHeight" scope="instance" type="Object"/>
      <property name="updating" scope="instance" type="bool"/>
      <property name="fastScroll" scope="instance" type="Boolean"/>
      <property name="delayScroll" scope="instance" type="bool"/>
      <property name="scrollRedrawThreshold" scope="instance" type="int"/>
      <property name="_pendingScroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.domNode">
    <properties>
      <property name="tabIndex" scope="instance" type="String"/>
      <property name="onReveal" scope="instance" type="Object"/>
      <property name="onSizeChange" scope="instance" type="Object"/>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.scroller">
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="renderRow" scope="instance" type="Object"/>
      <property name="removeRow" scope="instance" type="Object"/>
      <property name="windowHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.views">
    <properties>
      <property name="createView" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.layout">
    <properties>
      <property name="structure" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.messagesNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.messagesNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.viewsHeaderNode"/>
  <class type="dojox.grid._Grid.viewsHeaderNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.viewsNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.invalidated">
    <properties>
      <property name="all" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.__CellDef">
    <methods>
      <method name="get" scope="instance"/>
      <method name="formatter" scope="instance"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
      <property name="type" scope="instance" type="dojox.grid.cells._Base|Function"/>
      <property name="editable" scope="instance" type="Boolean"/>
      <property name="hidden" scope="instance" type="Boolean"/>
      <property name="width" scope="instance" type="Integer|String"/>
      <property name="colSpan" scope="instance" type="Integer"/>
      <property name="rowSpan" scope="instance" type="Integer"/>
      <property name="styles" scope="instance" type="String"/>
      <property name="headerStyles" scope="instance" type="String"/>
      <property name="cellStyles" scope="instance" type="String"/>
      <property name="classes" scope="instance" type="String"/>
      <property name="headerClasses" scope="instance" type="String"/>
      <property name="cellClasses" scope="instance" type="String"/>
      <property name="attrs" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.__ViewDef">
    <methods>
      <method name="onBeforeRow" scope="instance"/>
      <method name="onAfterRow" scope="instance"/>
    </methods>
    <properties>
      <property name="noscroll" scope="instance" type="Boolean"/>
      <property name="width" scope="instance" type="Integer|String"/>
      <property name="cells" scope="instance" type="dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]"/>
      <property name="type" scope="instance" type="String"/>
      <property name="defaultCell" scope="instance" type="dojox.grid.__CellDef"/>
    </properties>
  </class>
  <class type="dojox.grid._Layout">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveColumn" scope="instance">
        <parameters>
          <parameter name="sourceViewIndex" type="Object" usage="required"/>
          <parameter name="destViewIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
          <parameter name="targetIndex" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColumnVisibility" scope="instance">
        <parameters>
          <parameter name="columnIndex" type="Object" usage="required"/>
          <parameter name="visible" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowsDef" scope="instance">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addViewDef" scope="instance">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cells" scope="instance" type="Array"/>
      <property name="structure" scope="instance" type="Array"/>
      <property name="defaultWidth" scope="instance" type="String"/>
      <property name="_defaultCellProps" scope="instance" type="Object"/>
      <property name="fieldIndex" scope="instance" type="Number"/>
      <property name="cellCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Layout.grid">
    <properties>
      <property name="sortInfo" scope="instance" type="Object"/>
      <property name="rowSelector" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RadioSelector" superclass="dojox.grid._Selector">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="renderHeader" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="selectionMode" scope="instance" type="String"/>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RowManager">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="prepareStylingRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStyles" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOverRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isOver" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="linesToEms" scope="instance" type="Number"/>
      <property name="overRow" scope="instance" type="Number"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector" superclass="dojox.grid._View">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="getWidth" scope="instance"/>
      <method name="buildRowContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="instance"/>
      <method name="updateRow" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="adaptWidth" scope="instance"/>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._View" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultWidth" scope="instance" type="String"/>
      <property name="noscroll" scope="instance" type="Object"/>
      <property name="padBorderWidth" scope="instance" type="Number"/>
      <property name="contentWidth" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector.headerNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inContentNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
          <parameter name="inKeepRows" type="Object" usage="required"/>
          <parameter name="inRowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageCount" scope="instance">
        <parameters>
          <parameter name="rowCount" type="Object" usage="required"/>
          <parameter name="rowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setKeepInfo" scope="instance">
        <parameters>
          <parameter name="inKeepRows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setContentNodes" scope="instance">
        <parameters>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultNodes" scope="instance"/>
      <method name="invalidate" scope="instance"/>
      <method name="updateRowCount" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pageExists" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measurePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="repositionPages" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="installPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pacify" scope="instance">
        <parameters>
          <parameter name="inShouldPacify" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPacifying" scope="instance">
        <parameters>
          <parameter name="inPacifying" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startPacify" scope="instance"/>
      <method name="doPacify" scope="instance"/>
      <method name="endPacify" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="calcLastPageHeight" scope="instance"/>
      <method name="updateContentHeight" scope="instance">
        <parameters>
          <parameter name="inDh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updatePageHeight" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="fromBuild" type="Object" usage="required"/>
          <parameter name="fromAsynRendering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="fromAsynRendering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidateNodes" scope="instance"/>
      <method name="createPageNode" scope="instance"/>
      <method name="getPageHeight" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pushPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popPage" scope="instance"/>
      <method name="findPage" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onscroll" scope="instance"/>
      <method name="scroll" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScrollBottom" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processNodeEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inPageNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultPageNode" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPageNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageNodePosition" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidatePageNode" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastPageRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstVisibleRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inPageTop" type="Object" usage="required"/>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastVisibleRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inBottom" type="Object" usage="required"/>
          <parameter name="inScrollBottom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTopRow" scope="instance">
        <parameters>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findScrollTop" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rowCount" scope="instance" type="Number"/>
      <property name="defaultRowHeight" scope="instance" type="Number"/>
      <property name="keepRows" scope="instance" type="Number"/>
      <property name="contentNode" scope="instance" type="Object"/>
      <property name="defaultPageHeight" scope="instance" type="Number"/>
      <property name="keepPages" scope="instance" type="Number"/>
      <property name="pageCount" scope="instance" type="Object"/>
      <property name="windowHeight" scope="instance" type="Number"/>
      <property name="firstVisibleRow" scope="instance" type="Object"/>
      <property name="lastVisibleRow" scope="instance" type="Object"/>
      <property name="averageRowHeight" scope="instance" type="Number"/>
      <property name="page" scope="instance" type="Number"/>
      <property name="pageTop" scope="instance" type="Number"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="contentNodes" scope="instance" type="Object"/>
      <property name="colCount" scope="instance" type="Object"/>
      <property name="pageNodes" scope="instance-prototype" type="Array"/>
      <property name="_invalidating" scope="instance" type="bool"/>
      <property name="pageHeights" scope="instance-prototype" type="Array"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="pacifying" scope="instance" type="bool"/>
      <property name="pacifyTicks" scope="instance" type="Number"/>
      <property name="startPacifyTicks" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="dummy" scope="instance" type="Number"/>
      <property name="stack" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.scrollboxNode">
    <properties>
      <property name="scrollTop" scope="instance" type="Number"/>
      <property name="onscroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.grid.viewsNode"/>
  <class type="dojox.grid._Scroller.grid.viewsNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.grid">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder" superclass="dojox.grid._HeaderBuilder.prototype">
    <methods/>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.generateHtml">
    <methods/>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.generateHtml.view">
    <properties>
      <property name="contentWidth" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.doclick">
    <methods/>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.doclick.view">
    <properties>
      <property name="_selectionChanging" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid._SelectorContentBuilder" superclass="dojox.grid._ContentBuilder.prototype">
    <methods>
      <method name="getCellContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTarget" scope="instance"/>
      <method name="domouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.generateHtml">
    <methods/>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.generateHtml.view">
    <properties>
      <property name="contentWidth" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.doclick">
    <methods/>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.doclick.view.grid.selection">
    <properties>
      <property name="mode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._InputSelectorContentBuilder" superclass="dojox.grid._SelectorContentBuilder.prototype">
    <methods/>
  </class>
  <class type="dojox.grid._InputSelectorContentBuilder.getCellContent">
    <methods/>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Selector" superclass="dojox.grid._View">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="getWidth" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="instance"/>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._View" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="selectionMode" scope="instance" type="String"/>
      <property name="defaultWidth" scope="instance" type="String"/>
      <property name="noscroll" scope="instance" type="Object"/>
      <property name="padBorderWidth" scope="instance" type="Number"/>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
      <property name="contentWidth" scope="instance" type="Number"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Selector.grid.selection">
    <properties>
      <property name="mode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Selector.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._RadioSelector.headerNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._CheckBoxSelector.headerNode.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._CheckBoxSelector.grid">
    <properties>
      <property name="rowCount" scope="instance" type="Object"/>
      <property name="allItemsSelected" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid._Selector.headerNodeContainer.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Expando" superclass="dijit._Widget">
    <methods>
      <method name="_toggleRows" scope="instance">
        <parameters>
          <parameter name="toggleClass" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onToggle" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRowNode" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="open" scope="instance" type="Object"/>
      <property name="toggleClass" scope="instance" type="String"/>
      <property name="itemId" scope="instance" type="String"/>
      <property name="cellIdx" scope="instance" type="Number"/>
      <property name="rowNode" scope="instance" type="Object"/>
      <property name="rowIdx" scope="instance" type="Number"/>
      <property name="expandoCell" scope="instance" type="Object"/>
      <property name="level" scope="instance" type="Number"/>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_tableRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Expando.view"/>
  <class type="dojox.grid._Expando.view.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="treeModel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Expando.expandoInner">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeContentBuilder" superclass="dojox.grid._ContentBuilder">
    <methods>
      <method name="generateHtml" scope="instance">
        <parameters>
          <parameter name="inDataIndex" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="findTarget" scope="instance">
        <parameters>
          <parameter name="inSource" type="Object" usage="required"/>
          <parameter name="inTag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowNode" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decorateEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._ContentBuilder" scope="instance"/>
    </mixins>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeContentBuilder.view.structure.cells">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeContentBuilder.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeView" superclass="dojox.grid._View">
    <methods>
      <method name="_onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onBeforeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._View" scope="instance"/>
    </mixins>
    <properties>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
      <property name="_expandos" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBeforeRow" scope="instance"/>
      <method name="_onAfterRow" scope="instance"/>
      <method name="_cleanupRowWidgets" scope="instance">
        <parameters>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="testFlexCells" scope="instance"/>
      <method name="updateStructure" scope="instance"/>
      <method name="getScrollbarWidth" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getColumnsWidth" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setColumnsWidth" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getContentWidth" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="render" scope="instance"/>
      <method name="_hide" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDropBefore" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="instance"/>
      <method name="_getHeaderContent" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="hasHScrollbar" scope="instance">
        <parameters>
          <parameter name="reset" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasVScrollbar" scope="instance">
        <parameters>
          <parameter name="reset" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="convertColPctToFixed" scope="instance"/>
      <method name="adaptHeight" scope="instance">
        <parameters>
          <parameter name="minusScroll" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="instance"/>
      <method name="setSize" scope="instance">
        <parameters>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRowContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeaderCellNode" scope="instance">
        <parameters>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doscroll" scope="instance">
        <parameters>
          <parameter name="inEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultWidth" scope="instance" type="String"/>
      <property name="viewWidth" scope="instance" type="String"/>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="themeable" scope="instance" type="bool"/>
      <property name="classTag" scope="instance" type="String"/>
      <property name="marginBottom" scope="instance" type="Number"/>
      <property name="rowPad" scope="instance" type="Number"/>
      <property name="_togglingColumn" scope="instance" type="int"/>
      <property name="_headerBuilderClass" scope="instance" type="Object"/>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
      <property name="rowNodes" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
      <property name="structure" scope="instance" type="Object"/>
      <property name="noscroll" scope="instance" type="Object"/>
      <property name="simpleStructure" scope="instance" type="Object"/>
      <property name="flexCells" scope="instance" type="Object"/>
      <property name="bottomMarker" scope="instance" type="Object"/>
      <property name="topMarker" scope="instance" type="Object"/>
      <property name="arrowDim" scope="instance" type="Object"/>
      <property name="_source_conn" scope="instance" type="Object"/>
      <property name="_source_sub" scope="instance" type="Object"/>
      <property name="_removingColumn" scope="instance" type="bool"/>
      <property name="index" scope="instance" type="Object"/>
      <property name="contentWidth" scope="instance" type="Object"/>
      <property name="_hasHScroll" scope="instance" type="bool"/>
      <property name="_hasVScroll" scope="instance" type="bool"/>
      <property name="contentNode" scope="instance" type="Object"/>
      <property name="lastTop" scope="instance" type="Number"/>
      <property name="firstScroll" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNodeContainer.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._View.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerContentNode.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._View.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.source">
    <properties>
      <property name="_targetNode" scope="instance" type="Object"/>
      <property name="_beforeTarget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.grid.views">
    <properties>
      <property name="views" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.grid">
    <properties>
      <property name="initialWidth" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerContentNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.domNode">
    <properties>
      <property name="clientHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.contentNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.domNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.scrollboxNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._GridAvatar" superclass="dojo.dnd.Avatar">
    <methods>
      <method name="construct" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="oldOffsetY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._GridAvatar.manager">
    <properties>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._ViewManager">
    <description>Grid creates views automatically based on grid's layout structure.
	Users should typically not need to access individual views or the views collection directly.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="addView" scope="instance">
        <parameters>
          <parameter name="inView" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyViews" scope="instance"/>
      <method name="getContentNodes" scope="instance"/>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="inCallback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEach" scope="instance">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeHeaderNodeHeight" scope="instance"/>
      <method name="normalizeRowNodeHeights" scope="instance">
        <parameters>
          <parameter name="inRowNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resetHeaderNodeHeight" scope="instance"/>
      <method name="renormalizeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getViewWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measureHeader" scope="instance"/>
      <method name="measureContent" scope="instance"/>
      <method name="findClient" scope="instance">
        <parameters>
          <parameter name="inAutoWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrange" scope="instance">
        <parameters>
          <parameter name="l" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
          <parameter name="skipRenorm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="skipRenorm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstScrollingView" scope="instance"/>
    </methods>
    <properties>
      <property name="defaultWidth" scope="instance" type="Number"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._ViewManager.views">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._DeferredTextWidget" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="deferred" scope="instance" type="Object"/>
      <property name="_destroyOnRemove" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells">
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="dijit" scope="instance" type="Object"/>
      <property name="tree" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inProps" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultFormat" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="callArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
        <return-description>html for a given grid cell</return-description>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="anything" usage="required"/>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
        <return-description>string of html to place in grid cell</return-description>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
        <return-description>dom node for a given grid cell</return-description>
      </method>
      <method name="getHeaderNode" scope="instance"/>
      <method name="getEditNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canResize" scope="instance"/>
      <method name="isFlex" scope="instance"/>
      <method name="applyEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditBlur" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerOnBlur" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needFormatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelFormatNode" scope="instance"/>
      <method name="_formatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="dom" usage="required"/>
          <parameter name="inDatum" type="anything" usage="required"/>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
        <return-description>value of editor</return-description>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
          <parameter name="inValue" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
          <parameter name="inNode" type="dom" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="restore" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="styles" scope="instance" type="String"/>
      <property name="classes" scope="instance" type="String"/>
      <property name="editable" scope="instance" type="bool"/>
      <property name="alwaysEditing" scope="instance" type="bool"/>
      <property name="formatter" scope="instance" type="Object"/>
      <property name="defaultValue" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="hidden" scope="instance" type="bool"/>
      <property name="noresize" scope="instance" type="bool"/>
      <property name="draggable" scope="instance-prototype" type="Object"/>
      <property name="_valueProp" scope="instance" type="String"/>
      <property name="_formatPending" scope="instance" type="bool"/>
      <property name="unitWidth" scope="instance" type="Object"/>
      <property name="_props" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base.grid">
    <properties>
      <property name="formatterScope" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base.grid.edit">
    <properties>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Cell" superclass="dojox.grid.cells._Base">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="keyFilter" scope="instance-prototype" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.RowIndex" superclass="dojox.grid.cells.Cell">
    <methods>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.Cell" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="editable" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Select" superclass="dojox.grid.cells.Cell">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.Cell" scope="instance"/>
    </mixins>
    <properties>
      <property name="options" scope="instance" type="Array"/>
      <property name="values" scope="instance-prototype" type="Array"/>
      <property name="returnIndex" scope="instance" type="Integer"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.AlwaysEdit" superclass="dojox.grid.cells.Cell">
    <methods>
      <method name="_formatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStaticValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.Cell" scope="instance"/>
    </mixins>
    <properties>
      <property name="alwaysEditing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.AlwaysEdit.grid">
    <properties>
      <property name="edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Bool" superclass="dojox.grid.cells.AlwaysEdit">
    <methods>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.AlwaysEdit" scope="instance"/>
    </mixins>
    <properties>
      <property name="_valueProp" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Widget" superclass="dojox.grid.cells._Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attachWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
      <property name="widget" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.ComboBox" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.DateTextBox" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.CheckBox" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="getValue" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Editor" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="populateEditor" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAggregate">
    <methods/>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAggregate.grid.edit">
    <properties>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.getOpenState">
    <methods/>
    <properties>
      <property name="openStates" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.getOpenState.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._Events">
    <description>Methods are copied or replaced for overwriting, this might be refined once
	an overall plugin architecture is set up for DataGrid.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseup" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domousedown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectedRegionContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowSelectorMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowSelectorMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUpRow" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_events" scope="instance-prototype" type="Object"/>
      <property name="headerCellActiveClass" scope="instance" type="String"/>
      <property name="cellActiveClass" scope="instance" type="String"/>
      <property name="rowActiveClass" scope="instance" type="String"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._Events._click">
    <properties>
      <property name="0" scope="instance" type="Object"/>
      <property name="1" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusArea">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
          <parameter name="focusManager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="funcName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="keydown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="keyup" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="contentMouseEventPlanner" scope="instance"/>
      <method name="headerMouseEventPlanner" scope="instance"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="string"/>
      <property name="onFocus" scope="instance" type="function(event,"/>
      <property name="onBlur" scope="instance" type="function(event,"/>
      <property name="onMove" scope="instance" type="function(rowStep,"/>
      <property name="onKey" scope="instance" type="function(event,"/>
      <property name="getRegions" scope="instance" type="function()"/>
      <property name="onRegionFocus" scope="instance" type="function(event)"/>
      <property name="onRegionBlur" scope="instance" type="function(event)"/>
      <property name="_fm" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusArea._evtStack">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager" superclass="dojox.grid._FocusManager">
    <methods>
      <method name="_stopEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_bindAreaEvents" scope="instance"/>
      <method name="removeArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="currentArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="String" usage="required"/>
          <parameter name="toBlurOld" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeArea" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="otherAreaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ignoreArea" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusArea" scope="instance">
        <parameters>
          <parameter name="areaId" type="int|string|areaObj" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tab" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEvent" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="contentMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="headerMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initFocusView" scope="instance"/>
      <method name="isNavHeader" scope="instance"/>
      <method name="previousKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="doFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doBlur" scope="instance"/>
      <method name="doLastNodeFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_delayedHeaderFocus" scope="instance"/>
      <method name="_delayedCellFocus" scope="instance"/>
      <method name="_changeMenuBindNode" scope="instance">
        <parameters>
          <parameter name="oldBindNode" type="Object" usage="required"/>
          <parameter name="newBindNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_navHeader" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setActiveColHeader" scope="instance"/>
      <method name="findAndFocusGridCell" scope="instance"/>
      <method name="_focusContent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurContent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_navContent" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="inRowDelta" type="Object" usage="required"/>
          <parameter name="inColDelta" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onContentKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_focusEditableCell" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyEditableCell" scope="instance"/>
      <method name="_blurEditableCell" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initNavigatableElems" scope="instance"/>
      <method name="_onEditableCellKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditableCellMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._FocusManager" scope="instance"/>
    </mixins>
    <properties>
      <property name="_areas" scope="instance-prototype" type="Object"/>
      <property name="_currentAreaIdx" scope="instance-prototype" type="Number"/>
      <property name="tabbingOut" scope="instance" type="bool"/>
      <property name="_areaQueue" scope="instance-prototype" type="Array"/>
      <property name="_gridBlured" scope="instance-prototype" type="Object"/>
      <property name="focusView" scope="instance" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
      <property name="rowIndex" scope="instance" type="Object"/>
      <property name="_contextMenuBindNode" scope="instance" type="Object"/>
      <property name="_colHeadNode" scope="instance" type="Object"/>
      <property name="_colHeadFocusIdx" scope="instance" type="Object"/>
      <property name="_blurFromEditableCell" scope="instance" type="Object"/>
      <property name="_isNavigating" scope="instance" type="Object"/>
      <property name="_contentMouseEventHandlers" scope="instance" type="Array"/>
      <property name="_headerMouseEventHandlers" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager.grid">
    <properties>
      <property name="headerMenu" scope="instance" type="Object"/>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager._navElems">
    <properties>
      <property name="lowest" scope="instance" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager.grid.layout">
    <properties>
      <property name="cellCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._Plugin">
    <description>Provides common plugin functionality and basic life cycle management.
	Each concrete plugin must have a name field and is responsible for registering itself to the global plugin registry
	e.g. for dnd plugin:
			dojox.grid.EnhancedGrid.registerPlugin("dnd" /*plugin name*/,
													dojox.grid.enhanced.plugins.DnD /*full class name of a plugin
													{"preInit": false, "dependency": ["nestedSorting"]} /*properties*/);
	[Keywords] of plugin properties(case sensitive)
	- "preInit": boolean, whether a plugin should be created before EnhancedGrid.postCreate(),
	false by default(plugins are created after EnhancedGrid.postCreate()).
	- "dependency": array or string, plugin(s) indicated by "dependency" will be created before the current one.
	Note: recursive cycle dependencies are not supported e.g. following dependency is invalid:
	pluginA -&gt; pluginB -&gt; pluginA</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="onPreInit" scope="instance"/>
      <method name="onPostInit" scope="instance"/>
      <method name="onStartUp" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="option" scope="instance-prototype" type="Object"/>
      <property name="_connects" scope="instance-prototype" type="Array"/>
      <property name="_subscribes" scope="instance-prototype" type="Array"/>
      <property name="privates" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager">
    <description>Plugin manager is responsible for
	1. Loading required plugins
	2. Handling collaboration and dependencies among plugins
	Some plugin dependencies:
	- "columnReordering" attribute won't work when either DnD or Indirect Selections plugin is on.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="preInit" scope="instance"/>
      <method name="postInit" scope="instance"/>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="func" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseProps" scope="instance">
        <parameters>
          <parameter name="plugins" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalize" scope="instance">
        <parameters>
          <parameter name="p" type="String" usage="required"/>
          <parameter name="plugins" type="Object" usage="required"/>
          <parameter name="registry" type="Object" usage="required"/>
          <parameter name="loading" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="pre" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="loadPlugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="return if no plugin option"/>
          <return-type type="return if plugin(&quot;name&quot;) already existed"/>
        </return-types>
      </method>
      <method name="_initView" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pluginExisted" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getPlugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getPluginClazz" scope="instance">
        <parameters>
          <parameter name="clazz" type="class" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="return if it's already a clazz"/>
        </return-types>
      </method>
      <method name="isFixedCell" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="registerPlugin" scope="instance">
        <parameters>
          <parameter name="clazz" type="String" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_connects" scope="instance-prototype" type="Array"/>
      <property name="_store" scope="instance" type="Object"/>
      <property name="registry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager.grid">
    <properties>
      <property name="focus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager.grid.edit">
    <methods>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced._PluginManager._options">
    <properties>
      <property name="columnReordering" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager._plugins">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins">
    <methods>
      <method name="wrap" scope="instance">
        <parameters>
          <parameter name="store" type="Read-store" usage="required"/>
          <parameter name="funcName" type="Object" usage="required"/>
          <parameter name="layer" type="_StoreLayer" usage="required"/>
          <parameter name="layerFuncName" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Read-store"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.AutoScroll" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initEvents" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_fireEvent" scope="instance">
        <parameters>
          <parameter name="eventName" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_manageAutoScroll" scope="instance">
        <parameters>
          <parameter name="toStop" type="Object" usage="required"/>
          <parameter name="isVertical" type="Object" usage="required"/>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScroll" scope="instance">
        <parameters>
          <parameter name="isVertical" type="Object" usage="required"/>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollColumn" scope="instance">
        <parameters>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="autoScrollInterval" scope="instance-prototype" type="Integer"/>
      <property name="autoScrollMargin" scope="instance-prototype" type="Integer"/>
      <property name="_scrolling" scope="instance-prototype" type="bool"/>
      <property name="_handler" scope="instance" type="Object"/>
      <property name="readyForAutoScroll" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.AutoScroll.grid">
    <methods>
      <method name="onStartAutoScroll" scope="instance"/>
      <method name="onEndAutoScroll" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mergeCells" scope="instance">
        <parameters>
          <parameter name="rowTester" type="function(Integer)|Integer" usage="required"/>
          <parameter name="startColumnIndex" type="Integer" usage="required"/>
          <parameter name="endColumnIndex" type="Integer" usage="required"/>
          <parameter name="majorColumnIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="unmergeCells" scope="instance">
        <parameters>
          <parameter name="mergeHandler" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getMergedCells" scope="instance"/>
      <method name="getMergedCellsByRow" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setupConfig" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initEvents" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_getWidth" scope="instance">
        <parameters>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onAfterRow" scope="instance">
        <parameters>
          <parameter name="viewIdx" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="subrows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRecord" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isValid" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateRows" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="_merged" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid">
    <properties>
      <property name="mergeCells" scope="instance" type="Object"/>
      <property name="unmergeCells" scope="instance" type="Object"/>
      <property name="getMergedCells" scope="instance" type="Object"/>
      <property name="getMergedCellsByRow" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge._records">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid.layout"/>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid.layout.cells">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Cookie" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_saveCookie" scope="instance"/>
      <method name="onPreInit" scope="instance"/>
      <method name="addCookieHandler" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeCookie" scope="instance"/>
      <method name="setCookieEnabled" scope="instance">
        <parameters>
          <parameter name="cookieName" type="String" usage="optional"/>
          <parameter name="enabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getCookieEnabled" scope="instance">
        <parameters>
          <parameter name="cookieName" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="_cookieEnabled" scope="instance" type="bool"/>
      <property name="_cookieHandlers" scope="instance-prototype" type="Array"/>
      <property name="_cookie" scope="instance" type="Object"/>
      <property name="_cookieStartedup" scope="instance" type="Object"/>
      <property name="cookieProps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Cookie.grid">
    <properties>
      <property name="addCookieHandler" scope="instance" type="Object"/>
      <property name="removeCookie" scope="instance" type="Object"/>
      <property name="setCookieEnabled" scope="instance" type="Object"/>
      <property name="getCookieEnabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Dialog" superclass="dijit.Dialog">
    <methods>
      <method name="_position" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="refNode" scope="instance" type="Object"/>
      <property name="_relativePosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="setupConfig" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="copyOnly" scope="instance">
        <parameters>
          <parameter name="isCopyOnly" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isOutOfGrid" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="instance"/>
      <method name="_initEvents" scope="instance"/>
      <method name="_clear" scope="instance"/>
      <method name="_getDnDRegion" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startDnd" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endDnd" scope="instance">
        <parameters>
          <parameter name="destroySource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createDnDUI" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="isMovingIn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyDnDUI" scope="instance">
        <parameters>
          <parameter name="isMovingOut" type="Object" usage="required"/>
          <parameter name="destroySource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createSource" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroySource" scope="instance"/>
      <method name="_createMoveable" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyMoveable" scope="instance"/>
      <method name="_calcColTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcRowTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcCellTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
          <parameter name="targetAnchor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_getVisibleHeaders" scope="instance"/>
      <method name="_rearrange" scope="instance"/>
      <method name="onDraggingOver" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mapRegion" scope="instance">
        <parameters>
          <parameter name="srcGrid" type="Object" usage="required"/>
          <parameter name="dndRegion" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOut" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragIn" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
          <parameter name="isCopy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragOut" scope="instance">
        <parameters>
          <parameter name="isMove" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_canAccept" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_allDnDItemsLoaded" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String,"/>
      <property name="_targetAnchorBorderWidth" scope="instance" type="Number"/>
      <property name="_copyOnly" scope="instance-prototype" type="bool"/>
      <property name="_container" scope="instance-prototype" type="Object"/>
      <property name="rearranger" scope="instance-prototype" type="Object"/>
      <property name="_dnding" scope="instance" type="bool"/>
      <property name="_oldCursor" scope="instance" type="Object"/>
      <property name="_alreadyOut" scope="instance" type="bool"/>
      <property name="_moveEvent" scope="instance" type="Object"/>
      <property name="_target" scope="instance" type="Object"/>
      <property name="_targetAnchor" scope="instance" type="Object"/>
      <property name="_externalDnd" scope="instance" type="Object"/>
      <property name="_isSource" scope="instance" type="bool"/>
      <property name="_extDnding" scope="instance" type="bool"/>
      <property name="_markTagetAnchorHandler" scope="instance" type="Object"/>
      <property name="_elem" scope="instance" type="Object"/>
      <property name="_source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._config"/>
  <class type="dojox.grid.enhanced.plugins.DnD._config.row">
    <properties>
      <property name="within" scope="instance" type="Object"/>
      <property name="in" scope="instance" type="Object"/>
      <property name="out" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._config.col">
    <properties>
      <property name="within" scope="instance" type="Object"/>
      <property name="in" scope="instance" type="Object"/>
      <property name="out" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._config.cell">
    <properties>
      <property name="within" scope="instance" type="Object"/>
      <property name="in" scope="instance" type="Object"/>
      <property name="out" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.grid">
    <properties>
      <property name="setupDnDConfig" scope="instance" type="Object"/>
      <property name="dndCopyOnly" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
      <property name="_by_idx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.selector">
    <properties>
      <property name="_selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.layout"/>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.layout.cells">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion">
    <properties>
      <property name="handle" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.scroller">
    <properties>
      <property name="firstVisibleRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected.0.min">
    <properties>
      <property name="row" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected.0.max">
    <properties>
      <property name="row" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDElement">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="dndPlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="createDnDNodes" scope="instance">
        <parameters>
          <parameter name="dndRegion" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDnDNodes" scope="instance"/>
      <method name="destroyDnDNodes" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="nodeId" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="plugin" scope="instance-prototype" type="Object"/>
      <property name="node" scope="instance-prototype" type="Object"/>
      <property name="_items" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDSource" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="param" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="nodeId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="accept" scope="instance" type="Array"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="dndElem" scope="instance-prototype" type="Object"/>
      <property name="dndPlugin" scope="instance-prototype" type="Object"/>
      <property name="sourcePlugin" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar" superclass="dojo.dnd.Avatar">
    <methods>
      <method name="construct" scope="instance"/>
      <method name="_getItemCount" scope="instance"/>
      <method name="_getGridDnDIconClass" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="_itemType" scope="instance" type="Object"/>
      <property name="_itemCount" scope="instance" type="Object"/>
      <property name="isA11y" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar.manager">
    <properties>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar.manager._dndPlugin.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Exporter" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="EnhancedGrid" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="setExportFormatter" scope="instance">
        <parameters>
          <parameter name="formatter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="exportGrid" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
          <parameter name="args" type="object" usage="optional"/>
          <parameter name="onExported" type="function(string)" usage="required"/>
        </parameters>
      </method>
      <method name="exportSelected" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
        <return-description>string
	The exported string</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_buildRow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
          <parameter name="writer" type="ExportWriter" usage="required"/>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="_goThroughGridData" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="writer" type="ExportWriter" usage="required"/>
        </parameters>
      </method>
      <method name="_isSpecialCol" scope="instance">
        <parameters>
          <parameter name="header_cell" type="dojox.grid.__CellDef" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getExportWriter" scope="instance">
        <parameters>
          <parameter name="fileType" type="string" usage="required"/>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="ExportWriter"/>
        </return-types>
      </method>
      <method name="registerWriter" scope="instance">
        <parameters>
          <parameter name="fileType" type="string" usage="required"/>
          <parameter name="writerClsName" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="formatter" scope="instance-prototype" type="Object"/>
      <property name="writerNames" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Exporter.grid">
    <properties>
      <property name="exportTo" scope="instance" type="Object"/>
      <property name="exportGrid" scope="instance" type="Object"/>
      <property name="exportSelected" scope="instance" type="Object"/>
      <property name="setExportFormatter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Filter" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_wrapStore" scope="instance"/>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clientFilterGetter" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="cell" type="cell" usage="required"/>
          <parameter name="rowIndex" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="filterBar" scope="instance-prototype" type="Object"/>
      <property name="clearFilterDialog" scope="instance-prototype" type="Object"/>
      <property name="filterStatusTip" scope="instance-prototype" type="Object"/>
      <property name="filterDefDialog" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="nls" scope="instance-prototype" type="Object"/>
      <property name="args" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridSource" superclass="dojo.dnd.Source">
    <methods>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="onDropExternal" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="leftTopCell" type="Object" usage="required"/>
          <parameter name="rightBottomCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="rowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="colIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropGridCells" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="leftTopCell" type="Object" usage="required"/>
          <parameter name="rightBottomCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropGridRows" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="rowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropGridColumns" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="colIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="accept" scope="instance" type="Array"/>
      <property name="insertNodesForGrid" scope="instance" type="If"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridSource.sourcePlugin">
    <properties>
      <property name="_isSource" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.IndirectSelection" superclass="dojox.grid.enhanced._Plugin">
    <description>For better rendering performance, div(images) are used to simulate radio button|check boxes</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="addRowSelectCell" scope="instance">
        <parameters>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="cellCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.IndirectSelection.grid">
    <properties>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.RowSelector" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="formatter" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleRow" scope="instance">
        <parameters>
          <parameter name="index" type="Integer" usage="required"/>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="disabled" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_focusEndingCell" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required"/>
          <parameter name="cellIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_nativeSelect" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSelected" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDeselected" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpdateRow" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleCheckedStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleDisabledStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getSelector" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pageDestroyed" scope="instance">
        <parameters>
          <parameter name="pageIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="map" scope="instance-prototype" type="Object"/>
      <property name="disabledMap" scope="instance-prototype" type="Object"/>
      <property name="isRowSelector" scope="instance" type="Boolean"/>
      <property name="_connects" scope="instance-prototype" type="Array"/>
      <property name="_subscribes" scope="instance-prototype" type="Array"/>
      <property name="checkedText" scope="instance" type="String"/>
      <property name="unCheckedText" scope="instance" type="String"/>
      <property name="baseClass" scope="instance-prototype" type="String"/>
      <property name="disabledCount" scope="instance" type="Number"/>
      <property name="inA11YMode" scope="instance" type="Object"/>
      <property name="checkedClass" scope="instance" type="String"/>
      <property name="disabledClass" scope="instance" type="String"/>
      <property name="checkedDisabledClass" scope="instance" type="String"/>
      <property name="statusTextClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.RowSelector.grid.scroller">
    <properties>
      <property name="rowsPerPage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.SingleRowSelector" superclass="dojox.grid.cells.RowSelector">
    <methods>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.RowSelector" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.MultipleRowSelector" superclass="dojox.grid.cells.RowSelector">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="toggleAllSelection" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRowMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_domouseup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_startSelection" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelection" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="delta" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_swipeByKey" scope="instance">
        <parameters>
          <parameter name="rowOffset" type="Integer" usage="required"/>
          <parameter name="colOffset" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_finishSelect" scope="instance"/>
      <method name="inSwipeSelection" scope="instance"/>
      <method name="_nativeSelect" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addHeaderSelector" scope="instance"/>
      <method name="_toggletHeader" scope="instance"/>
      <method name="_onSelectionChanged" scope="instance"/>
      <method name="_toggleDisabledStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.RowSelector" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="swipeStartRowIndex" scope="instance" type="Integer"/>
      <property name="swipeMinRowIndex" scope="instance" type="Integer"/>
      <property name="swipeMaxRowIndex" scope="instance" type="Number"/>
      <property name="toSelect" scope="instance" type="Boolean"/>
      <property name="lastClickRowIdx" scope="instance" type="Integer"/>
      <property name="toggleAllTrigerred" scope="instance" type="Boolean"/>
      <property name="unCheckedText" scope="instance" type="String"/>
      <property name="_headerSelectorConnectIdx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.MultipleRowSelector.grid">
    <properties>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_selectingRange" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Menu" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onStartUp" scope="instance"/>
      <method name="_initMenu" scope="instance">
        <parameters>
          <parameter name="menuType" type="String" usage="required"/>
          <parameter name="menu" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenuWidget" scope="instance">
        <parameters>
          <parameter name="menu" type="String|Widget(dijit.Menu)" usage="required"/>
        </parameters>
      </method>
      <method name="_setRowMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="Widget(dijit.Menu)" usage="required"/>
        </parameters>
      </method>
      <method name="_setCellMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="Widget(dijit.Menu)" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedRegionMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="Widget(dijit.Menu)" usage="required"/>
        </parameters>
      </method>
      <method name="_setMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="Widget(dijit.Menu)" usage="required"/>
          <parameter name="menuType" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="showMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="Array"/>
      <property name="types" scope="instance" type="Array"/>
      <property name="option" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Menu.grid">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="showMenu" scope="instance" type="Object"/>
      <property name="_setRowMenuAttr" scope="instance" type="Object"/>
      <property name="_setCellMenuAttr" scope="instance" type="Object"/>
      <property name="_setSelectedRegionMenuAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting" superclass="dojox.grid.enhanced._Plugin">
    <description>A flexible way to control multiple column sorting, including
	1. Set default sorting order
	2. Disable sorting for certain columns
	3. Set sorting order dynamically with JS API</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onStartUp" scope="instance"/>
      <method name="_setGridSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inAsc" type="Object" usage="required"/>
          <parameter name="noRefresh" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="header click from base DataGrid"/>
        </return-types>
      </method>
      <method name="getSortProps" scope="instance"/>
      <method name="_initSort" scope="instance">
        <parameters>
          <parameter name="postSort" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initHeaderNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSortBtnClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSortData" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSortData" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareSingleSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareNestedSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSortDef" scope="instance"/>
      <method name="_updateHeaderNodeUI" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isAsc" scope="instance">
        <parameters>
          <parameter name="cellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDesc" scope="instance">
        <parameters>
          <parameter name="cellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCellByNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSort" scope="instance"/>
      <method name="initCookieHandler" scope="instance"/>
      <method name="_loadNestedSortingProps" scope="instance">
        <parameters>
          <parameter name="sortInfo" type="Object" usage="required"/>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveNestedSortingProps" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initFocus" scope="instance"/>
      <method name="_focusHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMove" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRegionView" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRegions" scope="instance"/>
      <method name="_focusRegion" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurRegion" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentRegion" scope="instance"/>
      <method name="_getRegionHeader" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="_currMainSort" scope="instance" type="String"/>
      <property name="_currRegionIdx" scope="instance" type="Object"/>
      <property name="_excludedCoIdx" scope="instance" type="Array"/>
      <property name="_headerNodes" scope="instance-prototype" type="Object"/>
      <property name="_connects" scope="instance" type="Object"/>
      <property name="_sortData" scope="instance-prototype" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="_focusRegions" scope="instance" type="Object"/>
      <property name="_headerArea" scope="instance" type="Object"/>
      <property name="_excludedColIdx" scope="instance" type="Array"/>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting._a11yText">
    <properties>
      <property name="dojoxGridDescending" scope="instance" type="String"/>
      <property name="dojoxGridAscending" scope="instance" type="String"/>
      <property name="dojoxGridAscendingTip" scope="instance" type="String"/>
      <property name="dojoxGridDescendingTip" scope="instance" type="String"/>
      <property name="dojoxGridUnsortedTip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting.grid">
    <methods>
      <method name="setSortInfo" scope="instance"/>
    </methods>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="setSortIndex" scope="instance" type="Object"/>
      <property name="getSortProps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting._sortDef">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Pagination" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="init" scope="instance"/>
      <method name="_createPaginators" scope="instance">
        <parameters>
          <parameter name="paginationArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_wrapStoreLayer" scope="instance"/>
      <method name="_stopEvent" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeSelectedRows" scope="instance"/>
      <method name="_onDelete" scope="instance"/>
      <method name="_regApis" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="nextPage" scope="instance"/>
      <method name="prevPage" scope="instance"/>
      <method name="gotoPage" scope="instance">
        <parameters>
          <parameter name="page" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="gotoFirstPage" scope="instance"/>
      <method name="gotoLastPage" scope="instance"/>
      <method name="changePageSize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showGotoPageButton" scope="instance">
        <parameters>
          <parameter name="flag" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="scrollToRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="integer" usage="required"/>
        </parameters>
      </method>
      <method name="getTotalRowCount" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="pageSize" scope="instance" type="Number"/>
      <property name="defaultRows" scope="instance" type="Number"/>
      <property name="_currentPage" scope="instance" type="Number"/>
      <property name="_maxSize" scope="instance" type="Number"/>
      <property name="gh" scope="instance" type="Object"/>
      <property name="nls" scope="instance" type="Object"/>
      <property name="paginators" scope="instance" type="Object"/>
      <property name="_store" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="forcePageStoreLayer" scope="instance" type="Object"/>
      <property name="_multiRemoving" scope="instance" type="bool"/>
      <property name="originalScrollToRow" scope="instance" type="Object"/>
      <property name="_originalOnNew" scope="instance" type="Object"/>
      <property name="_originalRemove" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Pagination.grid">
    <properties>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="usingPagination" scope="instance" type="Object"/>
      <property name="gotoPage" scope="instance" type="Object"/>
      <property name="nextPage" scope="instance" type="Object"/>
      <property name="prevPage" scope="instance" type="Object"/>
      <property name="gotoFirstPage" scope="instance" type="Object"/>
      <property name="gotoLastPage" scope="instance" type="Object"/>
      <property name="changePageSize" scope="instance" type="Object"/>
      <property name="showGotoPageButton" scope="instance" type="Object"/>
      <property name="getTotalRowCount" scope="instance" type="Object"/>
      <property name="scrollToRow" scope="instance" type="Object"/>
      <property name="removeSelectedRows" scope="instance" type="Object"/>
      <property name="_onNew" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._ForcedPageStoreLayer" superclass="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._StoreLayer" scope="instance"/>
    </mixins>
    <properties>
      <property name="tags" scope="instance" type="Array"/>
      <property name="_plugin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_setWidthValue" scope="instance"/>
      <method name="_regFocusMgr" scope="instance">
        <parameters>
          <parameter name="position" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeSelf" scope="instance"/>
      <method name="_resetGridHeight" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_styleMsgNode" scope="instance">
        <parameters>
          <parameter name="top" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateDescription" scope="instance"/>
      <method name="_updateSizeSwitch" scope="instance"/>
      <method name="_createSizeSwitchNodes" scope="instance"/>
      <method name="_updateSwitchNodeClass" scope="instance"/>
      <method name="_updatePageStepper" scope="instance"/>
      <method name="_createPageStepNodes" scope="instance"/>
      <method name="_createWardBtns" scope="instance"/>
      <method name="_resetPageStepNodes" scope="instance"/>
      <method name="_updatePageStepNodeClass" scope="instance"/>
      <method name="_showGotoButton" scope="instance">
        <parameters>
          <parameter name="flag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateGotoButton" scope="instance"/>
      <method name="_createGotoNode" scope="instance"/>
      <method name="_openGotopageDialog" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusPaginator" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusPageSizeNode" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusPageStepNode" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusGotoPageNode" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlurPaginator" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveFocus" scope="instance">
        <parameters>
          <parameter name="rowDelta" type="Object" usage="required"/>
          <parameter name="colDelta" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageSizeActivableNodes" scope="instance"/>
      <method name="_getPageStepActivableNodes" scope="instance"/>
      <method name="_getAllPageSizeNodes" scope="instance"/>
      <method name="_getAllPageStepNodes" scope="instance"/>
      <method name="_moveToNextActivableNode" scope="instance">
        <parameters>
          <parameter name="nodeList" type="Object" usage="required"/>
          <parameter name="curNodeValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSwitchPageSize" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onPageStep" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentPageNo" scope="instance"/>
      <method name="_getPageCount" scope="instance"/>
      <method name="_getStartPage" scope="instance"/>
      <method name="_getStepPageSize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="position" scope="instance" type="String"/>
      <property name="_maxItemSize" scope="instance" type="Object"/>
      <property name="description" scope="instance" type="Object"/>
      <property name="pageStepper" scope="instance" type="Object"/>
      <property name="maxPageStep" scope="instance" type="Number"/>
      <property name="sizeSwitch" scope="instance" type="Object"/>
      <property name="pageSizes" scope="instance" type="Object"/>
      <property name="gotoButton" scope="instance" type="bool"/>
      <property name="_originalResize" scope="instance" type="Object"/>
      <property name="currentPageSize" scope="instance" type="Object"/>
      <property name="_resultSize" scope="instance" type="Object"/>
      <property name="pageSizeValue" scope="instance" type="Object"/>
      <property name="initializedSizeNode" scope="instance" type="Object"/>
      <property name="pageStepValue" scope="instance" type="Object"/>
      <property name="gotoPageTd" scope="instance" type="Object"/>
      <property name="gotoPageDiv" scope="instance" type="Object"/>
      <property name="_gotoPageDialog" scope="instance" type="Object"/>
      <property name="_currentFocusNode" scope="instance" type="Object"/>
      <property name="focusArea" scope="instance" type="String"/>
      <property name="itemTitle" scope="instance" type="Object"/>
      <property name="descTemplate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.grid">
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_pendingChangeSize" scope="instance" type="Object"/>
      <property name="_pendingResultSize" scope="instance" type="Object"/>
      <property name="messagesNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.plugin">
    <properties>
      <property name="gh" scope="instance" type="String"/>
      <property name="forcePageStoreLayer" scope="instance" type="Object"/>
      <property name="showAll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.descriptionDiv">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.pageStepperDiv"/>
  <class type="dojox.grid.enhanced.plugins._Paginator.pageStepperDiv.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.plugin.grid">
    <properties>
      <property name="usingPagination" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination"/>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createDialogContent" scope="instance"/>
      <method name="_styleContent" scope="instance"/>
      <method name="updatePageCount" scope="instance"/>
      <method name="showDialog" scope="instance"/>
      <method name="_onConfirm" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCancel" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setConfirmBtnState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="pageCount" scope="instance-prototype" type="Object"/>
      <property name="_specifyNode" scope="instance" type="Object"/>
      <property name="_pageInputDiv" scope="instance" type="Object"/>
      <property name="_pageLabel" scope="instance" type="Object"/>
      <property name="_buttonDiv" scope="instance" type="Object"/>
      <property name="_confirmBtn" scope="instance" type="Object"/>
      <property name="_cancelBtn" scope="instance" type="Object"/>
      <property name="plugin" scope="instance" type="Object"/>
      <property name="_dialogNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog._pageTextBox">
    <properties>
      <property name="constraints" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog._gotoPageDialog">
    <properties>
      <property name="onCancel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Printer" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="printGrid" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="printSelected" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="exportToHTML" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional"/>
          <parameter name="onExported" type="function(string)" usage="required"/>
        </parameters>
      </method>
      <method name="exportSelectedToHTML" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_print" scope="instance">
        <parameters>
          <parameter name="htmlStr" type="string" usage="required"/>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="_wrapHTML" scope="instance">
        <parameters>
          <parameter name="title" type="string" usage="required"/>
          <parameter name="cssFiles" type="Array" usage="required"/>
          <parameter name="body_content" type="string" usage="required"/>
        </parameters>
        <return-description>the wrapped HTML string ready for print</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="normalizeRowHeight" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_formalizeArgs" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="_printFrame" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Printer.grid">
    <properties>
      <property name="printGrid" scope="instance" type="Object"/>
      <property name="printSelected" scope="instance" type="Object"/>
      <property name="exportToHTML" scope="instance" type="Object"/>
      <property name="exportSelectedToHTML" scope="instance" type="Object"/>
      <property name="normalizePrintedGrid" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setArgs" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hasIdentity" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveColumns" scope="instance">
        <parameters>
          <parameter name="colsToMove" type="Integer[]" usage="required"/>
          <parameter name="targetPos" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="moveRows" scope="instance">
        <parameters>
          <parameter name="rowsToMove" type="Integer[]" usage="required"/>
          <parameter name="targetPos" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="moveCells" scope="instance">
        <parameters>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="copyCells" scope="instance">
        <parameters>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changeCells" scope="instance">
        <parameters>
          <parameter name="sourceGrid" type="Object" usage="required"/>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearCells" scope="instance">
        <parameters>
          <parameter name="cellsToClear" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertRows" scope="instance">
        <parameters>
          <parameter name="sourceGrid" type="Object" usage="required"/>
          <parameter name="rowsToMove" type="Object" usage="required"/>
          <parameter name="targetPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRows" scope="instance">
        <parameters>
          <parameter name="rowsToRemove" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageInfo" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.args">
    <methods>
      <method name="setIdentifierForNewItem" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="_notRefreshSelection" scope="instance" type="Object"/>
      <property name="_noInternalMapping" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.selection">
    <properties>
      <property name="selected" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.scroller">
    <properties>
      <property name="firstVisibleRow" scope="instance" type="Object"/>
      <property name="lastVisibleRow" scope="instance" type="Object"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.scroller.pageNodes">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Search" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="searchRow" scope="instance">
        <parameters>
          <parameter name="searchArgs" type="Object|RegExp|String" usage="required"/>
          <parameter name="onSearched" type="function(Integer," usage="required"/>
        </parameters>
      </method>
      <method name="_search" scope="instance">
        <parameters>
          <parameter name="searchArgs" type="Object|RegExp" usage="required"/>
          <parameter name="start" type="Integer" usage="required"/>
          <parameter name="onSearched" type="function(Integer," usage="required"/>
          <parameter name="isGlobal" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_checkRow" scope="instance">
        <parameters>
          <parameter name="item" type="store" usage="required"/>
          <parameter name="searchArgs" type="Object|RegExp" usage="required"/>
          <parameter name="isGlobal" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="_cacheSize" scope="instance-prototype" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Search.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="__SelectCellItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="row" scope="instance" type="Integer"/>
      <property name="col" scope="instance" type="Integer"/>
    </properties>
  </class>
  <class type="__SelectRowItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="row" scope="instance" type="Integer"/>
      <property name="except" scope="instance" type="Integer[]"/>
    </properties>
  </class>
  <class type="__SelectColItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="col" scope="instance" type="Integer"/>
      <property name="except" scope="instance" type="Integer[]"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setupConfig" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="rowIndex" type="Integer" usage="required"/>
          <parameter name="colIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="toggleSelect" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="rowIndex" type="Integer" usage="required"/>
          <parameter name="colIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="start" type="Integer" usage="required"/>
          <parameter name="end" type="Integer" usage="required"/>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="isSelecting" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="selectEnabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="includeExceptions" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedCount" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="includeExceptions" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedType" scope="instance"/>
      <method name="getLastSelectedRange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hacks" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_initEvents" scope="instance"/>
      <method name="_onSelectedById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="newIndex" type="Object" usage="required"/>
          <parameter name="isSelected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetStore" scope="instance"/>
      <method name="_onInternalRearrange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="mapping" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onExternalChange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshSelected" scope="instance"/>
      <method name="_initAreas" scope="instance"/>
      <method name="_clearSelection" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="reservedItem" type="__SelectItem" usage="required"/>
        </parameters>
      </method>
      <method name="_startSelect" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="start" type="__SelectItem" usage="required"/>
          <parameter name="extending" type="Boolean" usage="required"/>
          <parameter name="isRange" type="Boolean" usage="required"/>
          <parameter name="mandatarySelect" type="Boolean" usage="required"/>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endSelect" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fireEvent" scope="instance">
        <parameters>
          <parameter name="evtName" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcToHighlight" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightHeader" scope="instance">
        <parameters>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightRowSelector" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightSingle" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toSelect" type="Object" usage="required"/>
          <parameter name="isRefresh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlight" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toSelect" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_focusPoint" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="point" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurPoint" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="point" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addToSelected" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forEach" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
          <parameter name="halfClose" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeupForExceptions" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="newCellItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeupForCells" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="newItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addException" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addCellException" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isCellNotInExcept" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isSelected" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInLastRange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isSelected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isValid" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="allowNotSelectable" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="_enabled" scope="instance-prototype" type="Object"/>
      <property name="_selected" scope="instance-prototype" type="Object"/>
      <property name="_oldDeselectAll" scope="instance" type="Object"/>
      <property name="_lastFocusedRowBarIdx" scope="instance" type="Number"/>
      <property name="_isUsingRowSelector" scope="instance" type="Object"/>
      <property name="_toSelect" scope="instance" type="Object"/>
      <property name="_curType" scope="instance" type="Object"/>
      <property name="_isStartFocus" scope="instance" type="bool"/>
      <property name="_lastType" scope="instance-prototype" type="Object"/>
      <property name="_selectedRowModified" scope="instance-prototype" type="Object"/>
      <property name="_selecting" scope="instance" type="Object"/>
      <property name="_startPoint" scope="instance" type="Object"/>
      <property name="_currentPoint" scope="instance" type="Object"/>
      <property name="_lastAnchorPoint" scope="instance" type="Object"/>
      <property name="_lastEndPoint" scope="instance" type="Object"/>
      <property name="_lastSelectedAnchorPoint" scope="instance" type="Object"/>
      <property name="_lastSelectedEndPoint" scope="instance" type="Object"/>
      <property name="_keyboardSelect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid">
    <methods>
      <method name="onStartSelect" scope="instance"/>
      <method name="onEndSelect" scope="instance"/>
      <method name="onStartDeselect" scope="instance"/>
      <method name="onEndDeselect" scope="instance"/>
      <method name="onSelectCleared" scope="instance"/>
    </methods>
    <properties>
      <property name="_selectingRange" scope="instance" type="bool"/>
      <property name="setupSelectorConfig" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.selection">
    <methods>
      <method name="clickSelect" scope="instance"/>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectRange" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance"/>
    </methods>
    <properties>
      <property name="_selectedById" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.views.views"/>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.views.views.0">
    <methods>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.focus">
    <properties>
      <property name="_colHeadFocusIdx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector._config">
    <properties>
      <property name="row" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._RowMapLayer" superclass="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
      <method name="setMapping" scope="instance">
        <parameters>
          <parameter name="mapping" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearMapping" scope="instance"/>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowArrays" scope="instance">
        <parameters>
          <parameter name="rows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_subFetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
          <parameter name="rowArrays" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="map" type="Object" usage="required"/>
          <parameter name="oldOnComplete" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._StoreLayer" scope="instance"/>
    </mixins>
    <properties>
      <property name="tags" scope="instance" type="Array"/>
      <property name="_map" scope="instance-prototype" type="Object"/>
      <property name="_revMap" scope="instance-prototype" type="Object"/>
      <property name="_oldOnDelete" scope="instance" type="Object"/>
      <property name="_oldSort" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._RowMapLayer.grid">
    <properties>
      <property name="_onDelete" scope="instance" type="Object"/>
      <property name="sort" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._SelectionPreserver">
    <description>When this feature turned on, Grid will try to preserve selections across various user actions, e.g. sorting, filtering etc.
	Precondition - Identifier(id) is required for store, as id is used for differentiating row items.
	Known issue - The preserved selections might be inaccurate if some unloaded rows are selected by range previously(e.g.SHIFT + click)</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_reSelectById" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectById" scope="instance">
        <parameters>
          <parameter name="toSelect" type="Object" usage="required"/>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectedById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateMapping" scope="instance">
        <parameters>
          <parameter name="trustSelection" type="Object" usage="required"/>
          <parameter name="isSelect" type="Object" usage="required"/>
          <parameter name="isForAll" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_connects" scope="instance" type="Array"/>
      <property name="_selectedById" scope="instance" type="Object"/>
      <property name="_trustSelection" scope="instance" type="Array"/>
      <property name="_defaultSelected" scope="instance" type="bool"/>
      <property name="selection" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._SelectionPreserver._idMap">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="_wrap" scope="instance">
        <parameters>
          <parameter name="store" type="Read-store" usage="required"/>
          <parameter name="funcName" type="Object" usage="required"/>
          <parameter name="layerFuncName" type="Object" usage="required"/>
          <parameter name="nextLayer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unwrap" scope="instance">
        <parameters>
          <parameter name="nextLayer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="bool" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="name" scope="instance">
        <return-description>The name of this layer.</return-description>
      </method>
      <method name="originFetch" scope="instance"/>
    </methods>
    <properties>
      <property name="_store" scope="instance-prototype" type="Read-store"/>
      <property name="_originFetch" scope="instance-prototype" type="function"/>
      <property name="__enabled" scope="instance-prototype" type="Boolean"/>
      <property name="tags" scope="instance" type="Array"/>
      <property name="layerFuncName" scope="instance" type="String"/>
      <property name="_funcName" scope="instance" type="Object"/>
      <property name="__name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._ServerSideLayer" superclass="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="bool" usage="optional"/>
        </parameters>
      </method>
      <method name="useCommands" scope="instance">
        <parameters>
          <parameter name="toUse" type="bool" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="keywordArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.data.api.Request"/>
        </return-types>
      </method>
      <method name="command" scope="instance">
        <parameters>
          <parameter name="cmdName" type="string" usage="required"/>
          <parameter name="cmdContent" type="(string|number|bool|)" usage="optional"/>
        </parameters>
        <return-description>The content of the command if cmdContent is undefined</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="onCommandLoad" scope="instance">
        <parameters>
          <parameter name="response" type="string" usage="required"/>
          <parameter name="userRequest" type="keywordArgs" usage="required"/>
        </parameters>
      </method>
      <method name="onCommandError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="_onUserCommandLoad" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._StoreLayer" scope="instance"/>
    </mixins>
    <properties>
      <property name="_url" scope="instance-prototype" type="string"/>
      <property name="_isStateful" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._ServerSideLayer.__cmds">
    <properties>
      <property name="enable" scope="instance" type="Object"/>
      <property name="cmdlayer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter"/>
  <class type="dojox.grid.enhanced.plugins.exporter.CSVWriter" superclass="dojox.grid.enhanced.plugins.exporter._ExportWriter">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_formatCSVCell" scope="instance">
        <parameters>
          <parameter name="cellValue" type="string" usage="required"/>
        </parameters>
        <return-description>The formatted content of a cell</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="beforeContentRow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.exporter._ExportWriter" scope="instance"/>
    </mixins>
    <properties>
      <property name="_separator" scope="instance-prototype" type="String"/>
      <property name="_newline" scope="instance-prototype" type="String"/>
      <property name="_headers" scope="instance" type="Array"/>
      <property name="_dataRows" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter.TableWriter" superclass="dojox.grid.enhanced.plugins.exporter._ExportWriter">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_getTableAttrs" scope="instance">
        <parameters>
          <parameter name="tagName" type="string" usage="required"/>
        </parameters>
        <return-description>The well formatted attributes for the given html table.tag</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getRowClass" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getColumnClass" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="beforeView" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterView" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="beforeSubrow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterSubrow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="afterContent" scope="instance"/>
      <method name="toString" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.exporter._ExportWriter" scope="instance"/>
    </mixins>
    <properties>
      <property name="_viewTables" scope="instance" type="Array"/>
      <property name="_tableAttrs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter._ExportWriter">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_getExportDataForCell" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="rowItem" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beforeHeader" scope="instance">
        <parameters>
          <parameter name="grid" type="EnhancedGrid" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterHeader" scope="instance">
        <return-description>undefined</return-description>
      </method>
      <method name="beforeContent" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterContent" scope="instance">
        <return-description>undefined</return-description>
      </method>
      <method name="beforeContentRow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterContentRow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required"/>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="beforeView" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterView" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required"/>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="beforeSubrow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterSubrow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required"/>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required"/>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="toString" scope="instance">
        <return-description>The exported result string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter._ExportWriter.argObj">
    <properties>
      <property name="grid" scope="instance" type="EnhancedGrid"/>
      <property name="isHeader" scope="instance" type="bool"/>
      <property name="view" scope="instance" type="_View"/>
      <property name="viewIdx" scope="instance" type="int"/>
      <property name="subrow" scope="instance" type="_View.structure.cells[i]"/>
      <property name="subrowIdx" scope="instance" type="int"/>
      <property name="cell" scope="instance" type="dojox.grid.__CellDef"/>
      <property name="cellIdx" scope="instance" type="int"/>
      <property name="row" scope="instance" type="item"/>
      <property name="rowIdx" scope="instance" type="int"/>
      <property name="spCols" scope="instance" type="Array&lt;int&gt;"/>
      <property name="colOffset" scope="instance" type="int"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter">
    <properties>
      <property name="FilterLayer" scope="instance" type="Object"/>
      <property name="_DataExprs" scope="instance" type="Object"/>
      <property name="_FilterExpr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClearFilterConfirm" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="_onCancel" scope="instance"/>
      <method name="_onClear" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_clearBtnLabel" scope="instance" type="Object"/>
      <property name="_cancelBtnLabel" scope="instance" type="Object"/>
      <property name="_clearFilterMsg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClearFilterConfirm.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="isFilterBarShown" scope="instance"/>
      <method name="showFilterBar" scope="instance">
        <parameters>
          <parameter name="toShow" type="Object" usage="required"/>
          <parameter name="useAnim" type="Object" usage="required"/>
          <parameter name="animArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleFilterBar" scope="instance">
        <parameters>
          <parameter name="useAnim" type="Object" usage="required"/>
          <parameter name="animArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnIdx" scope="instance">
        <parameters>
          <parameter name="coordX" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="toggleClearFilterBtn" scope="instance">
        <parameters>
          <parameter name="toHide" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closeFilterBar" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEnterButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMoveButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLeaveButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onShowFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="colIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseFilterDefDialog" scope="instance"/>
      <method name="_onClickFilterBar" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateTipPosition" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusFilterBar" scope="instance">
        <parameters>
          <parameter name="highlightOnly" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlurFilterBar" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFiltered" scope="instance">
        <parameters>
          <parameter name="filteredSize" type="int" usage="required"/>
          <parameter name="originSize" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_initAriaInfo" scope="instance"/>
      <method name="_isInColumn" scope="instance">
        <parameters>
          <parameter name="mousePos_x" type="int" usage="required"/>
          <parameter name="headerNode" type="domNode" usage="required"/>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_setStatusTipTimeout" scope="instance"/>
      <method name="_clearStatusTipTimeout" scope="instance"/>
      <method name="_showStatusTooltip" scope="instance"/>
      <method name="_highlightHeader" scope="instance">
        <parameters>
          <parameter name="colIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_clearHeaderHighlight" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_timeout_statusTooltip" scope="instance" type="Number"/>
      <property name="_handle_statusTooltip" scope="instance" type="Object"/>
      <property name="_curColIdx" scope="instance" type="Number"/>
      <property name="_filterBarDefBtnLabel" scope="instance" type="Object"/>
      <property name="_filterBarClearBtnLabel" scope="instance" type="Object"/>
      <property name="_closeFilterBarBtnLabel" scope="instance" type="Object"/>
      <property name="_noFilterMsg" scope="instance" type="Object"/>
      <property name="oldGetHeaderHeight" scope="instance" type="Object"/>
      <property name="_leavingBtn" scope="instance" type="bool"/>
      <property name="_defPaneIsShown" scope="instance" type="bool"/>
      <property name="_tippos" scope="instance" type="Object"/>
      <property name="_isFocused" scope="instance" type="bool"/>
      <property name="_focusPos" scope="instance" type="Number"/>
      <property name="_previousHeaderIdx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.args">
    <properties>
      <property name="itemsName" scope="instance" type="Object"/>
      <property name="statusTipTimeout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.grid">
    <methods>
      <method name="_getHeaderHeight" scope="instance"/>
    </methods>
    <properties>
      <property name="showFilterBar" scope="instance" type="Object"/>
      <property name="toggleFilterBar" scope="instance" type="Object"/>
      <property name="isFilterBarShown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.defineFilterButton.domNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.grid.views.views.0.domNode">
    <properties>
      <property name="offsetHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.statusBarNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder">
    <methods>
      <method name="buildExpression" scope="instance">
        <parameters>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.supportedOps">
    <methods>
      <method name="range" scope="instance">
        <parameters>
          <parameter name="operands" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="equalto" scope="instance" type="Object"/>
      <property name="lessthan" scope="instance" type="Object"/>
      <property name="lessthanorequalto" scope="instance" type="Object"/>
      <property name="largerthan" scope="instance" type="Object"/>
      <property name="largerthanorequalto" scope="instance" type="Object"/>
      <property name="contains" scope="instance" type="Object"/>
      <property name="startswith" scope="instance" type="Object"/>
      <property name="endswith" scope="instance" type="Object"/>
      <property name="notequalto" scope="instance" type="Object"/>
      <property name="notcontains" scope="instance" type="Object"/>
      <property name="notstartswith" scope="instance" type="Object"/>
      <property name="notendswith" scope="instance" type="Object"/>
      <property name="isempty" scope="instance" type="Object"/>
      <property name="logicany" scope="instance" type="Object"/>
      <property name="logicall" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.supportedTypes">
    <properties>
      <property name="number" scope="instance" type="Object"/>
      <property name="string" scope="instance" type="Object"/>
      <property name="boolean" scope="instance" type="Object"/>
      <property name="date" scope="instance" type="Object"/>
      <property name="time" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.defaultArgs"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.defaultArgs.boolean">
    <methods>
      <method name="convert" scope="instance">
        <parameters>
          <parameter name="dataValue" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="falseValue" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveColumn" scope="instance">
        <parameters>
          <parameter name="sourceViewIndex" type="Object" usage="required"/>
          <parameter name="destViewIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
          <parameter name="targetIndex" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_setupData" scope="instance"/>
      <method name="setFilter" scope="instance">
        <parameters>
          <parameter name="rules" type="Object" usage="required"/>
          <parameter name="ruleRelation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFilter" scope="instance"/>
      <method name="getColumnLabelByValue" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getConditionLabelByValue" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCriteriaBoxes" scope="instance">
        <parameters>
          <parameter name="cnt" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="removeCriteriaBoxes" scope="instance">
        <parameters>
          <parameter name="cnt" type="int|CriteriaBox|int[]" usage="required"/>
          <parameter name="isIdx" type="bool" usage="optional"/>
        </parameters>
      </method>
      <method name="getCriteria" scope="instance">
        <parameters>
          <parameter name="idx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getExprForCriteria" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getExprForColumn" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnType" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="clearFilter" scope="instance">
        <parameters>
          <parameter name="noRefresh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showDialog" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="closeDialog" scope="instance"/>
      <method name="onFilter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClearFilter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRendered" scope="instance">
        <parameters>
          <parameter name="cbox" type="Current" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetFilter" scope="instance">
        <parameters>
          <parameter name="filterDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareDialog" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_defineFilter" scope="instance"/>
      <method name="_updateCBoxTitles" scope="instance"/>
      <method name="_updatePane" scope="instance"/>
      <method name="canFilter" scope="instance"/>
      <method name="_closeDlgAndUpdateGrid" scope="instance"/>
    </methods>
    <properties>
      <property name="curColIdx" scope="instance" type="Number"/>
      <property name="_relOpCls" scope="instance" type="String"/>
      <property name="_savedCriterias" scope="instance" type="Object"/>
      <property name="_defPane" scope="instance-prototype" type="Object"/>
      <property name="builder" scope="instance-prototype" type="Object"/>
      <property name="_dataTypeMap" scope="instance" type="Object"/>
      <property name="_clearWithoutRefresh" scope="instance" type="Object"/>
      <property name="__alreadyResizedForIE6" scope="instance" type="Object"/>
      <property name="_criteriasChanged" scope="instance" type="bool"/>
      <property name="defaultType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin.grid">
    <properties>
      <property name="setFilter" scope="instance" type="Object"/>
      <property name="getFilter" scope="instance" type="Object"/>
      <property name="getFilterRelation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.filterDefPane">
    <properties>
      <property name="cboxContainer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin.args">
    <properties>
      <property name="ruleCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog._cboxes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.filterDefPane.criteriaPane">
    <properties>
      <property name="scrollTop" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="_onRelSelectChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onAddCBox" scope="instance"/>
      <method name="_onCancel" scope="instance"/>
      <method name="_onClearFilter" scope="instance"/>
      <method name="_onFilter" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_addRuleBtnLabel" scope="instance" type="Object"/>
      <property name="_cancelBtnLabel" scope="instance" type="Object"/>
      <property name="_clearBtnLabel" scope="instance" type="Object"/>
      <property name="_filterBtnLabel" scope="instance" type="Object"/>
      <property name="_relAll" scope="instance" type="Object"/>
      <property name="_relAny" scope="instance" type="Object"/>
      <property name="_relMsgFront" scope="instance" type="Object"/>
      <property name="_relMsgTail" scope="instance" type="Object"/>
      <property name="cboxContainer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane.dlg">
    <properties>
      <property name="_relOpCls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_getColumnOptions" scope="instance"/>
      <method name="onMoveColumn" scope="instance"/>
      <method name="_onChangeColumn" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRemove" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="_showSelectOrLabel" scope="instance">
        <parameters>
          <parameter name="sel" type="Object" usage="required"/>
          <parameter name="alt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChangeCondition" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValueBox" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkValidCriteria" scope="instance"/>
      <method name="_createValueBox" scope="instance">
        <parameters>
          <parameter name="cls" type="widget" usage="required"/>
          <parameter name="arg" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRangeBox" scope="instance">
        <parameters>
          <parameter name="cls" type="widget" usage="required"/>
          <parameter name="arg" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="changeCurrentColumn" scope="instance">
        <parameters>
          <parameter name="selectCurCol" type="bool" usage="required"/>
        </parameters>
      </method>
      <method name="curColumn" scope="instance"/>
      <method name="curCondition" scope="instance"/>
      <method name="curValue" scope="instance"/>
      <method name="save" scope="instance"/>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getExpr" scope="instance"/>
      <method name="isEmpty" scope="instance"/>
      <method name="updateRuleTitle" scope="instance">
        <parameters>
          <parameter name="isEmpty" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRuleIndex" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setAriaInfo" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getUsableConditions" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setConditionsByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueBoxByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueBoxArgByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="formatValue" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueBoxClsInfo" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int|string" usage="required"/>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_curValueBox" scope="instance" type="Object"/>
      <property name="_colSelectLabel" scope="instance" type="Object"/>
      <property name="_condSelectLabel" scope="instance" type="Object"/>
      <property name="_valueBoxLabel" scope="instance" type="Object"/>
      <property name="_anyColumnOption" scope="instance" type="Object"/>
      <property name="_colOptions" scope="instance" type="Object"/>
      <property name="_isRange" scope="instance" type="Object"/>
      <property name="_ruleIndex" scope="instance" type="Object"/>
      <property name="_index" scope="instance" type="Object"/>
      <property name="_condSelect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox.dlg">
    <properties>
      <property name="curColIdx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox._pane._buttonWidget"/>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox._pane._buttonWidget.titleTextNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.AccordionContainer" superclass="dijit.layout.AccordionContainer">
    <methods>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="fromTitle" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_modifyChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="isFirst" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hackHeight" scope="instance">
        <parameters>
          <parameter name="toGrow" type="bool" usage="required"/>
          <parameter name="heightDif" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_setupTitleDom" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.AccordionContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="nls" scope="instance" type="Object"/>
      <property name="_focusOnRemoveBtn" scope="instance" type="bool"/>
      <property name="_titleHeight" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.AccordionContainer.domNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.UniqueComboBox" superclass="dijit.form.ComboBox">
    <methods>
      <method name="_openResultList" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="searchAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.BooleanValueBox" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_baseId" scope="instance" type="Object"/>
      <property name="_lblTrue" scope="instance" type="String"/>
      <property name="_lblFalse" scope="instance" type="String"/>
      <property name="args" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin">
    <methods>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="_ConditionExpr|null)" usage="optional"/>
        </parameters>
        <return-description>A filter definition if it's getter.</return-description>
      </method>
      <method name="name" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="onFilterDefined" scope="instance">
        <parameters>
          <parameter name="filter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFiltered" scope="instance">
        <parameters>
          <parameter name="filteredSize" type="Integer" usage="required"/>
          <parameter name="totalSize" type="Integer" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_filter" scope="instance" type="_ConditionExpr"/>
      <property name="tags" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ServerSideFilterLayer" superclass="dojox.grid.enhanced.plugins._ServerSideLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="(_ConditionExpr|null)" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="onCommandLoad" scope="instance">
        <parameters>
          <parameter name="responce" type="(in)string" usage="required"/>
          <parameter name="userRequest" type="(in|out)keywordArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._ServerSideLayer" scope="instance"/>
      <mixin type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_filter" scope="instance" type="Object"/>
      <property name="_filteredSize" scope="instance" type="Object"/>
      <property name="_onUserCommandLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClientSideFilterLayer" superclass="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultGetter" scope="instance">
        <parameters>
          <parameter name="datarow" type="Object" usage="required"/>
          <parameter name="colName" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="(_ConditionExpr|null)" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="setGetter" scope="instance">
        <parameters>
          <parameter name="getter" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="fetchAllOnFirstFilter" scope="instance">
        <parameters>
          <parameter name="toFetchAll" type="bool" usage="optional"/>
        </parameters>
        <return-description>Whether fetch all on first filter if this is a getter</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
          <parameter name="filterRequest" type="dojo.data.api.Request" usage="required"/>
        </parameters>
      </method>
      <method name="_hasReachedStoreEnd" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_applyFilter" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="rowIndex" type="Integer" usage="required"/>
        </parameters>
        <return-description>whether this row survived the filter.</return-description>
      </method>
      <method name="_doFilter" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="startIdx" type="Integer" usage="required"/>
          <parameter name="userRequest" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Integer" usage="required"/>
          <parameter name="req" type="request" usage="required"/>
        </parameters>
      </method>
      <method name="_completeQuery" scope="instance">
        <parameters>
          <parameter name="userRequest" type="request" usage="required"/>
        </parameters>
      </method>
      <method name="_addCachedItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="filterStartIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMappingChange" scope="instance">
        <parameters>
          <parameter name="mapping" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._StoreLayer" scope="instance"/>
      <mixin type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_result" scope="instance" type="Array,"/>
      <property name="_resultStartIdx" scope="instance" type="Integer,"/>
      <property name="_indexMap" scope="instance" type="Array,"/>
      <property name="_getter" scope="instance-prototype" type="function(datarow,"/>
      <property name="_nextUnfetchedIdx" scope="instance" type="Integer"/>
      <property name="_storeSize" scope="instance" type="Integer"/>
      <property name="_fetchAll" scope="instance" type="bool"/>
      <property name="_filter" scope="instance" type="Object"/>
      <property name="_lastSortInfo" scope="instance" type="Object"/>
      <property name="_store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClientSideFilterLayer._items">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="showDialog" scope="instance">
        <parameters>
          <parameter name="pos_x" type="int" usage="required"/>
          <parameter name="pos_y" type="int" usage="required"/>
          <parameter name="columnIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeDialog" scope="instance"/>
      <method name="_updateStatus" scope="instance">
        <parameters>
          <parameter name="columnIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createStatusDetail" scope="instance"/>
      <method name="_addButtonForRules" scope="instance"/>
      <method name="_getCriteriaStr" scope="instance">
        <parameters>
          <parameter name="c" type="object" usage="required"/>
          <parameter name="rowIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_modifyFilter" scope="instance"/>
    </methods>
    <properties>
      <property name="_pos" scope="instance" type="Object"/>
      <property name="_removedCriterias" scope="instance-prototype" type="Array"/>
      <property name="_rules" scope="instance-prototype" type="Array"/>
      <property name="statusPane" scope="instance-prototype" type="Object"/>
      <property name="_statusHeader" scope="instance" type="Object"/>
      <property name="_dlg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
      <property name="filterDefDialog" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusTitle">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusRel">
    <properties>
      <property name="innerHTML" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusRelPre">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusRelPost">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusDetailNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusPane" superclass="dijit._Widget">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._ConditionExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colArg)" usage="required"/>
        </parameters>
        <return-description>MUST return a _ConditionExpr object</return-description>
      </method>
      <method name="toObject" scope="instance">
        <return-description>An object for serialization.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getName" scope="instance">
        <return-description>the name of this kind of expression</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._DataExpr" superclass="dojox.grid.enhanced.plugins.filter._ConditionExpr">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
          <parameter name="isColumn" type="bool" usage="optional"/>
          <parameter name="convertArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <return-description>the value of this data expression.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="toObject" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._ConditionExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
      <property name="_convertData" scope="instance-prototype" type="Object"/>
      <property name="_convertArgs" scope="instance" type="Object"/>
      <property name="_colArg" scope="instance" type="Object"/>
      <property name="_value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._OperatorExpr" superclass="dojox.grid.enhanced.plugins.filter._ConditionExpr">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="toObject" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._ConditionExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
      <property name="_operands" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._UniOpExpr" superclass="dojox.grid.enhanced.plugins.filter._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colArg)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colArg)" usage="required"/>
        </parameters>
        <return-description>MUST return a _ConditionExpr object.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._OperatorExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._BiOpExpr" superclass="dojox.grid.enhanced.plugins.filter._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colArg)" usage="required"/>
        </parameters>
      </method>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colArg)" usage="required"/>
        </parameters>
        <return-description>MUST return a _ConditionExpr object.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._OperatorExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.BooleanExpr" superclass="dojox.grid.enhanced.plugins.filter._DataExpr">
    <methods>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._DataExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.StringExpr" superclass="dojox.grid.enhanced.plugins.filter._DataExpr">
    <methods>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._DataExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.NumberExpr" superclass="dojox.grid.enhanced.plugins.filter._DataExpr">
    <methods>
      <method name="_convertDataToExpr" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._DataExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.DateExpr" superclass="dojox.grid.enhanced.plugins.filter._DataExpr">
    <methods>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="toObject" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._DataExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
      <property name="_value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.TimeExpr" superclass="dojox.grid.enhanced.plugins.filter.DateExpr">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter.DateExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicAND" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicOR" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicXOR" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicNOT" superclass="dojox.grid.enhanced.plugins.filter._UniOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._UniOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicALL" superclass="dojox.grid.enhanced.plugins.filter._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._OperatorExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicANY" superclass="dojox.grid.enhanced.plugins.filter._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._OperatorExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.EqualTo" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LessThan" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LessThanOrEqualTo" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LargerThan" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LargerThanOrEqualTo" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.Contains" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.StartsWith" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.EndsWith" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.Matches" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.IsEmpty" superclass="dojox.grid.enhanced.plugins.filter._UniOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required"/>
          <parameter name="getter" type="function(row,colIdx)" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._UniOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.help">
    <methods>
      <method name="locate" scope="instance">
        <description>Search for locally available data; variable names and any cached
	documentation results for matches containing our search parameter
	searchFor
	The string to search for.</description>
        <parameters>
          <parameter name="searchFor" type="String" usage="required"/>
          <parameter name="searchIn" type="String|Object|String[]|Object[]" usage="required"/>
          <parameter name="maxResults" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance">
        <parameters>
          <parameter name="namespace" type="String" usage="optional"/>
          <parameter name="recursive" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="noConflict" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="namespaces" type="String[]" usage="required"/>
          <parameter name="noConflict" type="Boolen" usage="optional"/>
        </parameters>
      </method>
      <method name="_noConflict" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="instance">
        <parameters>
          <parameter name="self" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayLocated" scope="instance">
        <parameters>
          <parameter name="located" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayHelp" scope="instance">
        <parameters>
          <parameter name="loading" type="Object" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addVersion" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stripPrototype" scope="instance">
        <parameters>
          <parameter name="original" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__toString" scope="instance"/>
      <method name="_recurse" scope="instance">
        <parameters>
          <parameter name="namespace" type="String" usage="optional"/>
          <parameter name="recursive" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="__recurse" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
          <parameter name="root" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="recursive" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_plainText" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_namespaces" scope="instance" type="Array"/>
      <property name="_rpc" scope="instance" type="Object"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_toStrings" scope="instance" type="Object"/>
      <property name="_overrides" scope="instance" type="Array"/>
      <property name="_recursions" scope="instance" type="Array"/>
      <property name="_names" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="console" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.help._help">
    <methods/>
    <properties>
      <property name="__name__" scope="instance" type="Object"/>
      <property name="__searched__" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.help._parse">
    <methods/>
    <properties>
      <property name="__parameters__" scope="instance" type="Object"/>
      <property name="__source__" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.help._toString">
    <methods/>
    <properties>
      <property name="__parameters__" scope="instance" type="Array"/>
      <property name="__searching__" scope="instance" type="Object"/>
      <property name="__output__" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight">
    <description>This project parses pre &gt; code nodes, and applies syntax highlighting for
	a wide variety of languages. Simply dojo.require() in all the
	dojox.highlight.languages you wish to include in your highlighingting,
	and customize colors in the highlight.css.
	It is provided as a dojo package, contributed under CLA
	by Ivan Sagalaev and is available originally from:
	http://softwaremaniacs.org/soft/highlight/en/</description>
    <methods>
      <method name="processString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="lang" type="String" usage="optional"/>
        </parameters>
        <return-description>Object containing:
	result - string of html with spans to apply formatting
	partialResult - if the formating failed: string of html
	up to the point of the failure, otherwise: undefined
	langName - the language used to do the formatting</return-description>
      </method>
      <method name="init" scope="instance">
        <description>Syntax highlight a passed DomNode or String ID of a DomNode</description>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="stop iterations"/>
          <return-type type="continue iterations"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants">
    <properties>
      <property name="IDENT_RE" scope="instance" type="String"/>
      <property name="UNDERSCORE_IDENT_RE" scope="instance" type="String"/>
      <property name="NUMBER_RE" scope="instance" type="String"/>
      <property name="C_NUMBER_RE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.APOS_STRING_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.QUOTE_STRING_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.BACKSLASH_ESCAPE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.C_LINE_COMMENT_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.C_BLOCK_COMMENT_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.HASH_COMMENT_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.C_NUMBER_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="String"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.Code">
    <methods/>
    <properties>
      <property name="node" scope="instance" type="String|DomNode"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages">
    <properties>
      <property name="_all" scope="instance" type="Object"/>
      <property name="_dynamic" scope="instance" type="Object"/>
      <property name="_static" scope="instance" type="Object"/>
      <property name="_www" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp.defaultMode.keywords">
    <properties>
      <property name="false" scope="instance" type="Number"/>
      <property name="int" scope="instance" type="Number"/>
      <property name="float" scope="instance" type="Number"/>
      <property name="while" scope="instance" type="Number"/>
      <property name="private" scope="instance" type="Number"/>
      <property name="char" scope="instance" type="Number"/>
      <property name="catch" scope="instance" type="Number"/>
      <property name="export" scope="instance" type="Number"/>
      <property name="virtual" scope="instance" type="Number"/>
      <property name="operator" scope="instance" type="Number"/>
      <property name="sizeof" scope="instance" type="Number"/>
      <property name="dynamic_cast" scope="instance" type="Number"/>
      <property name="typedef" scope="instance" type="Number"/>
      <property name="const_cast" scope="instance" type="Number"/>
      <property name="const" scope="instance" type="Number"/>
      <property name="struct" scope="instance" type="Number"/>
      <property name="for" scope="instance" type="Number"/>
      <property name="static_cast" scope="instance" type="Number"/>
      <property name="union" scope="instance" type="Number"/>
      <property name="namespace" scope="instance" type="Number"/>
      <property name="unsigned" scope="instance" type="Number"/>
      <property name="long" scope="instance" type="Number"/>
      <property name="throw" scope="instance" type="Number"/>
      <property name="volatile" scope="instance" type="Number"/>
      <property name="static" scope="instance" type="Number"/>
      <property name="protected" scope="instance" type="Number"/>
      <property name="bool" scope="instance" type="Number"/>
      <property name="template" scope="instance" type="Number"/>
      <property name="mutable" scope="instance" type="Number"/>
      <property name="if" scope="instance" type="Number"/>
      <property name="public" scope="instance" type="Number"/>
      <property name="friend" scope="instance" type="Number"/>
      <property name="do" scope="instance" type="Number"/>
      <property name="return" scope="instance" type="Number"/>
      <property name="goto" scope="instance" type="Number"/>
      <property name="auto" scope="instance" type="Number"/>
      <property name="void" scope="instance" type="Number"/>
      <property name="enum" scope="instance" type="Number"/>
      <property name="else" scope="instance" type="Number"/>
      <property name="break" scope="instance" type="Number"/>
      <property name="new" scope="instance" type="Number"/>
      <property name="extern" scope="instance" type="Number"/>
      <property name="using" scope="instance" type="Number"/>
      <property name="true" scope="instance" type="Number"/>
      <property name="class" scope="instance" type="Number"/>
      <property name="asm" scope="instance" type="Number"/>
      <property name="case" scope="instance" type="Number"/>
      <property name="typeid" scope="instance" type="Number"/>
      <property name="short" scope="instance" type="Number"/>
      <property name="reinterpret_cast" scope="instance" type="Number"/>
      <property name="default" scope="instance" type="Number"/>
      <property name="double" scope="instance" type="Number"/>
      <property name="register" scope="instance" type="Number"/>
      <property name="explicit" scope="instance" type="Number"/>
      <property name="signed" scope="instance" type="Number"/>
      <property name="typename" scope="instance" type="Number"/>
      <property name="try" scope="instance" type="Number"/>
      <property name="this" scope="instance" type="Number"/>
      <property name="switch" scope="instance" type="Number"/>
      <property name="continue" scope="instance" type="Number"/>
      <property name="wchar_t" scope="instance" type="Number"/>
      <property name="inline" scope="instance" type="Number"/>
      <property name="delete" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Array"/>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.delphi">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.delphi.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.django">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.django.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.groovy">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
      <property name="GROOVY_KEYWORDS" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.groovy.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.html">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
      <property name="HTML_TAGS" scope="instance" type="Object"/>
      <property name="HTML_DOCTYPE" scope="instance" type="Object"/>
      <property name="HTML_ATTR" scope="instance" type="Object"/>
      <property name="HTML_VALUE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.html.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.java">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.java.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords"/>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.keyword">
    <properties>
      <property name="in" scope="instance" type="Number"/>
      <property name="if" scope="instance" type="Number"/>
      <property name="for" scope="instance" type="Number"/>
      <property name="while" scope="instance" type="Number"/>
      <property name="finally" scope="instance" type="Number"/>
      <property name="var" scope="instance" type="Number"/>
      <property name="new" scope="instance" type="Number"/>
      <property name="function" scope="instance" type="Number"/>
      <property name="do" scope="instance" type="Number"/>
      <property name="return" scope="instance" type="Number"/>
      <property name="void" scope="instance" type="Number"/>
      <property name="else" scope="instance" type="Number"/>
      <property name="break" scope="instance" type="Number"/>
      <property name="catch" scope="instance" type="Number"/>
      <property name="instanceof" scope="instance" type="Number"/>
      <property name="with" scope="instance" type="Number"/>
      <property name="throw" scope="instance" type="Number"/>
      <property name="case" scope="instance" type="Number"/>
      <property name="default" scope="instance" type="Number"/>
      <property name="try" scope="instance" type="Number"/>
      <property name="this" scope="instance" type="Number"/>
      <property name="switch" scope="instance" type="Number"/>
      <property name="continue" scope="instance" type="Number"/>
      <property name="typeof" scope="instance" type="Number"/>
      <property name="delete" scope="instance" type="Number"/>
      <property name="const" scope="instance" type="Number"/>
      <property name="label" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.literal">
    <properties>
      <property name="true" scope="instance" type="Number"/>
      <property name="false" scope="instance" type="Number"/>
      <property name="null" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments._html"/>
  <class type="dojox.highlight.languages.pygments._html.tags">
    <properties>
      <property name="code" scope="instance" type="Number"/>
      <property name="kbd" scope="instance" type="Number"/>
      <property name="font" scope="instance" type="Number"/>
      <property name="noscript" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="Number"/>
      <property name="img" scope="instance" type="Number"/>
      <property name="title" scope="instance" type="Number"/>
      <property name="menu" scope="instance" type="Number"/>
      <property name="tt" scope="instance" type="Number"/>
      <property name="tr" scope="instance" type="Number"/>
      <property name="param" scope="instance" type="Number"/>
      <property name="li" scope="instance" type="Number"/>
      <property name="tfoot" scope="instance" type="Number"/>
      <property name="th" scope="instance" type="Number"/>
      <property name="input" scope="instance" type="Number"/>
      <property name="td" scope="instance" type="Number"/>
      <property name="dl" scope="instance" type="Number"/>
      <property name="blockquote" scope="instance" type="Number"/>
      <property name="fieldset" scope="instance" type="Number"/>
      <property name="big" scope="instance" type="Number"/>
      <property name="dd" scope="instance" type="Number"/>
      <property name="abbr" scope="instance" type="Number"/>
      <property name="optgroup" scope="instance" type="Number"/>
      <property name="dt" scope="instance" type="Number"/>
      <property name="button" scope="instance" type="Number"/>
      <property name="isindex" scope="instance" type="Number"/>
      <property name="p" scope="instance" type="Number"/>
      <property name="small" scope="instance" type="Number"/>
      <property name="div" scope="instance" type="Number"/>
      <property name="dir" scope="instance" type="Number"/>
      <property name="em" scope="instance" type="Number"/>
      <property name="frame" scope="instance" type="Number"/>
      <property name="meta" scope="instance" type="Number"/>
      <property name="sub" scope="instance" type="Number"/>
      <property name="bdo" scope="instance" type="Number"/>
      <property name="label" scope="instance" type="Number"/>
      <property name="acronym" scope="instance" type="Number"/>
      <property name="sup" scope="instance" type="Number"/>
      <property name="body" scope="instance" type="Number"/>
      <property name="xml" scope="instance" type="Number"/>
      <property name="basefont" scope="instance" type="Number"/>
      <property name="base" scope="instance" type="Number"/>
      <property name="br" scope="instance" type="Number"/>
      <property name="address" scope="instance" type="Number"/>
      <property name="strong" scope="instance" type="Number"/>
      <property name="legend" scope="instance" type="Number"/>
      <property name="ol" scope="instance" type="Number"/>
      <property name="script" scope="instance" type="Number"/>
      <property name="caption" scope="instance" type="Number"/>
      <property name="s" scope="instance" type="Number"/>
      <property name="col" scope="instance" type="Number"/>
      <property name="h2" scope="instance" type="Number"/>
      <property name="h3" scope="instance" type="Number"/>
      <property name="h1" scope="instance" type="Number"/>
      <property name="h6" scope="instance" type="Number"/>
      <property name="h4" scope="instance" type="Number"/>
      <property name="h5" scope="instance" type="Number"/>
      <property name="table" scope="instance" type="Number"/>
      <property name="select" scope="instance" type="Number"/>
      <property name="noframes" scope="instance" type="Number"/>
      <property name="span" scope="instance" type="Number"/>
      <property name="area" scope="instance" type="Number"/>
      <property name="dfn" scope="instance" type="Number"/>
      <property name="strike" scope="instance" type="Number"/>
      <property name="cite" scope="instance" type="Number"/>
      <property name="thead" scope="instance" type="Number"/>
      <property name="head" scope="instance" type="Number"/>
      <property name="option" scope="instance" type="Number"/>
      <property name="form" scope="instance" type="Number"/>
      <property name="hr" scope="instance" type="Number"/>
      <property name="var" scope="instance" type="Number"/>
      <property name="link" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="colgroup" scope="instance" type="Number"/>
      <property name="ul" scope="instance" type="Number"/>
      <property name="applet" scope="instance" type="Number"/>
      <property name="del" scope="instance" type="Number"/>
      <property name="iframe" scope="instance" type="Number"/>
      <property name="pre" scope="instance" type="Number"/>
      <property name="frameset" scope="instance" type="Number"/>
      <property name="ins" scope="instance" type="Number"/>
      <property name="tbody" scope="instance" type="Number"/>
      <property name="html" scope="instance" type="Number"/>
      <property name="samp" scope="instance" type="Number"/>
      <property name="map" scope="instance" type="Number"/>
      <property name="object" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
      <property name="xmlns" scope="instance" type="Number"/>
      <property name="center" scope="instance" type="Number"/>
      <property name="textarea" scope="instance" type="Number"/>
      <property name="i" scope="instance" type="Number"/>
      <property name="q" scope="instance" type="Number"/>
      <property name="u" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments">
    <properties>
      <property name="_www" scope="instance" type="Object"/>
      <property name="css" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
      <property name="javascript" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode.keywords">
    <properties>
      <property name="name tag" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode.keywords.keyword">
    <properties>
      <property name="@media" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.keyword constant">
    <properties>
      <property name="true" scope="instance" type="Number"/>
      <property name="false" scope="instance" type="Number"/>
      <property name="null" scope="instance" type="Number"/>
      <property name="NaN" scope="instance" type="Number"/>
      <property name="Infinity" scope="instance" type="Number"/>
      <property name="undefined" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.name builtin">
    <properties>
      <property name="Array" scope="instance" type="Number"/>
      <property name="Boolean" scope="instance" type="Number"/>
      <property name="Date" scope="instance" type="Number"/>
      <property name="Error" scope="instance" type="Number"/>
      <property name="Function" scope="instance" type="Number"/>
      <property name="Math" scope="instance" type="Number"/>
      <property name="netscape" scope="instance" type="Number"/>
      <property name="Number" scope="instance" type="Number"/>
      <property name="Object" scope="instance" type="Number"/>
      <property name="Packages" scope="instance" type="Number"/>
      <property name="RegExp" scope="instance" type="Number"/>
      <property name="String" scope="instance" type="Number"/>
      <property name="sun" scope="instance" type="Number"/>
      <property name="decodeURI" scope="instance" type="Number"/>
      <property name="decodeURIComponent" scope="instance" type="Number"/>
      <property name="encodeURI" scope="instance" type="Number"/>
      <property name="encodeURIComponent" scope="instance" type="Number"/>
      <property name="eval" scope="instance" type="Number"/>
      <property name="isFinite" scope="instance" type="Number"/>
      <property name="isNaN" scope="instance" type="Number"/>
      <property name="parseFloat" scope="instance" type="Number"/>
      <property name="parseInt" scope="instance" type="Number"/>
      <property name="document" scope="instance" type="Number"/>
      <property name="window" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.name builtin pseudo">
    <properties>
      <property name="this" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments.xml">
    <properties>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xml">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="XML_COMMENT" scope="instance" type="Object"/>
      <property name="XML_ATTR" scope="instance" type="Object"/>
      <property name="XML_VALUE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xml.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.python">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.python.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.python.defaultMode.keywords">
    <properties>
      <property name="and" scope="instance" type="Number"/>
      <property name="elif" scope="instance" type="Number"/>
      <property name="is" scope="instance" type="Number"/>
      <property name="global" scope="instance" type="Number"/>
      <property name="as" scope="instance" type="Number"/>
      <property name="in" scope="instance" type="Number"/>
      <property name="if" scope="instance" type="Number"/>
      <property name="from" scope="instance" type="Number"/>
      <property name="raise" scope="instance" type="Number"/>
      <property name="for" scope="instance" type="Number"/>
      <property name="except" scope="instance" type="Number"/>
      <property name="finally" scope="instance" type="Number"/>
      <property name="print" scope="instance" type="Number"/>
      <property name="import" scope="instance" type="Number"/>
      <property name="pass" scope="instance" type="Number"/>
      <property name="None" scope="instance" type="Number"/>
      <property name="return" scope="instance" type="Number"/>
      <property name="exec" scope="instance" type="Number"/>
      <property name="else" scope="instance" type="Number"/>
      <property name="break" scope="instance" type="Number"/>
      <property name="not" scope="instance" type="Number"/>
      <property name="with" scope="instance" type="Number"/>
      <property name="class" scope="instance" type="Number"/>
      <property name="assert" scope="instance" type="Number"/>
      <property name="yield" scope="instance" type="Number"/>
      <property name="try" scope="instance" type="Number"/>
      <property name="while" scope="instance" type="Number"/>
      <property name="continue" scope="instance" type="Number"/>
      <property name="del" scope="instance" type="Number"/>
      <property name="or" scope="instance" type="Number"/>
      <property name="def" scope="instance" type="Number"/>
      <property name="lambda" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode.keywords">
    <properties>
      <property name="keyword" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode.keywords.aggregate">
    <properties>
      <property name="count" scope="instance" type="Number"/>
      <property name="sum" scope="instance" type="Number"/>
      <property name="min" scope="instance" type="Number"/>
      <property name="max" scope="instance" type="Number"/>
      <property name="avg" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xquery">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
      <property name="XQUERY_COMMENT" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xquery.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xquery.defaultMode.keywords">
    <properties>
      <property name="keyword" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="highlight"/>
  <class type="highlight.Code" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_populate" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRange" scope="instance">
        <parameters>
          <parameter name="range" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_updateView" scope="instance"/>
      <method name="_loadError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="range" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="String"/>
      <property name="listType" scope="instance" type="String"/>
      <property name="lang" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_lines" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="highlight.Code.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.highlight.widget">
    <properties>
      <property name="Code" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html">
    <methods>
      <method name="_adjustCssPaths" scope="instance">
        <description>Say we fetch a HTML page from level1/page.html
	It has some inline CSS:
	@import "css/page.css" tv, screen;
	...
	background-image: url(images/aplhaimage.png);
	as we fetched this HTML and therefore this CSS
	from level1/page.html, these paths needs to be adjusted to:
	@import 'level1/css/page.css' tv, screen;
	...
	background-image: url(level1/images/alphaimage.png);
	In IE it will also adjust relative paths in AlphaImageLoader()
	filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='images/alphaimage.png');
	will be adjusted to:
	filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='level1/images/alphaimage.png');
	Please note that any relative paths in AlphaImageLoader in external css files wont work, as
	the paths in AlphaImageLoader is MUST be declared relative to the HTML page,
	not relative to the CSS file that declares it</description>
        <parameters>
          <parameter name="cssUrl" type="Object" usage="required"/>
          <parameter name="cssText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustHtmlPaths" scope="instance">
        <parameters>
          <parameter name="htmlUrl" type="Object" usage="required"/>
          <parameter name="cont" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_snarfStyles" scope="instance">
        <parameters>
          <parameter name="cssUrl" type="String" usage="required"/>
          <parameter name="cont" type="String" usage="required"/>
          <parameter name="styles" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_snarfScripts" scope="instance">
        <parameters>
          <parameter name="cont" type="Object" usage="required"/>
          <parameter name="byRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="evalInGlobal" scope="instance">
        <parameters>
          <parameter name="code" type="Object" usage="required"/>
          <parameter name="appendNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required"/>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="insertCssRule" scope="instance">
        <parameters>
          <parameter name="selector" type="String" usage="required"/>
          <parameter name="declaration" type="String" usage="required"/>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="removeCssRule" scope="instance">
        <description>Only removes DYNAMICALLY created cssRules. If you
	created it with dojox.html.insertCssRule, it can be removed.</description>
        <parameters>
          <parameter name="selector" type="String" usage="required"/>
          <parameter name="declaration" type="String" usage="required"/>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet or false"/>
        </return-types>
      </method>
      <method name="getDynamicStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet"/>
        </return-types>
      </method>
      <method name="enableStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="disableStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="activeStyleSheet" scope="instance">
        <description>If passed a title, enables a that style sheet. All other
	toggle-able style sheets are disabled.
	If no argument is passed, returns currently enabled
	style sheet.</description>
        <parameters>
          <parameter name="title" type="?String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet or Boolean - FIXME - doesn't make a lot of sense"/>
        </return-types>
      </method>
      <method name="getPreferredStyleSheet" scope="instance"/>
      <method name="getToggledStyleSheets" scope="instance">
        <return-description>An array of all toggle-able style sheets
	TODO: 	Sets of style sheets could be grouped according to
	an ID and used in sets, much like different
	groups of radio buttons. It would not however be
	according to W3C spec</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getStyleSheets" scope="instance">
        <return-description>An hash map of all the style sheets.
	TODO: 	Does not recursively search for @imports, so it will
	only go one level deep.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="ellipsis" scope="instance" type="Object"/>
      <property name="styles" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html._ContentSetter" superclass="dojo.html._ContentSetter">
    <methods>
      <method name="_renderStyles" scope="instance">
        <parameters>
          <parameter name="styles" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="empty" scope="instance"/>
      <method name="onBegin" scope="instance"/>
      <method name="onEnd" scope="instance"/>
      <method name="tearDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.html._ContentSetter" scope="instance"/>
    </mixins>
    <properties>
      <property name="adjustPaths" scope="instance" type="Boolean"/>
      <property name="referencePath" scope="instance" type="String"/>
      <property name="renderStyles" scope="instance" type="bool"/>
      <property name="executeScripts" scope="instance" type="bool"/>
      <property name="scriptHasHooks" scope="instance" type="bool"/>
      <property name="scriptHookReplacement" scope="instance" type="Object"/>
      <property name="_styleNodes" scope="instance" type="Array"/>
      <property name="_styles" scope="instance" type="Array"/>
      <property name="_code" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html._ContentSetter.node">
    <properties>
      <property name="ownerDocument" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.entities">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
          <parameter name="m" type="array" usage="optional"/>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
          <parameter name="m" type="array" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="html" scope="instance" type="Array"/>
      <property name="latin" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo.style">
    <methods>
      <method name="_notSupported" scope="instance"/>
      <method name="_setTransformOriginFilter" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="transformOrigin" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getTransformOriginFilter" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getTransformFilter" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="setTransform" scope="instance"/>
      <method name="setTransformOrigin" scope="instance"/>
    </methods>
    <properties>
      <property name="supportsTransform" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo.style._toPx">
    <methods/>
    <properties>
      <property name="_conversion" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo.style.init">
    <methods>
      <method name="setTransform" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="transform" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTransform" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="setTransformOrigin" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="transformOrigin" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTransformOrigin" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tPropertyName" scope="instance" type="String"/>
      <property name="toPropertyName" scope="instance" type="String"/>
      <property name="supportsTransform" scope="instance" type="bool"/>
      <property name="_conversion" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo.style._setTransformFilter">
    <methods/>
    <properties>
      <property name="_toPx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo"/>
  <class type="dojox.html.format">
    <methods>
      <method name="prettyPrint" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
          <parameter name="indentBy" type="Integer" usage="optional"/>
          <parameter name="maxLineLength" type="Integer" usage="optional"/>
          <parameter name="map" type="Array" usage="optional"/>
          <parameter name="xhtml" type="boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.html.metrics">
    <methods>
      <method name="getFontMeasurements" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getCachedFontMeasurements" scope="instance">
        <parameters>
          <parameter name="recalculate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextBox" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
          <parameter name="className" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getScrollbar" scope="instance"/>
      <method name="initOnFontResize" scope="instance">
        <parameters>
          <parameter name="interval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFontResize" scope="instance"/>
      <method name="_fontresize" scope="instance"/>
    </methods>
    <properties>
      <property name="_fontResizeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image">
    <methods>
      <method name="preload" scope="instance">
        <parameters>
          <parameter name="urls" type="Array" usage="required"/>
        </parameters>
        <return-description>Array
	An Array of DomNodes that have been cached.</return-description>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Badge" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_init" scope="instance"/>
      <method name="_getCell" scope="instance">
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getImage" scope="instance"/>
      <method name="_enbiggen" scope="instance">
        <parameters>
          <parameter name="e" type="Event|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_loadUnder" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_disenbiggen" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="children" scope="instance" type="String"/>
      <property name="rows" scope="instance" type="Integer"/>
      <property name="cols" scope="instance" type="Integer"/>
      <property name="cellSize" scope="instance" type="Integer"/>
      <property name="cellMargin" scope="instance" type="Integer"/>
      <property name="delay" scope="instance" type="Integer"/>
      <property name="threads" scope="instance" type="Integer"/>
      <property name="easing" scope="instance" type="Function|String"/>
    </properties>
  </class>
  <class type="dojox.image.Badge._nl">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.FlickrBadge" superclass="dojox.image.Badge">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.image.Badge" scope="instance"/>
    </mixins>
    <properties>
      <property name="children" scope="instance" type="String"/>
      <property name="userid" scope="instance" type="String"/>
      <property name="username" scope="instance" type="String"/>
      <property name="setid" scope="instance" type="String"/>
      <property name="tags" scope="instance" type="String"/>
      <property name="searchText" scope="instance" type="String"/>
      <property name="target" scope="instance" type="String"/>
      <property name="apikey" scope="instance" type="String"/>
      <property name="_store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Gallery" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required"/>
          <parameter name="request" type="An" usage="required"/>
          <parameter name="paramNames" type="optional" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="showNextImage" scope="instance">
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSlideshow" scope="instance"/>
      <method name="toggleSlideShow" scope="instance"/>
      <method name="showImage" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="callback" type="optional" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_centerChildren" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageHeight" scope="instance" type="Number"/>
      <property name="imageWidth" scope="instance" type="Number"/>
      <property name="pageSize" scope="instance" type="Number"/>
      <property name="autoLoad" scope="instance" type="Boolean"/>
      <property name="linkAttr" scope="instance" type="String"/>
      <property name="imageThumbAttr" scope="instance" type="String"/>
      <property name="imageLargeAttr" scope="instance" type="String"/>
      <property name="titleAttr" scope="instance" type="String"/>
      <property name="slideshowInterval" scope="instance" type="Integer"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetid" scope="instance" type="Object"/>
      <property name="thumbPicker" scope="instance" type="Object"/>
      <property name="slideShow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Lightbox" superclass="dijit._Widget">
    <description>An Elegant, keyboard accessible, markup and store capable Lightbox widget to show images
	in a modal dialog-esque format. Can show individual images as Modal dialog, or can group
	images with multiple entry points, all using a single "master" Dialog for visualization
	key controls:
	ESC - close
	Down Arrow / Rt Arrow / N - Next Image
	Up Arrow / Lf Arrow / P - Previous Image</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_addSelf" scope="instance"/>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="disable" scope="instance"/>
      <method name="enable" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="group" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
      <property name="href" scope="instance" type="String"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="modal" scope="instance" type="Boolean"/>
      <property name="_allowPassthru" scope="instance" type="Boolean"/>
      <property name="_attachedDialog" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog" superclass="dijit.Dialog">
    <description>A widget that intercepts anchor links (typically around images)
	and displays a modal Dialog. this is the actual Dialog, which you can
	create and populate manually, though should use simple Lightbox's
	unless you need the direct access.
	There should only be one of these on a page, so all dojox.image.Lightbox's will us it
	(the first instance of a Lightbox to be show()'n will create me If i do not exist)</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <return-description>dijit._Widget
	Perhaps the only `dijit._Widget` that returns itself to allow
	'chaining' or var referencing with .startup()</return-description>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="groupData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ready" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_nextImage" scope="instance"/>
      <method name="_prevImage" scope="instance"/>
      <method name="_loadImage" scope="instance"/>
      <method name="_prepNodes" scope="instance"/>
      <method name="_calcTitleSize" scope="instance"/>
      <method name="resizeTo" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="forceTitle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scaleToFit" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_setImageSize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_size" scope="instance"/>
      <method name="_position" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_showImage" scope="instance"/>
      <method name="_showNav" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="addImage" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="group" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="removeImage" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="removeGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_makeAnims" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="groupData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onImageClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="inGroup" scope="instance" type="Array"/>
      <property name="imgUrl" scope="instance" type="String"/>
      <property name="errorMessage" scope="instance" type="String"/>
      <property name="adjust" scope="instance" type="Boolean"/>
      <property name="modal" scope="instance" type="Boolean"/>
      <property name="errorImg" scope="instance" type="Url"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_animConnects" scope="instance" type="Array"/>
      <property name="_vp" scope="instance" type="Object"/>
      <property name="_lastGroup" scope="instance" type="Object"/>
      <property name="_index" scope="instance" type="Object"/>
      <property name="_imageReady" scope="instance" type="bool"/>
      <property name="_lastTitleSize" scope="instance" type="Object"/>
      <property name="_lastSize" scope="instance" type="Object"/>
      <property name="_currentSize" scope="instance" type="Object"/>
      <property name="_wasStyled" scope="instance" type="Object"/>
      <property name="_showImageAnim" scope="instance" type="Object"/>
      <property name="_loadingAnim" scope="instance" type="Object"/>
      <property name="_showNavAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog._groups">
    <properties>
      <property name="XnoGroupX" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog.imgNode">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxNano">
    <description>Very lightweight lightbox which only displays a larger image.  There is
	no support for a caption or description.  The lightbox can be closed by
	clicking any where or pressing any key.  This widget is intended to be
	used on &lt;a&gt; and &lt;img&gt; tags.  Upon creation, if the domNode is &lt;img&gt; tag,
	then it is wrapped in an &lt;a&gt; tag, then a &lt;div class="enlarge"&gt; is placed
	inside the &lt;a&gt; and can be styled to display an icon that the original
	can be enlarged.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="optional"/>
          <parameter name="n" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_createDiv" scope="instance">
        <parameters>
          <parameter name="cssClass" type="String" usage="required"/>
          <parameter name="refNode" type="DomNode" usage="required"/>
          <parameter name="display" type="boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_load" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_hideLoading" scope="instance"/>
      <method name="_show" scope="instance"/>
      <method name="_sizeBg" scope="instance"/>
      <method name="_key" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_coords" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_hide" scope="instance"/>
      <method name="_reset" scope="instance"/>
      <method name="_anim" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="onEnd" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="href" scope="instance" type="string"/>
      <property name="duration" scope="instance" type="int"/>
      <property name="preloadDelay" scope="instance" type="int"/>
      <property name="_connects" scope="instance" type="Array"/>
      <property name="_loadingNode" scope="instance" type="bool"/>
      <property name="_img" scope="instance" type="Object"/>
      <property name="_bg" scope="instance" type="Object"/>
      <property name="_node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Magnifier" superclass="dojox.image.MagnifierLite">
    <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	over-ride the _createGlass method to create your custom surface,
	being sure to create an img node on that surface.</description>
    <methods>
      <method name="_createGlass" scope="instance"/>
      <method name="_placeGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.image.MagnifierLite" scope="instance"/>
    </mixins>
    <properties>
      <property name="glassNode" scope="instance" type="Object"/>
      <property name="surfaceNode" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.MagnifierLite" superclass="dijit._Widget">
    <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	The logic behind requiring the src image to be large is
	"it's going to be downloaded, anyway" so this method avoids
	having to make thumbnails and 2 http requests among other things.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_createGlass" scope="instance"/>
      <method name="_adjustScale" scope="instance"/>
      <method name="_showGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="finalize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="glassSize" scope="instance" type="Int"/>
      <property name="scale" scope="instance" type="Decimal"/>
      <property name="glassNode" scope="instance" type="Object"/>
      <property name="surfaceNode" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="_imageSize" scope="instance" type="Object"/>
      <property name="_zoomSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required"/>
          <parameter name="request" type="An" usage="required"/>
          <parameter name="paramNames" type="optional" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <description>Removes all previously loaded images, and clears all caches.</description>
      </method>
      <method name="isImageLoaded" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="moveImageLoadingPointer" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="showNextImage" scope="instance">
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required"/>
          <parameter name="forceLoop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSlideShow" scope="instance"/>
      <method name="getShowTopicName" scope="instance">
        <description>The information published is: index, title and url</description>
      </method>
      <method name="getLoadTopicName" scope="instance">
        <description>The information published is the index position of the image loaded.</description>
      </method>
      <method name="showImage" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="_fitSize" scope="instance">
        <parameters>
          <parameter name="force" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getTopPadding" scope="instance"/>
      <method name="_loadNextImage" scope="instance"/>
      <method name="_loadImage" scope="instance">
        <description>This function loads the image at position 'index' into the
	internal cache of images.  This does not cause the image to be displayed.</description>
        <parameters>
          <parameter name="index" type="The" usage="required"/>
          <parameter name="callbackFn" type="An" usage="required"/>
        </parameters>
      </method>
      <method name="_stop" scope="instance"/>
      <method name="_prev" scope="instance"/>
      <method name="_next" scope="instance"/>
      <method name="_startTimer" scope="instance"/>
      <method name="_calcNavDimensions" scope="instance"/>
      <method name="_setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fitImage" scope="instance">
        <parameters>
          <parameter name="img" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_showNav" scope="instance">
        <parameters>
          <parameter name="force" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_hideNav" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_overElement" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageHeight" scope="instance" type="Number"/>
      <property name="imageWidth" scope="instance" type="Number"/>
      <property name="title" scope="instance" type="String"/>
      <property name="titleTemplate" scope="instance" type="String"/>
      <property name="noLink" scope="instance" type="Boolean"/>
      <property name="loop" scope="instance" type="Boolean"/>
      <property name="hasNav" scope="instance" type="Boolean"/>
      <property name="images" scope="instance" type="Array"/>
      <property name="pageSize" scope="instance" type="Number"/>
      <property name="autoLoad" scope="instance" type="Boolean"/>
      <property name="autoStart" scope="instance" type="Boolean"/>
      <property name="fixedHeight" scope="instance" type="Boolean"/>
      <property name="imageStore" scope="instance" type="Object"/>
      <property name="linkAttr" scope="instance" type="String"/>
      <property name="imageLargeAttr" scope="instance" type="String"/>
      <property name="titleAttr" scope="instance" type="String"/>
      <property name="slideshowInterval" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_imageCounter" scope="instance" type="Number"/>
      <property name="_tmpImage" scope="instance" type="DomNode"/>
      <property name="_currentImage" scope="instance" type="Object"/>
      <property name="isInitialized" scope="instance" type="bool"/>
      <property name="imageIndex" scope="instance" type="Number"/>
      <property name="_timerCancelled" scope="instance" type="Object"/>
      <property name="_slideId" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_navAnim" scope="instance" type="Object"/>
      <property name="_navShowing" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.outerNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow._request">
    <methods>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.navPlay">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.navPrev">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.navNext">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="getClickTopicName" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getShowTopicName" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required"/>
          <parameter name="request" type="An" usage="required"/>
          <parameter name="paramNames" type="optional" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="isVisible" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_next" scope="instance"/>
      <method name="_prev" scope="instance"/>
      <method name="_checkLoad" scope="instance">
        <parameters>
          <parameter name="img" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showThumbs" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="markImageLoaded" scope="instance">
        <description>If 'useLoadNotifier' is set to true, then a visual cue is
	given to state whether the image is loaded or not.	Calling this function
	marks an image as loaded.</description>
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setThumbClass" scope="instance">
        <parameters>
          <parameter name="thumb" type="DomNode" usage="required"/>
          <parameter name="className" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_loadNextPage" scope="instance"/>
      <method name="_loadImage" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateNavControls" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageStore" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Number"/>
      <property name="thumbHeight" scope="instance" type="Number"/>
      <property name="thumbWidth" scope="instance" type="Number"/>
      <property name="useLoadNotifier" scope="instance" type="Boolean"/>
      <property name="useHyperlink" scope="instance" type="boolean"/>
      <property name="hyperlinkTarget" scope="instance" type="String"/>
      <property name="isClickable" scope="instance" type="Boolean"/>
      <property name="isScrollable" scope="instance" type="Boolean"/>
      <property name="isHorizontal" scope="instance" type="Boolean"/>
      <property name="autoLoad" scope="instance" type="Boolean"/>
      <property name="linkAttr" scope="instance" type="String"/>
      <property name="imageThumbAttr" scope="instance" type="String"/>
      <property name="imageLargeAttr" scope="instance" type="String"/>
      <property name="pageSize" scope="instance" type="Number"/>
      <property name="titleAttr" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_thumbs" scope="instance" type="Array"/>
      <property name="_thumbIndex" scope="instance" type="Number"/>
      <property name="_maxPhotos" scope="instance" type="Number"/>
      <property name="_loadedImages" scope="instance" type="Object"/>
      <property name="widgetid" scope="instance" type="Object"/>
      <property name="_scrollerSize" scope="instance" type="Number"/>
      <property name="_sizeProperty" scope="instance" type="Object"/>
      <property name="_totalSize" scope="instance" type="Number"/>
      <property name="isInitialized" scope="instance" type="bool"/>
      <property name="_offsetAttr" scope="instance" type="String"/>
      <property name="_sizeAttr" scope="instance" type="String"/>
      <property name="_scrollAttr" scope="instance" type="String"/>
      <property name="_loadInProgress" scope="instance" type="Object"/>
      <property name="_noImages" scope="instance" type="bool"/>
      <property name="_loadingImages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker.request">
    <properties>
      <property name="start" scope="instance" type="Number"/>
      <property name="count" scope="instance" type="Object"/>
      <property name="onComplete" scope="instance" type="Object"/>
      <property name="onError" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker.thumbScroller">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io">
    <methods>
      <method name="httpParse" scope="instance">
        <parameters>
          <parameter name="httpStream" type="String" usage="required"/>
          <parameter name="topHeaders" type="String" usage="optional"/>
          <parameter name="partial" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="the content is not finished"/>
        </return-types>
      </method>
      <method name="xhrMultiPart" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.io.__xhrMultiArgs" usage="required"/>
        </parameters>
      </method>
      <method name="xhrScriptPlugin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="callbackParamName" type="String" usage="required"/>
          <parameter name="httpAdapter" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="xhrWindowNamePlugin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="httpAdapter" type="Function" usage="optional"/>
          <parameter name="trusted" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.io.OAuth"/>
  <class type="dojox.io.OAuth.__AccessorArgs">
    <methods/>
    <properties>
      <property name="key" scope="instance" type="String"/>
      <property name="secret" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.io.OAuth.__OAuthArgs">
    <methods/>
    <properties>
      <property name="consumer" scope="instance" type="dojox.io.OAuth.__AccessorArgs"/>
      <property name="token" scope="instance" type="dojox.io.OAuth.__AccessorArgs"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip">
    <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy
	Usage of XHR IFrame Proxying does not work from local disk in Safari.</description>
    <methods>
      <method name="_realSend" scope="instance">
        <parameters>
          <parameter name="facade" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="receive" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
          <parameter name="urlEncodedData" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="frameLoaded" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="destroyState" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="createFacade" scope="instance"/>
      <method name="sendRequest" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="encodedData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestStart" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestPart" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setServerUrl" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeServerUrl" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceivedEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceived" scope="instance">
        <parameters>
          <parameter name="frag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unpackMessage" scope="instance">
        <parameters>
          <parameter name="encodedMessage" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="xipClientUrl" scope="instance" type="Object"/>
      <property name="urlLimit" scope="instance" type="Number"/>
      <property name="_callbackName" scope="instance" type="String"/>
      <property name="_state" scope="instance" type="Object"/>
      <property name="_stateIdCounter" scope="instance" type="Number"/>
      <property name="_isWebKit" scope="instance" type="bool"/>
      <property name="_xhrObjOld" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade">
    <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy</description>
    <methods>
      <method name="setRequestHeader" scope="instance">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="abort" scope="instance"/>
      <method name="getAllResponseHeaders" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getResponseHeader" scope="instance">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_requestHeaders" scope="instance" type="Object"/>
      <property name="_allResponseHeaders" scope="instance" type="Object"/>
      <property name="_responseHeaders" scope="instance" type="Object"/>
      <property name="_method" scope="instance" type="Object"/>
      <property name="_uri" scope="instance" type="Object"/>
      <property name="_bodyData" scope="instance" type="Object"/>
      <property name="responseText" scope="instance" type="Object"/>
      <property name="responseXML" scope="instance" type="Object"/>
      <property name="status" scope="instance" type="Object"/>
      <property name="statusText" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Number"/>
      <property name="_ifpServerUrl" scope="instance" type="Object"/>
      <property name="_stateId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade.open">
    <methods/>
    <properties>
      <property name="_method" scope="instance" type="Object"/>
      <property name="_uri" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade.send">
    <methods/>
    <properties>
      <property name="_bodyData" scope="instance" type="Object"/>
      <property name="_stateId" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade._setResponseHeaders">
    <methods/>
    <properties>
      <property name="_allResponseHeaders" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.proxy"/>
  <class type="dojox.io.proxy.xip.send">
    <methods/>
    <properties>
      <property name="fullXipClientUrl" scope="instance" type="Object"/>
      <property name="send" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window.location">
    <properties>
      <property name="href" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.scriptFrame">
    <methods>
      <method name="_getWaiters" scope="instance">
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixAttachUrl" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_loaded" scope="instance">
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_waiters" scope="instance" type="Object"/>
      <property name="_loadedIds" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.windowName">
    <methods>
      <method name="send" scope="instance">
        <description>In order to provide a windowname transport accessible resources/web services, a server
	should check for the presence of a parameter window.name=true and if a request includes
	such a parameter, it should respond to the request with an HTML
	document that sets it's window.name to the string that is to be
	delivered to the client. For example, if a client makes a window.name request like:
		http://othersite.com/greeting?windowname=true
	And server wants to respond to the client with "Hello", it should return an html page:
		&lt;html&gt;&lt;script type="text/javascript"&gt;
		window.name="Hello";
		&lt;/script&gt;&lt;/html&gt;
	One can provide XML or JSON data by simply quoting the data as a string, and parsing the data
	on the client.
	If you use the authorization window.name protocol, the requester should include an
	authElement element in the args, and a request will be created like:
		http://othersite.com/greeting?windowname=auth
	And the server can respond like this:
		&lt;html&gt;&lt;script type="text/javascript"&gt;
		var loc = window.name;
		authorizationButton.onclick = function(){
			window.name="Hello";
			location = loc;
		};
		&lt;/script&gt;&lt;/html&gt;
	When using windowName from a XD Dojo build, make sure to set the
	dojo.dojoBlankHtmlUrl property to a local URL.</description>
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="args" type="dojo.__IoArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_send" scope="instance">
        <parameters>
          <parameter name="dfd" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="authTarget" type="Object" usage="required"/>
          <parameter name="onAuthLoad" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_frameNum" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.io.__xhrContentArgs">
    <methods/>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="content" scope="instance" type="String"/>
      <property name="filename" scope="instance" type="String"/>
      <property name="contentType" scope="instance" type="String"/>
      <property name="charset" scope="instance" type="String"/>
      <property name="contentTransferEncoding" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.io.__xhrMultiArgs">
    <methods>
      <method name="load" scope="instance"/>
      <method name="error" scope="instance"/>
      <method name="handle" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="file" scope="instance" type="Object"/>
      <property name="timeout" scope="instance" type="Integer"/>
      <property name="form" scope="instance" type="DOMNode"/>
      <property name="preventCache" scope="instance" type="Boolean"/>
      <property name="handleAs" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.io.xhrPlugins">
    <methods>
      <method name="register" scope="instance">
        <return-types>
          <return-type type="or check to see if we have the same path"/>
        </return-types>
      </method>
      <method name="addProxy" scope="instance">
        <parameters>
          <parameter name="proxyUrl" type="This" usage="required"/>
        </parameters>
      </method>
      <method name="addCrossSiteXhr" scope="instance">
        <description>This can be used for servers that support W3C cross-site XHR. In order for
	a server to allow a client to make cross-site XHR requests,
	it should respond with the header like:
		Access-Control: allow &lt;*&gt;
	see: http://www.w3.org/TR/access-control/</description>
        <parameters>
          <parameter name="url" type="Requests" usage="required"/>
          <parameter name="httpAdapter" type="This" usage="required"/>
        </parameters>
      </method>
      <method name="fullHttpAdapter" scope="instance">
        <description>The following convention is used:
	method name -&gt; ?http-method=PUT
	Header -&gt; http-Header-Name=header-value
	X-Header -&gt; header_name=header-value</description>
        <parameters>
          <parameter name="plainXhr" type="Object" usage="required"/>
          <parameter name="noRawBody" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.query.pseudos">
    <methods>
      <method name="has" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="visible" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hidden" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selected" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checked" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disabled" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="input" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="button" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="header" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="inputPseudos" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.query"/>
  <class type="dojox.json">
    <methods>
      <method name="_slice" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_find" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_distinctFilter" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <description>JSONQuery provides a comprehensive set of data querying tools including filtering,
	recursive search, sorting, mapping, range selection, and powerful expressions with
	wildcard string comparisons and various operators. JSONQuery generally supersets
	JSONPath and provides syntax that matches and behaves like JavaScript where
	possible.
	JSONQuery evaluations begin with the provided object, which can referenced with
	$. From
	the starting object, various operators can be successively applied, each operating
	on the result of the last operation.
	Supported Operators:
	--------------------
	* .property - This will return the provided property of the object, behaving exactly
	like JavaScript.
	* [expression] - This returns the property name/index defined by the evaluation of
	the provided expression, behaving exactly like JavaScript.
	* [?expression] - This will perform a filter operation on an array, returning all the
	items in an array that match the provided expression. This operator does not
	need to be in brackets, you can simply use ?expression, but since it does not
	have any containment, no operators can be used afterwards when used
	without brackets.
	* [^?expression] - This will perform a distinct filter operation on an array. This behaves
	as [?expression] except that it will remove any duplicate values/objects from the
	result set.
	* [/expression], [\expression], [/expression, /expression] - This performs a sort
	operation on an array, with sort based on the provide expression. Multiple comma delimited sort
	expressions can be provided for multiple sort orders (first being highest priority). /
	indicates ascending order and \ indicates descending order
	* [=expression] - This performs a map operation on an array, creating a new array
	with each item being the evaluation of the expression for each item in the source array.
	* [start:end:step] - This performs an array slice/range operation, returning the elements
	from the optional start index to the optional end index, stepping by the optional step number.
	* [expr,expr] - This a union operator, returning an array of all the property/index values from
	the evaluation of the comma delimited expressions.
	* .* or [*] - This returns the values of all the properties of the current object.
	* $ - This is the root object, If a JSONQuery expression does not being with a $,
	it will be auto-inserted at the beginning.
	* @ - This is the current object in filter, sort, and map expressions. This is generally
	not necessary, names are auto-converted to property references of the current object
	in expressions.
	*	..property - Performs a recursive search for the given property name, returning
	an array of all values with such a property name in the current object and any subobjects
	* expr = expr - Performs a comparison (like JS's ==). When comparing to
	a string, the comparison string may contain wildcards * (matches any number of
	characters) and ? (matches any single character).
	* expr ~ expr - Performs a string comparison with case insensitivity.
	* ..[?expression] - This will perform a deep search filter operation on all the objects and
	subobjects of the current data. Rather than only searching an array, this will search
	property values, arrays, and their children.
	* $1,$2,$3, etc. - These are references to extra parameters passed to the query
	function or the evaluator function.
	* +, -, /, *, &amp;, |, %, (, ), &lt;, &gt;, &lt;=, &gt;=, != - These operators behave just as they do
	in JavaScript.
		dojox.json.query(queryString,object)
	and
		dojox.json.query(queryString)(object)
	always return identical results. The first one immediately evaluates, the second one returns a
	function that then evaluates the object.</description>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
          <parameter name="obj" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="we mark all the inner brackets as skippable"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.json.ref.resolveJson">
    <description>A JSON Schema object that can be used to advise the handling of the JSON (defining ids, date properties, urls, etc)</description>
    <methods/>
    <properties>
      <property name="refAttribute" scope="instance" type="Object"/>
      <property name="_addProp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.json.ref.toJson">
    <methods/>
    <properties>
      <property name="_useRefs" scope="instance" type="Object"/>
      <property name="_addProp" scope="instance" type="Object"/>
      <property name="refAttribute" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.json.schema">
    <methods>
      <method name="validate" scope="instance">
        <description>The validate method will return an object with two properties:
	valid: A boolean indicating if the instance is valid by the schema
	errors: An array of validation errors. If there are no errors, then an
	empty list will be returned. A validation error will have two properties:
	property: which indicates which property had the error
	message: which indicates what the error was</description>
        <parameters>
          <parameter name="instance" type="Any" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPropertyChange" scope="instance">
        <parameters>
          <parameter name="value" type="Any" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="mustBeValid" scope="instance">
        <parameters>
          <parameter name="result" type="the" usage="required"/>
        </parameters>
      </method>
      <method name="_validate" scope="instance">
        <parameters>
          <parameter name="instance" type="Any" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
          <parameter name="_changing" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.jsonPath">
    <methods>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="expr" type="String" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_regularExpressions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.aspect">
    <methods>
      <method name="cflow" scope="instance">
        <parameters>
          <parameter name="instance" type="Object" usage="required"/>
          <parameter name="method" type="String|RegExp|Array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="counter" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="memoizer" scope="instance">
        <parameters>
          <parameter name="keyMaker" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="memoizerGuard" scope="instance">
        <parameters>
          <parameter name="method" type="String|Array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="profiler" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="timer" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="tracer" scope="instance">
        <parameters>
          <parameter name="grouping" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="advise" scope="instance">
        <description>Attaches AOP-style advices to a method. Can attach several
	advices at once and operate on several methods of an object.
	The latter is achieved when a RegExp is specified as
	a method name, or an array of strings and regular expressions
	is used. In this case all functional methods that
	satisfy the RegExp condition are processed. This function
	returns a handle, which can be used to unadvise, or null,
	if advising has failed.
	This function is a convenience wrapper for
	dojox.lang.aspect.adviseRaw().</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="method" type="String|RegExp|Array" usage="required"/>
          <parameter name="advice" type="Object|Function|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="adviseRaw" scope="instance">
        <description>Attaches AOP-style advices to object's methods. Can attach several
	advices at once and operate on several methods of the object.
	The latter is achieved when a RegExp is specified as
	a method name. In this case all functional methods that
	satisfy the RegExp condition are processed. This function
	returns a handle, which can be used to unadvise, or null,
	if advising has failed.</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="methods" type="Array" usage="required"/>
          <parameter name="advices" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="unadvise" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getContext" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getContextStack" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="proceed" scope="instance">
        <description>Calls the original function (or the next level around advice).
	Accepts and passes on any number of arguments, and returns a value.
	This function is valid only in the content of around calls.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async">
    <methods>
      <method name="seq" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="par" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="any" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifThen" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="ifTrue" type="Object" usage="required"/>
          <parameter name="ifFalse" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loop" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async.event">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async.timeout">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="ms" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="ms" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async.topic">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.docs">
    <methods>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="async" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_loadedDocs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.functional">
    <methods>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="inlineLambda" scope="instance">
        <parameters>
          <parameter name="lambda" type="String" usage="required"/>
          <parameter name="init" type="String|Array" usage="required"/>
          <parameter name="add2dict" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="binrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required"/>
          <parameter name="then" type="Function|String|Array" usage="required"/>
          <parameter name="before" type="Function|String|Array" usage="required"/>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="curry" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="arity" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="partial" scope="instance">
        <description>This method is used to produce partially bound
	functions. If you want to change the order of arguments, use
	dojox.lang.functional.mixer() or dojox.lang.functional.flip().</description>
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="mixer" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="mix" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="flip" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="foldl" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldl1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldr" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldr1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="reduce" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="reduceRight" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="unfold" scope="instance">
        <parameters>
          <parameter name="pr" type="Function|String|Array" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="g" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="rawLambda" scope="instance">
        <description>This method is to normalize a functional representation (a
	text snippet) to an object that contains an array of
	arguments, and a body , which is used to calculate the
	returning value.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="buildLambda" scope="instance">
        <description>This method returns a textual representation of a function
	built from the snippet. It is meant to be evaled in the
	proper context, so local variables can be pulled from the
	environment.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="lambda" scope="instance">
        <description>This method is used to normalize a functional
	representation (a text snippet, an array, or a function) to
	a function object.</description>
        <parameters>
          <parameter name="s" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="clearLambdaCache" scope="instance"/>
      <method name="linrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required"/>
          <parameter name="then" type="Function|String|Array" usage="required"/>
          <parameter name="before" type="Function|String|Array" usage="required"/>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="buildListcomp" scope="instance">
        <description>This method returns a textual representation of a function
	built from the list comprehension text snippet (conformant to JS 1.7).
	It is meant to be evaled in the proper context, so local variable can be
	pulled from the environment.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="compileListcomp" scope="instance">
        <description>This method returns a function built from the list
	comprehension text snippet (conformant to JS 1.7). It is meant to be
	reused several times.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="listcomp" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="multirec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required"/>
          <parameter name="then" type="Function|String|Array" usage="required"/>
          <parameter name="before" type="Function|String|Array" usage="required"/>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="numrec" scope="instance">
        <description>This is a simplification of the linear recursion combinator:
	- the generated function takes one numeric parameter "x",
	- the "cond" is fixed and checks for 0.
	- the "before" is fixed and the generated function is called with "x - 1".
	- the "above is called with two parameters: the return from the generated
	function, and with "x".
	- as you can see the recursion is done by decreasing the parameter,
	and calling itself until it reaches 0.</description>
        <parameters>
          <parameter name="then" type="Object" usage="required"/>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="keys" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="values" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="filterIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="forIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mapIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="filterRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="forEachRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="mapRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="everyRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="someRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="scanl" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanl1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanr" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanr1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="repeat" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="until" scope="instance">
        <parameters>
          <parameter name="pr" type="Function|String|Array" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="tailrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required"/>
          <parameter name="then" type="Function|String|Array" usage="required"/>
          <parameter name="before" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="zip" scope="instance">
        <description>This is the venerable zip combiner (for example,
	see Python documentation for general details). The returned
	array is truncated to match the length of the shortest input
	array.</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="unzip" scope="instance">
        <description>This function is similar to dojox.lang.functional.zip()
	and can be used to unzip objects packed by
	dojox.lang.functional.zip(). It is here mostly to provide
	a short-cut for the different method signature.</description>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="array" scope="instance" type="Object"/>
      <property name="arg" scope="instance" type="Object"/>
      <property name="fold" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
      <property name="reversed" scope="instance" type="Object"/>
      <property name="scan" scope="instance" type="Object"/>
      <property name="sequence" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="frame.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="frame.contentWindow">
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.oo">
    <methods>
      <method name="makeDecorator" scope="instance">
        <parameters>
          <parameter name="decorator" type="Function|Object:" usage="required"/>
        </parameters>
        <return-description>Function:
	new decorator constructor</return-description>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="bag" type="Object:" usage="required"/>
          <parameter name="map" type="Object:" usage="required"/>
        </parameters>
        <return-description>new dojox.lang.oo.Filter object</return-description>
      </method>
      <method name="applyDecorator" scope="instance">
        <parameters>
          <parameter name="decorator" type="Function:" usage="required"/>
          <parameter name="name" type="String:" usage="required"/>
          <parameter name="newValue" type="Object:" usage="required"/>
          <parameter name="oldValue" type="Object:" usage="required"/>
        </parameters>
        <return-description>Object:
	returns the final value of the property</return-description>
      </method>
      <method name="__mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object:" usage="required"/>
          <parameter name="source" type="Object:" usage="required"/>
          <parameter name="decorator" type="Object" usage="required"/>
          <parameter name="filter" type="Object" usage="required"/>
          <parameter name="mixer" type="Object" usage="required"/>
        </parameters>
        <return-description>Object:
	target</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object:" usage="required"/>
          <parameter name="source" type="Object:" usage="one-or-more"/>
        </parameters>
        <return-description>Object:
	target</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="rearrange" scope="instance">
        <description>Properties of an object are to be renamed or removed specified
	by "map" argument. Only own properties of "map" are processed.</description>
        <parameters>
          <parameter name="bag" type="Object:" usage="required"/>
          <parameter name="map" type="Object:" usage="required"/>
        </parameters>
        <return-description>Object:
	the original object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.oo.Decorator">
    <description>This object holds an original function or another decorator
	object, and implements a special mixin algorithm to be used
	by dojox.lang.oo.mixin.</description>
    <methods/>
    <properties>
      <property name="value" scope="instance" type="Object:"/>
      <property name="decorator" scope="instance" type="Function|Object:"/>
    </properties>
  </class>
  <class type="dojox.lang.oo.Filter">
    <description>This object is used as a holder of an original object
	(whose properites are to be copied), and a filter
	function used while copying by dojox.lang.oo.mixin.</description>
    <methods/>
    <properties>
      <property name="bag" scope="instance" type="Object:"/>
      <property name="filter" scope="instance" type="Function|Object:"/>
    </properties>
  </class>
  <class type="dojox.lang.oo.aop">
    <properties>
      <property name="before" scope="instance" type="Object"/>
      <property name="around" scope="instance" type="Object"/>
      <property name="afterReturning" scope="instance" type="Object"/>
      <property name="afterThrowing" scope="instance" type="Object"/>
      <property name="after" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.oo.general">
    <properties>
      <property name="augment" scope="instance" type="Object"/>
      <property name="override" scope="instance" type="Object"/>
      <property name="shuffle" scope="instance" type="Object"/>
      <property name="wrap" scope="instance" type="Object"/>
      <property name="tap" scope="instance" type="Object"/>
      <property name="before" scope="instance" type="Object"/>
      <property name="after" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.oo.__MixinDefaults">
    <methods/>
    <properties>
      <property name="decorator" scope="instance" type="Function:"/>
      <property name="filter" scope="instance" type="Function:"/>
      <property name="mixer" scope="instance" type="Function:"/>
    </properties>
  </class>
  <class type="JSONSchema">
    <properties>
      <property name="__defineGetter__" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout">
    <properties>
      <property name="BorderContainer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ContentPane" superclass="dijit.layout.ContentPane">
    <description>useful if you send ContentPane a complete page, instead of a html fragment
	scans for
	* title Node, remove
	* DOCTYPE tag, remove</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onExecError" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="adjustPaths" scope="instance" type="Boolean"/>
      <property name="cleanContent" scope="instance" type="Boolean"/>
      <property name="renderStyles" scope="instance" type="Boolean"/>
      <property name="executeScripts" scope="instance" type="Boolean"/>
      <property name="scriptHasHooks" scope="instance" type="Boolean"/>
      <property name="ioMethod" scope="instance" type="dojo.xhrGet|dojo.xhrPost"/>
      <property name="ioArgs" scope="instance-prototype" type="Object"/>
      <property name="_contentSetter" scope="instance" type="Object"/>
      <property name="_contentSetterParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.DragPane" superclass="dijit._Widget">
    <description>A small widget which takes a node with overflow:auto and
	allows dragging to position the content. Useful with images,
	or for just adding "something" to a overflow-able div.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_down" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_up" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="invert" scope="instance" type="Boolean"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_x" scope="instance" type="Object"/>
      <property name="_y" scope="instance" type="Object"/>
      <property name="_mover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ExpandoPane" superclass="dijit.layout.ContentPane">
    <description>Works just like a ContentPane inside of a borderContainer. Will expand/collapse on
	command, and supports having Layout Children as direct descendants</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_startupSizes" scope="instance"/>
      <method name="_afterResize" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setupAnims" scope="instance"/>
      <method name="preview" scope="instance"/>
      <method name="toggle" scope="instance"/>
      <method name="_hideWrapper" scope="instance"/>
      <method name="_showEnd" scope="instance"/>
      <method name="_hideEnd" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="newSize" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_trap" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="easeOut" scope="instance" type="String|Function"/>
      <property name="easeIn" scope="instance" type="String|Function"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="startExpanded" scope="instance" type="Boolean"/>
      <property name="previewOpacity" scope="instance" type="Float"/>
      <property name="previewOnDblClick" scope="instance" type="Boolean"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_animConnects" scope="instance" type="Array"/>
      <property name="_isHorizontal" scope="instance" type="Object"/>
      <property name="_container" scope="instance" type="Object"/>
      <property name="_closedSize" scope="instance" type="Object"/>
      <property name="_titleHeight" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_currentSize" scope="instance" type="Object"/>
      <property name="_showSize" scope="instance" type="Object"/>
      <property name="_showing" scope="instance" type="bool"/>
      <property name="_hasSizes" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_isonlypreview" scope="instance" type="bool"/>
      <property name="_previewShowing" scope="instance" type="bool"/>
      <property name="_contentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane" superclass="dojox.layout.ContentPane">
    <description>Makes a `dojox.layout.ContentPane` float and draggable by it's title [similar to TitlePane]
	and over-rides onClick to onDblClick for wipeIn/Out of containerNode
	provides minimize(dock) / show() and hide() methods, and resize [almost]</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="minimize" scope="instance"/>
      <method name="maximize" scope="instance"/>
      <method name="_restore" scope="instance"/>
      <method name="_dock" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bringToTop" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="closable" scope="instance" type="Boolean"/>
      <property name="dockable" scope="instance" type="Boolean"/>
      <property name="resizable" scope="instance" type="Boolean"/>
      <property name="maxable" scope="instance" type="Boolean"/>
      <property name="resizeAxis" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
      <property name="dockTo" scope="instance" type="DomNode"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="iconSrc" scope="instance" type="String"/>
      <property name="contentClass" scope="instance" type="String"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_dockNode" scope="instance" type="Object"/>
      <property name="_restoreState" scope="instance" type="Object"/>
      <property name="_allFPs" scope="instance" type="Array"/>
      <property name="_startZ" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="bgIframe" scope="instance" type="Object"/>
      <property name="_naturalState" scope="instance" type="Object"/>
      <property name="_resizeHandle" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="_maximized" scope="instance" type="bool"/>
      <property name="_isDocked" scope="instance" type="Object"/>
      <property name="_currentState" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.dockNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.closeNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.maxNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.restoreNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.resizeHandle.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="position" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.canvas.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.containerNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.domNode"/>
  <class type="dojox.layout.Dock" superclass="dijit._Widget">
    <methods>
      <method name="addNode" scope="instance">
        <parameters>
          <parameter name="refNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="_positionDock" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_docked" scope="instance" type="Array"/>
      <property name="_inPositioning" scope="instance" type="bool"/>
      <property name="autoPosition" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.layout._DockNode" superclass="dijit._Widget">
    <methods>
      <method name="restore" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="paneRef" scope="instance" type="Widget"/>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer" superclass="dojox.layout.GridContainerLite">
    <description>This component inherits of all features of gridContainerLite plus :
	- Resize colums
	- Add / remove columns
	- Fix columns at left or at right.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resizeChildAfterDrop" scope="instance">
        <description>Allow to resize and put grips</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="targetArea" type="Object" usage="required"/>
          <parameter name="indexChild" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="onShow" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="_createGrip" scope="instance">
        <parameters>
          <parameter name="index" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_placeGrips" scope="instance"/>
      <method name="_onGripDbClick" scope="instance"/>
      <method name="_resizeColumnOn" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onGripMouseUp" scope="instance"/>
      <method name="_resizeColumnMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_resizeColumnOff" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setColumns" scope="instance">
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_addColumn" scope="instance">
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_deleteColumn" scope="instance">
        <parameters>
          <parameter name="indices" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColumnsWidth" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.layout.GridContainerLite" scope="instance"/>
    </mixins>
    <properties>
      <property name="hasResizableColumns" scope="instance" type="Boolean"/>
      <property name="liveResizeColumns" scope="instance" type="Boolean"/>
      <property name="minColWidth" scope="instance" type="Integer"/>
      <property name="minChildWidth" scope="instance" type="Integer"/>
      <property name="mode" scope="instance" type="String"/>
      <property name="isRightFixed" scope="instance" type="Boolean"/>
      <property name="isLeftFixed" scope="instance" type="Boolean"/>
      <property name="_activeGrip" scope="instance" type="Object"/>
      <property name="_initX" scope="instance" type="Object"/>
      <property name="_isResized" scope="instance" type="bool"/>
      <property name="_oldTabSize" scope="instance" type="Object"/>
      <property name="_currentColumn" scope="instance" type="Object"/>
      <property name="_currentColumnWidth" scope="instance" type="Object"/>
      <property name="_nextColumn" scope="instance" type="Object"/>
      <property name="_nextColumnWidth" scope="instance" type="Object"/>
      <property name="_currentMinCol" scope="instance" type="Object"/>
      <property name="_nextMinCol" scope="instance" type="Object"/>
      <property name="_connectResizeColumnMove" scope="instance" type="Object"/>
      <property name="_connectOnGripMouseUp" scope="instance" type="Object"/>
      <property name="_connectResizeColumnOff" scope="instance" type="Object"/>
      <property name="_dragManager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer.domNode.style">
    <properties>
      <property name="overflowY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._activeGrip.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._currentColumn.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._nextColumn.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer.gridContainerTable">
    <properties>
      <property name="clientWidth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._grid">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite" superclass="dijit.layout._LayoutWidget">
    <description>GridContainerLite displays the child elements by column
	(ie: the children widths are fixed by the column width of the grid but
	the children heights are free).
	Each child is movable by drag and drop inside the GridContainer.
	The position of other children is automatically calculated when a child is moved.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resizeChildAfterDrop" scope="instance">
        <description>These components are resized only if the targetArea.node is a
	child of this instance of gridContainerLite.
	To be resized, the dropped node must have also a method resize.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="targetArea" type="Object" usage="required"/>
          <parameter name="indexChild" type="Integer" usage="required"/>
        </parameters>
        <return-description>True if resized.</return-description>
      </method>
      <method name="resizeChildAfterDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="sourceArea" type="Object" usage="required"/>
          <parameter name="indexChild" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <return-description>An array containing all children (widgets).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_isShown" scope="instance">
        <return-description>true if the content is currently shown</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="layout" scope="instance"/>
      <method name="onShow" scope="instance"/>
      <method name="onHide" scope="instance"/>
      <method name="_createCells" scope="instance"/>
      <method name="_getZonesAttr" scope="instance"/>
      <method name="enableDnd" scope="instance"/>
      <method name="disableDnd" scope="instance"/>
      <method name="_organizeChildren" scope="instance"/>
      <method name="_organizeChildrenManually" scope="instance"/>
      <method name="_insertChild" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
          <parameter name="column" type="Integer" usage="required"/>
          <parameter name="p" type="Integer" usage="optional"/>
        </parameters>
        <return-description>The widget inserted</return-description>
        <return-types>
          <return-type type="Widget"/>
        </return-types>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addService" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="column" type="Integer" usage="optional"/>
          <parameter name="p" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="column" type="Integer" usage="optional"/>
          <parameter name="p" type="Integer" usage="optional"/>
        </parameters>
        <return-description>The widget inserted</return-description>
        <return-types>
          <return-type type="Widget"/>
        </return-types>
      </method>
      <method name="_setColWidthsAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColumnsWidth" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectFocus" scope="instance">
        <description>Possibility to move focus into the GridContainer (TAB, LEFT ARROW, RIGHT ARROW, UP ARROW, DOWN ARROW).
	Possibility to move GridContainer's children (Drag and Drop) with keyboard. (SHIFT +  ARROW).
	If the type of widget is not draggable, a popup is displayed.</description>
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="autoRefresh" scope="instance" type="Boolean"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="dragHandleClass" scope="instance" type="Array"/>
      <property name="nbZones" scope="instance" type="Integer"/>
      <property name="doLayout" scope="instance" type="Boolean"/>
      <property name="isAutoOrganized" scope="instance" type="Boolean"/>
      <property name="acceptTypes" scope="instance-prototype" type="Array"/>
      <property name="colWidths" scope="instance" type="String"/>
      <property name="_border" scope="instance" type="Object"/>
      <property name="_draggedNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_disabled" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite._dragManager">
    <properties>
      <property name="autoRefresh" scope="instance" type="Object"/>
      <property name="dragHandleClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite._contentBox">
    <properties>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite._grid">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite.gridNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RadioGroup" superclass="dijit.layout.StackContainer">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="required"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="hasButtons" scope="instance" type="Boolean"/>
      <property name="buttonClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_children" scope="instance" type="Object"/>
      <property name="_buttons" scope="instance" type="Object"/>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RadioGroupFade" superclass="dojox.layout.RadioGroup">
    <methods>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.layout.RadioGroup" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.RadioGroupSlide" superclass="dojox.layout.RadioGroup">
    <description>An extension on a stock RadioGroup widget, sliding the pane
	into view from being hidden. The entry direction is randomized
	on each view</description>
    <methods>
      <method name="easing" scope="instance-prototype"/>
      <method name="constructor" scope="instance"/>
      <method name="_positionChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="FIXME: is there a real &quot;size&quot; floating around always?"/>
        </return-types>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.layout.RadioGroup" scope="instance"/>
    </mixins>
    <properties>
      <property name="zTop" scope="instance" type="Integer"/>
      <property name="_anim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout._RadioButton" superclass="dijit._Widget">
    <description>A private widget used to manipulate the StackContainer (RadioGroup*). Don't create directly.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_clearSelected" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String"/>
      <property name="page" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.ResizeHandle" superclass="dijit._Widget">
    <description>The handle on the bottom-right corner of FloatingPane or other widgets that allows
	the widget to be resized.
	Typically not used directly.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_beginSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewCoords" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_checkConstraints" scope="instance">
        <parameters>
          <parameter name="newW" type="Object" usage="required"/>
          <parameter name="newH" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_changeSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_endSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="targetId" scope="instance" type="String"/>
      <property name="targetContainer" scope="instance" type="DomNode"/>
      <property name="resizeAxis" scope="instance" type="String"/>
      <property name="activeResize" scope="instance" type="Boolean"/>
      <property name="activeResizeClass" scope="instance" type="String"/>
      <property name="animateSizing" scope="instance" type="Boolean"/>
      <property name="animateMethod" scope="instance" type="String"/>
      <property name="animateDuration" scope="instance" type="Integer"/>
      <property name="minHeight" scope="instance" type="Integer"/>
      <property name="minWidth" scope="instance" type="Integer"/>
      <property name="constrainMax" scope="instance" type="Boolean"/>
      <property name="maxHeight" scope="instance" type="Integer"/>
      <property name="maxWidth" scope="instance" type="Integer"/>
      <property name="fixedAspect" scope="instance" type="Boolean"/>
      <property name="intermediateChanges" scope="instance" type="Boolean"/>
      <property name="startTopic" scope="instance" type="String"/>
      <property name="endTopic" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_resizeHelper" scope="instance" type="Object"/>
      <property name="minSize" scope="instance" type="Object"/>
      <property name="maxSize" scope="instance" type="Object"/>
      <property name="_resizeX" scope="instance" type="Object"/>
      <property name="_resizeY" scope="instance" type="Object"/>
      <property name="targetWidget" scope="instance" type="Object"/>
      <property name="targetDomNode" scope="instance" type="Object"/>
      <property name="_isSizing" scope="instance" type="bool"/>
      <property name="startPoint" scope="instance" type="Object"/>
      <property name="startSize" scope="instance" type="Object"/>
      <property name="_aspect" scope="instance" type="Object"/>
      <property name="_pconnects" scope="instance" type="Array"/>
      <property name="_activeResizeLastEvent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout._ResizeHelper" superclass="dijit._Widget">
    <methods>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.RotatorContainer" superclass="dijit.layout.StackContainer">
    <description>The RotatorContainer cycles through the children with a transition.
	published topics:
	[widgetId]-update - Notifies pager(s) that a child has changed.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused
	/*int*/ current     - current selected child
	/*int*/ total       - total number of children</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setShowTabsAttr" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePager" scope="instance"/>
      <method name="_onMouseOver" scope="instance"/>
      <method name="_onMouseOut" scope="instance"/>
      <method name="_resetTimer" scope="instance"/>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="next" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_manualChange" scope="instance"/>
      <method name="_play" scope="instance">
        <parameters>
          <parameter name="skip" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pause" scope="instance"/>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="playing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="next" type="dijit._Widget" usage="required"/>
          <parameter name="prev" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_transitionEnd" scope="instance"/>
      <method name="_fade" scope="instance">
        <parameters>
          <parameter name="next" type="dijit._Widget" usage="required"/>
          <parameter name="prev" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_styleNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMnode" usage="required"/>
          <parameter name="opacity" type="number" usage="required"/>
          <parameter name="zIndex" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="showTabs" scope="instance" type="Boolean"/>
      <property name="transitionDelay" scope="instance" type="int"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="transitionDuration" scope="instance" type="int"/>
      <property name="autoStart" scope="instance" type="Boolean"/>
      <property name="suspendOnHover" scope="instance" type="Boolean"/>
      <property name="pauseOnManualChange" scope="instance" type="Boolean"/>
      <property name="reverse" scope="instance" type="Boolean"/>
      <property name="pagerId" scope="instance" type="String"/>
      <property name="cycles" scope="instance" type="int"/>
      <property name="pagerClass" scope="instance" type="String"/>
      <property name="id" scope="instance" type="String"/>
      <property name="tabNode" scope="instance" type="Object"/>
      <property name="_stackController" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="_over" scope="instance" type="bool"/>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_playing" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager" superclass="dijit._Widget">
    <description>A pager can be defined one of two ways:
	* Externally of the RotatorContainer's template and tell the
	RotatorPager the rotatorId of the RotatorContainer
	* As a direct descendant of the RotatorContainer (i.e. inside the
	RotatorContainer's template)
	The pager can contain the following components:
	* Previous button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "previous"
	* Next button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "next"
	* Play/Pause toggle button
	- Must be a dijit.form.ToggleButton
	- dojoAttachPoint must be named "playPause"
	- Use iconClass to specify toggled state
	* Current child #
	- dojoAttachPoint must be named "current"
	* Total # of children
	- dojoAttachPoint must be named "total"
	You can choose to exclude specific controls as well as add elements
	for styling.
	Should you need a pager, but don't want to use Dijit buttons, you can
	write your own pager widget and just wire it into the topics.  The
	topic names are prefixed with the widget ID of the RotatorContainer.
	Notifications are received from and sent to the RotatorContainer as
	well as other RotatorPagers.
	published topics:
	[widgetId]-cycle - Notify that the next or previous button was pressed.
	Parameters:
	/*boolean*/ next - true if next, false if previous
	[widgetId]-state - Notify that the play/pause button was toggled.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
          <parameter name="current" type="int" usage="required"/>
          <parameter name="total" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="rotatorId" scope="instance" type="int"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager.current">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager.total">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ScrollPane" superclass="dijit.layout.ContentPane">
    <description>A sizable container that takes it's content's natural size and creates
	a scroll effect based on the relative mouse position. It is an interesting
	way to display lists of data, or blocks of content, within a confined
	space.
	Horizontal scrolling is supported. Combination scrolling is not.
	FIXME: need to adust the _line somehow, it stops scrolling</description>
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_calc" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_enter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_leave" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="_line" scope="instance" type="dojo._Line"/>
      <property name="_lo" scope="instance" type="the"/>
      <property name="_offset" scope="instance" type="Number"/>
      <property name="orientation" scope="instance" type="String"/>
      <property name="autoHide" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_dir" scope="instance" type="String"/>
      <property name="_vertical" scope="instance" type="bool"/>
      <property name="_size" scope="instance" type="Object"/>
      <property name="_helpLine" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_edge" scope="instance" type="String"/>
      <property name="_scroll" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.ScrollPane.helper.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.TableContainer" superclass="dijit.layout._LayoutWidget">
    <description>The TableContainer lays out child widgets in a Table layout.
	Each widget can specify a "label" or a "title" parameter.
	This label is displayed either above or to the left of
	a widget depending on whether the "orientation" attribute
	is "horiz" or "vert", for horizontal and vertical respectively.
	The number of columns is configured using the "cols" attribute.
	The width of labels can be configured using the "labelWidth" parameter.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setSpacingAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="cols" scope="instance" type="Number"/>
      <property name="labelWidth" scope="instance" type="Number|String"/>
      <property name="showLabels" scope="instance" type="Boolean"/>
      <property name="orientation" scope="instance" type="String"/>
      <property name="spacing" scope="instance" type="Number"/>
      <property name="customClass" scope="instance" type="String"/>
      <property name="_children" scope="instance" type="Array"/>
      <property name="_initialized" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.TableContainer.table">
    <properties>
      <property name="cellspacing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ToggleSplitter" superclass="dijit.layout._Splitter">
    <description>Extends the dijit.layout._Splitter to add a toggling behavior
	on double-click</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_onMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onPrelimMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance"/>
      <method name="_getStyleProps" scope="instance">
        <parameters>
          <parameter name="paneNode" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
          <parameter name="paneStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance"/>
      <method name="_setOpenAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="_toggleMe" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._Splitter" scope="instance"/>
    </mixins>
    <properties>
      <property name="container" scope="instance" type="Object"/>
      <property name="region" scope="instance" type="Object"/>
      <property name="open" scope="instance" type="Boolean"/>
      <property name="closedThreshold" scope="instance" type="Integer"/>
      <property name="openSize" scope="instance" type="String"/>
      <property name="_closedSize" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="_openStyleProps" scope="instance" type="Object"/>
      <property name="_startPosn" scope="instance" type="Number"/>
      <property name="_onUpHandle" scope="instance" type="Object"/>
      <property name="_onMoveHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ToggleSplitter.child">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd">
    <methods>
      <method name="_setGcDndHandle" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="withHandles" type="Object" usage="required"/>
          <parameter name="handleClasses" type="Object" usage="required"/>
          <parameter name="first" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handdleIE" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.Avatar" superclass="dojo.dnd.Avatar">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
          <parameter name="opacity" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="construct" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="opacity" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.Avatar.manager">
    <properties>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calculateCoords" scope="instance">
        <parameters>
          <parameter name="height" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setDndItemSelectable" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="isSelectable" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getDraggedWidget" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="setIndicatorPosition" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="deleteDashedZone" scope="instance"/>
      <method name="insertDashedZone" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required"/>
          <parameter name="data" type="Array" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="anchor" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_checkAutoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollUp" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollDown" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stopAutoScroll" scope="instance"/>
      <method name="_sumAncestorProperties" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="integer"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="GC_OFFSET_X" scope="instance" type="Object"/>
      <property name="GC_OFFSET_Y" scope="instance" type="Object"/>
      <property name="firstIndicator" scope="instance" type="bool"/>
      <property name="dndNodes" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="anchor" scope="instance" type="Object"/>
      <property name="containerSource" scope="instance" type="bool"/>
      <property name="targetAnchor" scope="instance" type="Object"/>
      <property name="targetBox" scope="instance" type="Object"/>
      <property name="before" scope="instance" type="Object"/>
      <property name="_over" scope="instance-prototype" type="bool"/>
      <property name="dropObject" scope="instance" type="Object"/>
      <property name="dom" scope="instance-prototype" type="Object"/>
      <property name="autoScrollActive" scope="instance" type="bool"/>
      <property name="_timer" scope="instance-prototype" type="Object"/>
      <property name="childBoxes" scope="instance" type="Object"/>
      <property name="dropIndicator" scope="instance" type="Object"/>
      <property name="withHandles" scope="instance" type="Object"/>
      <property name="handleClasses" scope="instance" type="Object"/>
      <property name="opacity" scope="instance" type="Object"/>
      <property name="allowAutoScroll" scope="instance" type="Object"/>
      <property name="singular" scope="instance" type="Object"/>
      <property name="skipForm" scope="instance" type="Object"/>
      <property name="defaultHandleClass" scope="instance" type="String"/>
      <property name="isDropped" scope="instance" type="bool"/>
      <property name="isOffset" scope="instance" type="Object"/>
      <property name="hideSource" scope="instance" type="Object"/>
      <property name="_drop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd._drop.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd.current">
    <properties>
      <property name="coords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd.offsetDrag">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.DropIndicator">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="cn" type="String" usage="required"/>
          <parameter name="tag" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="isInserted" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="tag" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="document.body">
    <methods>
      <method name="onselectstart" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.layout.ext-dijit.layout">
    <properties>
      <property name="StackContainer-touch" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ext-dijit"/>
  <class type="dojox.math.BigInteger.prototype">
    <properties>
      <property name="_chunkSize" scope="instance" type="Object"/>
      <property name="_toRadix" scope="instance" type="Object"/>
      <property name="_fromRadix" scope="instance" type="Object"/>
      <property name="_fromNumber" scope="instance" type="Object"/>
      <property name="_bitwiseTo" scope="instance" type="Object"/>
      <property name="_changeBit" scope="instance" type="Object"/>
      <property name="_addTo" scope="instance" type="Object"/>
      <property name="_dMultiply" scope="instance" type="Object"/>
      <property name="_dAddOffset" scope="instance" type="Object"/>
      <property name="_multiplyLowerTo" scope="instance" type="Object"/>
      <property name="_multiplyUpperTo" scope="instance" type="Object"/>
      <property name="_modInt" scope="instance" type="Object"/>
      <property name="_millerRabin" scope="instance" type="Object"/>
      <property name="clone" scope="instance" type="Object"/>
      <property name="intValue" scope="instance" type="Object"/>
      <property name="byteValue" scope="instance" type="Object"/>
      <property name="shortValue" scope="instance" type="Object"/>
      <property name="signum" scope="instance" type="Object"/>
      <property name="toByteArray" scope="instance" type="Object"/>
      <property name="equals" scope="instance" type="Object"/>
      <property name="min" scope="instance" type="Object"/>
      <property name="max" scope="instance" type="Object"/>
      <property name="and" scope="instance" type="Object"/>
      <property name="or" scope="instance" type="Object"/>
      <property name="xor" scope="instance" type="Object"/>
      <property name="andNot" scope="instance" type="Object"/>
      <property name="not" scope="instance" type="Object"/>
      <property name="shiftLeft" scope="instance" type="Object"/>
      <property name="shiftRight" scope="instance" type="Object"/>
      <property name="getLowestSetBit" scope="instance" type="Object"/>
      <property name="bitCount" scope="instance" type="Object"/>
      <property name="testBit" scope="instance" type="Object"/>
      <property name="setBit" scope="instance" type="Object"/>
      <property name="clearBit" scope="instance" type="Object"/>
      <property name="flipBit" scope="instance" type="Object"/>
      <property name="add" scope="instance" type="Object"/>
      <property name="subtract" scope="instance" type="Object"/>
      <property name="multiply" scope="instance" type="Object"/>
      <property name="divide" scope="instance" type="Object"/>
      <property name="remainder" scope="instance" type="Object"/>
      <property name="divideAndRemainder" scope="instance" type="Object"/>
      <property name="modPow" scope="instance" type="Object"/>
      <property name="modInverse" scope="instance" type="Object"/>
      <property name="pow" scope="instance" type="Object"/>
      <property name="gcd" scope="instance" type="Object"/>
      <property name="isProbablePrime" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="NullExp">
    <properties>
      <property name="convert" scope="instance" type="Object"/>
      <property name="revert" scope="instance" type="Object"/>
      <property name="mulTo" scope="instance" type="Object"/>
      <property name="sqrTo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Barrett">
    <properties>
      <property name="convert" scope="instance" type="Object"/>
      <property name="revert" scope="instance" type="Object"/>
      <property name="reduce" scope="instance" type="Object"/>
      <property name="mulTo" scope="instance" type="Object"/>
      <property name="sqrTo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Classic.prototype">
    <properties>
      <property name="convert" scope="instance" type="Object"/>
      <property name="revert" scope="instance" type="Object"/>
      <property name="reduce" scope="instance" type="Object"/>
      <property name="mulTo" scope="instance" type="Object"/>
      <property name="sqrTo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Montgomery.prototype">
    <properties>
      <property name="convert" scope="instance" type="Object"/>
      <property name="revert" scope="instance" type="Object"/>
      <property name="reduce" scope="instance" type="Object"/>
      <property name="mulTo" scope="instance" type="Object"/>
      <property name="sqrTo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="BigInteger.prototype">
    <properties>
      <property name="_DB" scope="instance" type="Object"/>
      <property name="_copyTo" scope="instance" type="Object"/>
      <property name="_fromInt" scope="instance" type="Object"/>
      <property name="_fromString" scope="instance" type="Object"/>
      <property name="_clamp" scope="instance" type="Object"/>
      <property name="_dlShiftTo" scope="instance" type="Object"/>
      <property name="_drShiftTo" scope="instance" type="Object"/>
      <property name="_lShiftTo" scope="instance" type="Object"/>
      <property name="_rShiftTo" scope="instance" type="Object"/>
      <property name="_subTo" scope="instance" type="Object"/>
      <property name="_multiplyTo" scope="instance" type="Object"/>
      <property name="_squareTo" scope="instance" type="Object"/>
      <property name="_divRemTo" scope="instance" type="Object"/>
      <property name="_invDigit" scope="instance" type="Object"/>
      <property name="_isEven" scope="instance" type="Object"/>
      <property name="_exp" scope="instance" type="Object"/>
      <property name="toString" scope="instance" type="Object"/>
      <property name="negate" scope="instance" type="Object"/>
      <property name="abs" scope="instance" type="Object"/>
      <property name="compareTo" scope="instance" type="Object"/>
      <property name="bitLength" scope="instance" type="Object"/>
      <property name="mod" scope="instance" type="Object"/>
      <property name="modPowInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="BigInteger">
    <methods/>
    <properties>
      <property name="_DM" scope="instance" type="Number"/>
      <property name="_DV" scope="instance" type="bool"/>
      <property name="_FV" scope="instance" type="Object"/>
      <property name="_F1" scope="instance" type="Number"/>
      <property name="_F2" scope="instance" type="Number"/>
      <property name="am" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves">
    <methods>
      <method name="Arc" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="ccw" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Circle" scope="instance">
        <parameters>
          <parameter name="center" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.curves.Line">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="dimensions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves.Bezier">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves.CatmullRom">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="c" scope="instance" type="Number"/>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves.CenteredArc">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="center" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Number"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves.Path">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="curve" type="Object" usage="required"/>
          <parameter name="weight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="curve" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAll" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.matrix">
    <methods>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="product" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="sum" scope="instance">
        <return-types>
          <return-type type="Number"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="inverse" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="determinant" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
          <parameter name="value" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="ones" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="zeros" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="identity" scope="instance">
        <parameters>
          <parameter name="size" type="Number" usage="required"/>
          <parameter name="scale" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="adjoint" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="transpose" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="points" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="copy" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="factor" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="iDF" scope="instance" type="Number"/>
      <property name="ALMOST_ZERO" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.math.matrix.upperTriangle">
    <methods/>
    <properties>
      <property name="iDF" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.math.random.Secure">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="prng" type="Function:" usage="required"/>
          <parameter name="noEvents" type="Boolean:" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="nextBytes" scope="instance">
        <parameters>
          <parameter name="byteArray" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="seedTime" scope="instance"/>
      <method name="_seed_int" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="state" scope="instance" type="Object"/>
      <property name="pool" scope="instance-prototype" type="Object"/>
      <property name="pptr" scope="instance-prototype" type="Number"/>
      <property name="prng" scope="instance" type="Function:"/>
      <property name="h" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="Arcfour">
    <methods/>
  </class>
  <class type="Arcfour.init">
    <methods/>
    <properties>
      <property name="S" scope="instance" type="Object"/>
      <property name="i" scope="instance" type="Number"/>
      <property name="j" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="Arcfour.next">
    <methods/>
    <properties>
      <property name="S" scope="instance" type="Object"/>
      <property name="i" scope="instance" type="bool"/>
      <property name="j" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.math.stats">
    <methods>
      <method name="sd" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="variance" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bestFit" scope="instance">
        <parameters>
          <parameter name="a" type="Object[]" usage="required"/>
          <parameter name="xProp" type="String" usage="optional"/>
          <parameter name="yProp" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="forecast" scope="instance">
        <parameters>
          <parameter name="a" type="Object[]" usage="required"/>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="xProp" type="String" usage="optional"/>
          <parameter name="yProp" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="mean" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="min" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="max" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="median" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="mode" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="sum" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="approxLin" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]:" usage="required"/>
          <parameter name="pos" type="Number:" usage="required"/>
        </parameters>
        <return-description>Number</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="summary" scope="instance">
        <parameters>
          <parameter name="a" type="Number[]:" usage="required"/>
          <parameter name="alreadySorted" type="Boolean:" usage="optional"/>
        </parameters>
        <return-description>Object</return-description>
        <return-types>
          <return-type type="sort it properly"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.mdnd">
    <methods>
      <method name="areaManager" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_areaManager" scope="instance" type="Object"/>
      <property name="autoScroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AreaManager">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="registerByNode" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
          <parameter name="notInitAreas" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="registerByClass" scope="instance"/>
      <method name="unregister" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
        </parameters>
        <return-description>True if the area is found and unregistered.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_addMoveableItem" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
        <return-description>The draggable item.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_deleteMoveableItem" scope="instance">
        <parameters>
          <parameter name="objItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIndexArea" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
        </parameters>
        <return-description>area index or -1</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_searchDragHandle" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
        <return-description>The drag handle node.</return-description>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="addDragItem" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="index" type="Integer" usage="required"/>
          <parameter name="notCheckParent" type="Boolean" usage="required"/>
        </parameters>
        <return-description>True if the node has been inserted else false.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="removeDragItem" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
        <return-description>the removed node</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getChildren" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
        </parameters>
        <return-description>The children of a DnD area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setMarginArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="findCurrentIndexArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
        <return-description>an index of area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_isAccepted" scope="instance">
        <parameters>
          <parameter name="type" type="Array" usage="required"/>
          <parameter name="accept" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragEnter" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragExit" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="mousePosition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeDropIndicator" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
        <return-description>the current drop index</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_placeDropIndicator" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropCancel" scope="instance"/>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_resetAfterDrop" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="autoRefresh" scope="instance" type="Boolean"/>
      <property name="areaClass" scope="instance" type="String"/>
      <property name="dragHandleClass" scope="instance" type="String"/>
      <property name="_areaList" scope="instance-prototype" type="Array"/>
      <property name="_oldIndexArea" scope="instance-prototype" type="Number"/>
      <property name="_currentIndexArea" scope="instance-prototype" type="Number"/>
      <property name="_accept" scope="instance" type="bool"/>
      <property name="_cover" scope="instance" type="Object"/>
      <property name="_cover2" scope="instance" type="Object"/>
      <property name="_dragStartHandler" scope="instance" type="Object"/>
      <property name="_sourceIndexArea" scope="instance-prototype" type="Number"/>
      <property name="_lastValidIndexArea" scope="instance" type="Object"/>
      <property name="_dragItem" scope="instance" type="Object"/>
      <property name="_currentDropIndex" scope="instance-prototype" type="Number"/>
      <property name="_sourceDropIndex" scope="instance-prototype" type="Number"/>
      <property name="_eventsIE7" scope="instance" type="Array"/>
      <property name="_oldDropIndex" scope="instance-prototype" type="Number"/>
      <property name="resizeHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AreaManager._cover.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AreaManager._cover2.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AutoScroll">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="getViewport" scope="instance"/>
      <method name="setAutoScrollNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="setAutoScrollMaxPage" scope="instance"/>
      <method name="checkAutoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollDown" scope="instance"/>
      <method name="_autoScrollUp" scope="instance"/>
      <method name="_autoScrollRight" scope="instance"/>
      <method name="_autoScrollLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="stopAutoScroll" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="interval" scope="instance" type="Integer"/>
      <property name="recursiveTimer" scope="instance" type="Integer"/>
      <property name="marginMouse" scope="instance" type="Integer"/>
      <property name="_html" scope="instance" type="Object"/>
      <property name="_v" scope="instance" type="Object"/>
      <property name="_node" scope="instance" type="Object"/>
      <property name="_yMax" scope="instance" type="Object"/>
      <property name="_xMax" scope="instance" type="Object"/>
      <property name="_y" scope="instance" type="Object"/>
      <property name="_x" scope="instance" type="Object"/>
      <property name="_autoScrollActive" scope="instance" type="bool"/>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="resizeHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AutoScroll._node.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.DropIndicator">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="area" type="Node" usage="required"/>
          <parameter name="nodeRef" type="Node" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
        <return-description>the node inserted or null if it crashes</return-description>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="remove" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="node" scope="instance-prototype" type="DOMNode"/>
    </properties>
  </class>
  <class type="dojox.mdnd.DropIndicator.node.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.LazyManager">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="draggedNode" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="draggedNode" type="DOMNode" usage="optional"/>
        </parameters>
      </method>
      <method name="cancelDrag" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="_registry" scope="instance" type="Object"/>
      <property name="_fakeSource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.LazyManager.manager">
    <properties>
      <property name="target" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.Moveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="isFormElement" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
        <return-description>if true, the target is one of those specific nodes.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="initOffsetDrag" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragEnd" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="mousePosition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="handle" scope="instance-prototype" type="DOMNode"/>
      <property name="skip" scope="instance-prototype" type="Boolean"/>
      <property name="dragDistance" scope="instance" type="Integer"/>
      <property name="_selectStart" scope="instance" type="Object"/>
      <property name="_firstX" scope="instance" type="Object"/>
      <property name="_firstY" scope="instance" type="Object"/>
      <property name="_isDragging" scope="instance" type="bool"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="date" scope="instance" type="Object"/>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="autoScroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.Moveable.node"/>
  <class type="dojox.mdnd.Moveable.offsetDrag">
    <properties>
      <property name="l" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.mdnd.Moveable.node.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.PureSource" superclass="dojo.dnd.Selector">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required"/>
        </parameters>
        <return-description>True, if we need to copy items, false to move.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-description>New dojox.mdnd.PureSource instance.</return-description>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-description>True if user clicked on "approved" items.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="horizontal" scope="instance" type="bool"/>
      <property name="copyOnly" scope="instance" type="Object"/>
      <property name="skipForm" scope="instance" type="bool"/>
      <property name="withHandles" scope="instance" type="bool"/>
      <property name="isSource" scope="instance" type="Object"/>
      <property name="targetState" scope="instance" type="String"/>
      <property name="generateText" scope="instance" type="Object"/>
      <property name="isDragging" scope="instance-prototype" type="bool"/>
      <property name="mouseDown" scope="instance-prototype" type="bool"/>
      <property name="targetAnchor" scope="instance" type="Object"/>
      <property name="mouseButton" scope="instance" type="Object"/>
      <property name="accept" scope="instance" type="Object"/>
      <property name="sourceState" scope="instance" type="String"/>
      <property name="topics" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter">
    <methods>
      <method name="dndToDojo" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_dndFromDojo" scope="instance" type="Object"/>
      <property name="_dndToDojo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="subscribeDnd" scope="instance"/>
      <method name="unsubscribeDnd" scope="instance"/>
      <method name="_getHoverArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDragEnter" scope="instance"/>
      <method name="onDragExit" scope="instance"/>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="accept" type="Object" usage="required"/>
        </parameters>
        <return-description>true if the dragged node is accepted in the target dojo.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onDndSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resetAvatar" scope="instance"/>
      <method name="onDropCancel" scope="instance"/>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_dojoManager" scope="instance-prototype" type="Object"/>
      <property name="_currentArea" scope="instance-prototype" type="Object"/>
      <property name="_oldArea" scope="instance" type="Object"/>
      <property name="_moveHandler" scope="instance-prototype" type="Object"/>
      <property name="_subscribeHandler" scope="instance" type="Array"/>
      <property name="_dragNode" scope="instance" type="Object"/>
      <property name="_copy" scope="instance" type="Object"/>
      <property name="_source" scope="instance" type="Object"/>
      <property name="_outSourceHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo.dropIndicatorSize">
    <properties>
      <property name="w" scope="instance" type="Number"/>
      <property name="h" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager">
    <properties>
      <property name="_areaList" scope="instance" type="Object"/>
      <property name="_oldIndexArea" scope="instance" type="Object"/>
      <property name="_currentIndexArea" scope="instance" type="Object"/>
      <property name="_accept" scope="instance" type="bool"/>
      <property name="_currentDropIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager._dropIndicator.node.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager._dropIndicator">
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_getIndexDojoArea" scope="instance">
        <parameters>
          <parameter name="area" type="node" usage="required"/>
        </parameters>
        <return-description>The index of area if it's registered else -1.</return-description>
      </method>
      <method name="_initCoordinates" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
        </parameters>
        <return-description>An object which contains coordinates : *{x:0,y:,x1:0,y1:0}*</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="dojoTarget" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="unregisterByNode" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="unregisterByType" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="unregister" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="refreshByType" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getHoverDojoArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="draggedNode" type="DOMNode" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragEnter" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDragExit" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_currentDojoArea" scope="instance-prototype" type="DOMNode"/>
      <property name="_dojoxManager" scope="instance-prototype" type="dojox.mdnd.AreaManager"/>
      <property name="_dragStartHandler" scope="instance-prototype" type="Object"/>
      <property name="_dropHandler" scope="instance-prototype" type="Object"/>
      <property name="_moveHandler" scope="instance" type="Object"/>
      <property name="_moveUpHandler" scope="instance" type="Object"/>
      <property name="_lazyManager" scope="instance" type="Object"/>
      <property name="_oldDojoArea" scope="instance" type="Object"/>
      <property name="cancelHandler" scope="instance" type="Object"/>
      <property name="dropHandler" scope="instance" type="Object"/>
      <property name="accept" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoList">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item"/>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dropIndicator.node.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem"/>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item.node"/>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item.node.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._draggedNode"/>
  <class type="dojox.mdnd.adapter.DndToDojo._draggedNode.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.dropMode"/>
  <class type="dojox.mdnd.dropMode.DefaultDropMode">
    <methods>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="updateAreas" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
          <parameter name="indexItem" type="Integer" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="added" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getDragPoint" scope="instance">
        <description>return for:
	- X point : the middle
	- Y point : search if the user goes up or goes down with his mouse.
	- Up : top of the draggable item
	- Down : bottom of the draggable item</description>
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="mousePosition" type="Object" usage="required"/>
        </parameters>
        <return-description>an object of coordinates
	example : {'x':10,'y':10}</return-description>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="currentIndexArea" type="integer" usage="required"/>
        </parameters>
        <return-description>the index of the DnD area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
          <parameter name="index" type="Integer" usage="required"/>
          <parameter name="x" type="Coord" usage="required"/>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
        </parameters>
        <return-description>a number
	or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="_oldXPoint" scope="instance" type="Integer"/>
      <property name="_oldYPoint" scope="instance" type="Integer"/>
      <property name="_oldBehaviour" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.dropMode.OverDropMode">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="updateAreas" scope="instance">
        <description>the area position (and size) is equal to the postion of the domNode associated.</description>
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
          <parameter name="indexItem" type="Integer" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="added" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getDragPoint" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="mousePosition" type="Object" usage="required"/>
        </parameters>
        <return-description>an object of coordinates
	examples:{'x':10,'y':10}</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="currentIndexArea" type="integer" usage="required"/>
        </parameters>
        <return-description>the index of the D&amp;D area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
          <parameter name="index" type="Integer" usage="required"/>
          <parameter name="x" type="Coord" usage="required"/>
          <parameter name="y" type="Coord" usage="required"/>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
        </parameters>
        <return-description>a number or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="integer"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="_oldXPoint" scope="instance" type="Integer"/>
      <property name="_oldYPoint" scope="instance" type="Integer"/>
      <property name="_oldBehaviour" scope="instance" type="Integer"/>
      <property name="_dragHandler" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.mdnd.dropMode.VerticalDropMode">
    <methods>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="updateAreas" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
          <parameter name="indexItem" type="Integer" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="added" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getDragPoint" scope="instance">
        <description>return for:
	- X point : the middle
	- Y point : search if the user goes up or goes down with his mouse.
	- Up : top of the draggable item
	- Down : bottom of the draggable item</description>
        <parameters>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="mousePosition" type="Object" usage="required"/>
        </parameters>
        <return-description>an object of coordinates
	example : {'x':10,'y':10}</return-description>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="currentIndexArea" type="integer" usage="required"/>
        </parameters>
        <return-description>the index of the DnD area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required"/>
          <parameter name="index" type="Integer" usage="required"/>
          <parameter name="x" type="Coord" usage="required"/>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
        </parameters>
        <return-description>a number
	or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="_oldXPoint" scope="instance" type="Integer"/>
      <property name="_oldYPoint" scope="instance" type="Integer"/>
      <property name="_oldBehaviour" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile">
    <methods>
      <method name="addClass" scope="instance">
        <description>Finds the currently applied theme name, such as 'iphone' or 'android'
	from link elements, and adds it as a class name for the body element.</description>
      </method>
      <method name="setupIcon" scope="instance">
        <parameters>
          <parameter name="iconNode" type="DomNode" usage="required"/>
          <parameter name="iconPos" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="hideAddressBar" scope="instance"/>
      <method name="openWindow" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRoundRect" scope="instance">
        <parameters>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="isList" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyPngFilter" scope="instance">
        <parameters>
          <parameter name="root" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadCss" scope="instance">
        <parameters>
          <parameter name="files" type="String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="getCssPaths" scope="instance"/>
      <method name="loadCompatCssFiles" scope="instance"/>
    </methods>
    <properties>
      <property name="theme" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="loadCompatPattern" scope="instance" type="RegExp"/>
      <property name="compat" scope="instance" type="Object"/>
      <property name="parser" scope="instance" type="Object"/>
      <property name="scrollable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.FixedSplitter" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="orientation" scope="instance" type="String"/>
      <property name="isContainer" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.FixedSplitterPane" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.FlippableView" superclass="dojox.mobile.View">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="onTouchStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_nextView" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_previousView" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="duration" type="Number" usage="required"/>
          <parameter name="easing" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onFlickAnimationEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ScrollableMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
      <mixin type="dojox.mobile._ScrollableMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="scrollDir" scope="instance" type="String"/>
      <property name="weight" scope="instance" type="Number"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.FlippableView.containerNode.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.FlippableView.domNode">
    <properties>
      <property name="offsetWidth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.FlippableView.domNode.parentNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconContainer" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setupSubNodes" scope="instance">
        <parameters>
          <parameter name="ul" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="closeAll" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultIcon" scope="instance" type="String"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="pressedIconOpacity" scope="instance" type="Number"/>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="back" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="single" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_terminator" scope="instance" type="Object"/>
      <property name="_addChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconContainer.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconContainer.domNode.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem" superclass="dojox.mobile.AbstractItem">
    <description>Dynamic creation is not supported.</description>
    <methods>
      <method name="createTemplate" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="setIcon" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="highlight" scope="instance"/>
      <method name="unhighlight" scope="instance"/>
      <method name="setOpacity" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="instantiateWidget" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isOpen" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDownIcon" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iconClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeIconClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance"/>
      <method name="_open_1" scope="instance"/>
      <method name="close" scope="instance"/>
      <method name="onOpen" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onError" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.AbstractItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="lazy" scope="instance" type="bool"/>
      <property name="requires" scope="instance" type="String"/>
      <property name="timeout" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="templateStringSub" scope="instance" type="String"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.subNode">
    <properties>
      <property name="_parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.srcNodeRef.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.iconNode">
    <properties>
      <property name="src" scope="instance" type="Object"/>
      <property name="offsetLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.contentNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.containerNode.parentNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView" superclass="dojox.mobile.View">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reparent" scope="instance"/>
      <method name="findAppBars" scope="instance"/>
      <method name="_checkFixedBar" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterTransitionIn" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ScrollableMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
      <mixin type="dojox.mobile._ScrollableMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="flippable" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="fixedHeaderHeight" scope="instance" type="Object"/>
      <property name="fixedFooterHeight" scope="instance" type="Object"/>
      <property name="isLocalFooter" scope="instance" type="Object"/>
      <property name="fixedHeader" scope="instance" type="Object"/>
      <property name="fixedFooter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView.domNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView.containerNode.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
      <property name="paddingTop" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView.domNode.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView.domNode.parentNode.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onResize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="barType" scope="instance" type="String"/>
      <property name="inHeading" scope="instance" type="Object"/>
      <property name="_fixedButtonWidth" scope="instance" type="Number"/>
      <property name="_fixedButtonMargin" scope="instance" type="Number"/>
      <property name="_largeScreenWidth" scope="instance" type="Number"/>
      <property name="_clsName" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar.domNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar.containerNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar.containerNode.style">
    <properties>
      <property name="padding" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton" superclass="dojox.mobile.AbstractItem">
    <methods>
      <method name="inheritParams" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="deselect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.AbstractItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="icon1" scope="instance" type="String"/>
      <property name="icon2" scope="instance" type="Object"/>
      <property name="iconPos1" scope="instance" type="String"/>
      <property name="iconPos2" scope="instance" type="Object"/>
      <property name="selected" scope="instance" type="Object"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="tag" scope="instance" type="String"/>
      <property name="selectOne" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="anchorNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.img1.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.img1">
    <methods>
      <method name="onload" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mobile.TabBarButton.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.img2.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.img2">
    <methods>
      <method name="onload" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mobile.TabBarButton.srcNodeRef.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.box">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.domNode.parentNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabContainer" superclass="dijit._WidgetBase">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="createTabButtons" scope="instance"/>
      <method name="selectTab" scope="instance">
        <parameters>
          <parameter name="tab" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onTabClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="fixedHeader" scope="instance" type="bool"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="tabHeaderNode" scope="instance" type="Object"/>
      <property name="_selectedPane" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabContainer.containerNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabContainer._selectedPane.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabPane" superclass="dijit._WidgetBase">
    <methods>
      <method name="inheritParams" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="getParentWidget" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String"/>
      <property name="icon" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="selected" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabPane.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile._ScrollableMixin._meta">
    <properties>
      <property name="hidden" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile._ScrollableMixin" superclass="new">
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <properties>
      <property name="fixedHeader" scope="instance" type="String"/>
      <property name="fixedFooter" scope="instance" type="String"/>
      <property name="isLocalFooter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.View" superclass="dijit._WidgetBase">
    <description>View acts as a container for any HTML and/or widgets. An entire HTML page
	can have multiple View widgets and the user can navigate through
	the views back and forth without page transitions.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onStartView" scope="instance"/>
      <method name="onBeforeTransitionIn" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterTransitionIn" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeTransitionOut" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterTransitionOut" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveState" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="performTransition" scope="instance">
        <parameters>
          <parameter name="moveTo" type="String" usage="required"/>
          <parameter name="dir" type="Number" usage="required"/>
          <parameter name="transition" type="String" usage="required"/>
          <parameter name="context" type="Object|null" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
      </method>
      <method name="_doTransition" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
          <parameter name="toNode" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAnimationStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAnimationEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invokeCallback" scope="instance"/>
      <method name="getShowingView" scope="instance">
        <description>Note that dojox.mobile.currentView is the last shown view.
	If the page consists of a splitter, there are multiple showing views.</description>
      </method>
      <method name="show" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wakeUp" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="selected" scope="instance" type="Boolean"/>
      <property name="keepScrollPos" scope="instance" type="Boolean"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_visible" scope="instance" type="bool"/>
      <property name="_context" scope="instance" type="Object"/>
      <property name="_method" scope="instance" type="Object"/>
      <property name="_moveTo" scope="instance" type="Object"/>
      <property name="_dir" scope="instance" type="Object"/>
      <property name="_transition" scope="instance" type="Object"/>
      <property name="_arguments" scope="instance" type="Array"/>
      <property name="_args" scope="instance" type="Array"/>
      <property name="_dummyNode" scope="instance" type="Object"/>
      <property name="toNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.View.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.View.domNode.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.View.domNode.parentNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goTo" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="back" scope="instance" type="String"/>
      <property name="href" scope="instance" type="String"/>
      <property name="moveTo" scope="instance" type="String"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_view" scope="instance" type="Object"/>
      <property name="_body" scope="instance" type="Object"/>
      <property name="_head" scope="instance" type="Object"/>
      <property name="_btn" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading._btn.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading.domNode.firstChild">
    <properties>
      <property name="nodeValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRect" superclass="dijit._WidgetBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="shadow" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRect.buildRendering">
    <methods/>
  </class>
  <class type="dojox.mobile.RoundRect.domNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectCategory" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectCategory.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeCategory" superclass="dojox.mobile.RoundRectCategory">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.RoundRectCategory" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.EdgeToEdgeCategory.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectList" superclass="dijit._WidgetBase">
    <methods>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="redrawBorders" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="transition" scope="instance" type="String"/>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_addChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectList.buildRendering">
    <methods/>
  </class>
  <class type="dojox.mobile.RoundRectList.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList" superclass="dojox.mobile.RoundRectList">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.mobile.RoundRectList" scope="instance"/>
    </mixins>
    <properties>
      <property name="stateful" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList.buildRendering">
    <methods/>
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.AbstractItem" superclass="dijit._WidgetBase">
    <methods>
      <method name="inheritParams" scope="instance"/>
      <method name="findCurrentView" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="transitionTo" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="scene" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_instantiate" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="parent" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="createDomButton" scope="instance">
        <parameters>
          <parameter name="refNode" type="DomNode" usage="required"/>
          <parameter name="toNode" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="deselect" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="defaultClickAction" scope="instance"/>
      <method name="getParentWidget" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="icon" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="href" scope="instance" type="String"/>
      <property name="hrefTarget" scope="instance" type="String"/>
      <property name="moveTo" scope="instance" type="String"/>
      <property name="scene" scope="instance" type="String"/>
      <property name="clickable" scope="instance" type="bool"/>
      <property name="url" scope="instance" type="String"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="transitionDir" scope="instance" type="Number"/>
      <property name="callback" scope="instance" type="Object"/>
      <property name="sync" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="String"/>
      <property name="toggle" scope="instance" type="bool"/>
      <property name="_duration" scope="instance" type="Number"/>
      <property name="_text" scope="instance" type="Object"/>
      <property name="_ws" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ListItem" superclass="dojox.mobile.AbstractItem">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="setIcon" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already selected"/>
        </return-types>
      </method>
      <method name="onAnchorLabelClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRightTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.AbstractItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="rightText" scope="instance" type="String"/>
      <property name="btnClass" scope="instance" type="String"/>
      <property name="anchorLabel" scope="instance" type="bool"/>
      <property name="noArrow" scope="instance" type="bool"/>
      <property name="selected" scope="instance" type="bool"/>
      <property name="anchorNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="btnNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="iconNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ListItem.srcNodeRef.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ListItem._rightTextNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch" superclass="dijit._WidgetBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStateChanged" scope="instance">
        <parameters>
          <parameter name="newState" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="leftLabel" scope="instance" type="String"/>
      <property name="rightLabel" scope="instance" type="String"/>
      <property name="_width" scope="instance" type="Number"/>
      <property name="inner" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
      <property name="knob" scope="instance" type="Object"/>
      <property name="_moved" scope="instance" type="Object"/>
      <property name="innerStartX" scope="instance" type="Object"/>
      <property name="touchStartX" scope="instance" type="Object"/>
      <property name="_conn1" scope="instance" type="Object"/>
      <property name="_conn2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.buildRendering">
    <methods/>
    <properties>
      <property name="inner" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
      <property name="knob" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.inner.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.left.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.right.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Button" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="btnClass" scope="instance" type="String"/>
      <property name="duration" scope="instance" type="Number"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Button.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ToolBarButton" superclass="dojox.mobile.AbstractItem">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="deselect" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.AbstractItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="selected" scope="instance" type="bool"/>
      <property name="_defaultColor" scope="instance" type="String"/>
      <property name="_selColor" scope="instance" type="String"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="iconNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ToolBarButton.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ProgressIndicator">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="start" scope="instance"/>
      <method name="stop" scope="instance"/>
      <method name="getInstance" scope="instance"/>
    </methods>
    <properties>
      <property name="interval" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
      <property name="_bars" scope="instance" type="Array"/>
      <property name="timer" scope="instance" type="Object"/>
      <property name="_instance" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ProgressIndicator.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.app">
    <methods>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getActiveSceneController" scope="instance"/>
      <method name="getStageController" scope="instance"/>
      <method name="loadResources" scope="instance">
        <parameters>
          <parameter name="resources" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadResourcesForScene" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resolveTemplate" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resolveAssistant" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectFlick" scope="instance">
        <parameters>
          <parameter name="target" type="Node" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="isIPhone" scope="instance" type="Object"/>
      <property name="isWebOS" scope="instance" type="bool"/>
      <property name="isAndroid" scope="instance" type="bool"/>
      <property name="_event" scope="instance" type="Object"/>
      <property name="compat" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.AlertDialog" superclass="dijit._WidgetBase">
    <methods>
      <method name="onChoose" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="_doTransition" scope="instance">
        <parameters>
          <parameter name="dir" type="An" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="text" scope="instance" type="String"/>
      <property name="controller" scope="instance" type="Object"/>
      <property name="buttons" scope="instance" type="Array"/>
      <property name="defaultButtonLabel" scope="instance" type="String"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="mask" scope="instance" type="Object"/>
      <property name="_handleSelect" scope="instance-prototype" type="Object"/>
      <property name="onClick" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageThumbView" superclass="dijit._WidgetBase">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="addThumb" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleImgLoad" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hideCached" scope="instance"/>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setAnimationEnabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemNodeFromEvent" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="setContainerHeight" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calcPadding" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="items" scope="instance" type="Array"/>
      <property name="urlParam" scope="instance" type="String"/>
      <property name="labelParam" scope="instance" type="Object"/>
      <property name="itemTemplate" scope="instance" type="String"/>
      <property name="minPadding" scope="instance" type="Number"/>
      <property name="maxPerRow" scope="instance" type="Object"/>
      <property name="maxRows" scope="instance" type="Number"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="thumbSize" scope="instance" type="String"/>
      <property name="animationEnabled" scope="instance" type="Object"/>
      <property name="selectedIndex" scope="instance" type="Number"/>
      <property name="cache" scope="instance" type="Array"/>
      <property name="cacheMustMatch" scope="instance" type="bool"/>
      <property name="clickEvent" scope="instance" type="String"/>
      <property name="cacheBust" scope="instance" type="bool"/>
      <property name="disableHide" scope="instance" type="bool"/>
      <property name="_onLoadImages" scope="instance" type="Object"/>
      <property name="visibleImages" scope="instance" type="Object"/>
      <property name="_cacheCounter" scope="instance" type="Number"/>
      <property name="thumbNodes" scope="instance" type="Object"/>
      <property name="_numRows" scope="instance" type="Object"/>
      <property name="padding" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageThumbView._thumbSize">
    <properties>
      <property name="h" scope="instance" type="Number"/>
      <property name="w" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageThumbView._size">
    <properties>
      <property name="w" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView" superclass="dojox.mobile.app._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="isAnimating" scope="instance"/>
      <method name="handleDragEnd" scope="instance"/>
      <method name="handleFlick" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveTo" scope="instance">
        <parameters>
          <parameter name="direction" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_switchImage" scope="instance">
        <parameters>
          <parameter name="toImg" type="Object" usage="required"/>
          <parameter name="fromImg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_animPanTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="easing" type="Object" usage="required"/>
          <parameter name="duration" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="direction" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zoomTo" scope="instance">
        <parameters>
          <parameter name="centerX" type="Object" usage="required"/>
          <parameter name="centerY" type="Object" usage="required"/>
          <parameter name="zoom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="_renderImg" scope="instance">
        <parameters>
          <parameter name="smallImg" type="Object" usage="required"/>
          <parameter name="largeImg" type="Object" usage="required"/>
          <parameter name="panDir" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomAttr" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterXAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterYAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setAnimatedZoomAttr" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setCenterUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setLeftUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRightUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="isSmall" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="zoom" scope="instance" type="Number"/>
      <property name="zoomCenterX" scope="instance" type="Number"/>
      <property name="zoomCenterY" scope="instance" type="Number"/>
      <property name="maxZoom" scope="instance" type="Number"/>
      <property name="autoZoomLevel" scope="instance" type="Number"/>
      <property name="disableAutoZoom" scope="instance" type="Boolean"/>
      <property name="disableSwipe" scope="instance" type="Boolean"/>
      <property name="autoZoomEvent" scope="instance" type="String"/>
      <property name="_leftImg" scope="instance" type="Node"/>
      <property name="_rightImg" scope="instance" type="Node"/>
      <property name="_leftSmallImg" scope="instance" type="Object"/>
      <property name="_rightSmallImg" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="downX" scope="instance" type="Object"/>
      <property name="downY" scope="instance" type="Object"/>
      <property name="panX" scope="instance-prototype" type="Number"/>
      <property name="panY" scope="instance-prototype" type="Number"/>
      <property name="_moveDir" scope="instance" type="Object"/>
      <property name="_animCallback" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
      <property name="_updateAnimatedPan" scope="instance-prototype" type="Object"/>
      <property name="_onAnimPanEnd" scope="instance-prototype" type="Object"/>
      <property name="dispWidth" scope="instance" type="Number"/>
      <property name="dispHeight" scope="instance" type="Number"/>
      <property name="_updateAnimatedZoom" scope="instance-prototype" type="Object"/>
      <property name="handleLoad" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView.buildRendering">
    <methods/>
    <properties>
      <property name="canvas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView.canvas">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView._centerImg">
    <properties>
      <property name="_type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView._centerSmallImg">
    <properties>
      <property name="_type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.List" superclass="dijit._WidgetBase">
    <methods>
      <method name="dividerFunction" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="handleDrag" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleDragCancel" scope="instance"/>
      <method name="preDelete" scope="instance">
        <parameters>
          <parameter name="currentLeftPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createDeleteButtons" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_handleButtonClick" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="data" type="The" usage="required"/>
          <parameter name="index" type="The" usage="required"/>
          <parameter name="array" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="cancelDelete" scope="instance"/>
      <method name="applyClass" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="array" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDataInfo" scope="instance">
        <parameters>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_deselectRow" scope="instance"/>
      <method name="_getRowNode" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
          <parameter name="ignoreNoClick" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyTemplate" scope="instance">
        <parameters>
          <parameter name="template" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="_renderRange" scope="instance">
        <parameters>
          <parameter name="startIdx" type="Object" usage="required"/>
          <parameter name="endIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadTemplate" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="thisAttr" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFormattersAttr" scope="instance">
        <parameters>
          <parameter name="formatters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="items" scope="instance" type="Array"/>
      <property name="itemTemplate" scope="instance" type="String"/>
      <property name="emptyTemplate" scope="instance" type="String"/>
      <property name="dividerTemplate" scope="instance" type="String"/>
      <property name="labelDelete" scope="instance" type="String"/>
      <property name="labelCancel" scope="instance" type="String"/>
      <property name="controller" scope="instance" type="Object"/>
      <property name="autoDelete" scope="instance" type="Boolean"/>
      <property name="enableDelete" scope="instance" type="Boolean"/>
      <property name="enableHold" scope="instance" type="Boolean"/>
      <property name="formatters" scope="instance" type="Object"/>
      <property name="_templateLoadCount" scope="instance" type="Number"/>
      <property name="_mouseDownPos" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_dragThreshold" scope="instance" type="Object"/>
      <property name="_deleting" scope="instance" type="bool"/>
      <property name="_deleteAnimConn" scope="instance" type="Object"/>
      <property name="_postDeleteAnim" scope="instance-prototype" type="Object"/>
      <property name="_deleteBtns" scope="instance" type="Object"/>
      <property name="buttons" scope="instance" type="Object"/>
      <property name="_replaceToken" scope="instance-prototype" type="Object"/>
      <property name="_checkLoadComplete" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.List._selectedRow.style">
    <properties>
      <property name="left" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.List.deleteRow">
    <methods/>
    <properties>
      <property name="_selectedRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.List._selectedRow">
    <properties>
      <property name="previousSibling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ListSelector" superclass="dojox.mobile.app._Widget">
    <methods>
      <method name="onChoose" scope="instance"/>
      <method name="_setDataAttr" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="data" scope="instance" type="Array"/>
      <property name="controller" scope="instance" type="Object"/>
      <property name="destroyOnHide" scope="instance" type="bool"/>
      <property name="mask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneAssistant">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setup" scope="instance"/>
      <method name="activate" scope="instance">
        <parameters>
          <parameter name="params" type="Optional" usage="required"/>
        </parameters>
      </method>
      <method name="deactivate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneController" superclass="dojox.mobile.View">
    <methods>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContents" scope="instance">
        <parameters>
          <parameter name="templateHtml" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initAssistant" scope="instance"/>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="selector" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWindowSize" scope="instance"/>
      <method name="showAlertDialog" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popupSubMenu" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
    </mixins>
    <properties>
      <property name="stageController" scope="instance" type="Object"/>
      <property name="keepScrollPos" scope="instance" type="bool"/>
      <property name="sceneName" scope="instance" type="Object"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="_deferredInit" scope="instance" type="Object"/>
      <property name="sceneAssistantName" scope="instance" type="Object"/>
      <property name="_widgets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneController.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneController.assistant">
    <properties>
      <property name="controller" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.StageController">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getActiveSceneController" scope="instance"/>
      <method name="pushScene" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setZIndex" scope="instance">
        <parameters>
          <parameter name="controller" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popScene" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popScenesTo" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyScene" scope="instance">
        <parameters>
          <parameter name="scene" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="scenes" scope="instance-prototype" type="Array"/>
      <property name="effect" scope="instance-prototype" type="String"/>
      <property name="_opInProgress" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.TextBox" superclass="dojox.mobile.app._FormValueWidget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setPlaceHolderAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance">
        <description>For `dijit.form.TextBox` this basically returns the value of the &lt;input&gt;.
	For `dijit.form.MappedTextBox` subclasses, which have both
	a "displayed value" and a separate "submit value",
	This treats the "displayed value" as the master value, computing the
	submit value from it via this.parse().</description>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget to "value" which can be of
	any type as determined by the widget.</description>
        <parameters>
          <parameter name="value" type="The" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance">
        <description>Returns the displayed value (what the user sees on the screen),
	after filtering (ie, trimming spaces etc.).
	For some subclasses of TextBox (like ComboBox), the displayed value
	is different from the serialized value that's actually
	sent to the server (see dijit.form.ValidationTextBox.serialize)</description>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <description>Sets the value of the visual element to the string "value".
	The widget value is also set to a corresponding,
	but not necessarily the same, value.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="filter" scope="instance">
        <description>For MappedTextBox subclasses, this is called twice
	- once with the display value
	- once the value as set/returned by attr('value', ...)
	and attr('value'), ex: a Number for NumberTextBox.
	In the latter case it does corrections like converting null to NaN.  In
	the former case the NumberTextBox.filter() method calls this.inherited()
	to execute standard trimming code in TextBox.filter().
	TODO: break this into two methods in 2.0</description>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="trim" scope="instance" type="Boolean"/>
      <property name="uppercase" scope="instance" type="Boolean"/>
      <property name="lowercase" scope="instance" type="Boolean"/>
      <property name="propercase" scope="instance" type="Boolean"/>
      <property name="maxLength" scope="instance" type="String"/>
      <property name="selectOnClick" scope="instance" type="Boolean"/>
      <property name="placeHolder" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="focusNode" scope="instance" type="Object"/>
      <property name="displayedValue" scope="instance" type="String"/>
      <property name="_blankValue" scope="instance" type="String"/>
      <property name="_selectOnClickHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.TextBox.textbox">
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="selectionStart" scope="instance" type="Object"/>
      <property name="selectionEnd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app._FormWidget" superclass="dijit._WidgetBase">
    <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._WidgetBase.attr`.
	They also share some common methods.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="anything" usage="required"/>
          <parameter name="val2" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="create" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectInputText" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="alt" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="disabled" scope="instance" type="Boolean"/>
      <property name="intermediateChanges" scope="instance" type="Boolean"/>
      <property name="scrollOnFocus" scope="instance" type="Boolean"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="nameAttrSetting" scope="instance" type="Object"/>
      <property name="_onChangeActive" scope="instance" type="Boolean"/>
      <property name="_lastValue" scope="instance" type="Object"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
      <property name="_onChangeHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app._FormValueWidget" superclass="dojox.mobile.app._FormWidget">
    <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
    <methods>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean," usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="undo" scope="instance"/>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="readOnly" scope="instance" type="Boolean"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.mobile.app._Widget" superclass="dijit._WidgetBase">
    <methods>
      <method name="getScroll" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.app.eventMap">
    <properties>
      <property name="onmousedown" scope="instance" type="String"/>
      <property name="mousedown" scope="instance" type="String"/>
      <property name="onmouseup" scope="instance" type="String"/>
      <property name="mouseup" scope="instance" type="String"/>
      <property name="onmousemove" scope="instance" type="String"/>
      <property name="mousemove" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="Mojo.Event">
    <properties>
      <property name="flick" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView.buildRendering.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.buildRendering.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRect.buildRendering.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectList.buildRendering.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList.buildRendering.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.rails">
    <methods>
      <method name="live" scope="instance">
        <parameters>
          <parameter name="selector" type="Object" usage="required"/>
          <parameter name="evtName" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.validate">
    <methods>
      <method name="isText" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isInRange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isNumberFormat" scope="instance">
        <description>Validates any sort of number based format. Use it for phone numbers,
	social security numbers, zip-codes, etc. The value can be validated
	against one format or one of multiple formats.
	Format Definition
		 #        Stands for a digit, 0-9.
		 ?        Stands for an optional digit, 0-9 or nothing.
	All other characters must appear literally in the expression.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidLuhn" scope="instance">
        <description>Validate a String value against the Luhn algorithm to verify
	its integrity.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="check" scope="instance">
        <description>returns an object that contains several methods summarizing the results of the validation</description>
        <parameters>
          <parameter name="form" type="HTMLFormElement" usage="required"/>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="evaluateConstraint" scope="instance">
        <description>The arrays are expected to be in the format of:
	constraints:{</description>
        <parameters>
          <parameter name="profile" type="The" usage="required"/>
          <parameter name="constraint" type="Array" usage="required"/>
          <parameter name="fieldName" type="The" usage="required"/>
          <parameter name="elem" type="The" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidCreditCard" scope="instance">
        <description>Checks if a credit card type matches the # scheme in a passed value, and if
	the Luhn checksum is accurate (unless its an Enroute card, in which case
	the checkSum is skipped), returning a Boolean to check against.</description>
        <parameters>
          <parameter name="value" type="String|Int" usage="required"/>
          <parameter name="ccType" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="isValidCreditCardNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String|Int" usage="required"/>
          <parameter name="ccType" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isValidCvv" scope="instance">
        <parameters>
          <parameter name="value" type="String|Int" usage="required"/>
          <parameter name="ccType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidIsbn" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-description>Boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isIpAddress" scope="instance">
        <description>Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	Supports 2 formats for Ipv6.
	value  A string.
	flags  An object.  All flags are boolean with default = true.
	flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	Case insensitive.  Zero padding allowed.
	flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isUrl" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isEmailAddress" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getEmailAddressList" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="creditCard" scope="instance" type="Object"/>
      <property name="_isInRangeCache" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="isbn" scope="instance" type="Object"/>
      <property name="isEmailAddressList" scope="instance" type="Object"/>
      <property name="web" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.robot">
    <properties>
      <property name="recorder" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.Client">
    <properties>
      <property name="clientId" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.rpc.JsonRest">
    <methods>
      <method name="commit" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDirtyObjects" scope="instance"/>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteObject" scope="instance">
        <parameters>
          <parameter name="object" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="instance">
        <parameters>
          <parameter name="service" type="Function|String" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="absoluteId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdAttribute" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getServiceAndId" scope="instance">
        <parameters>
          <parameter name="absoluteId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="registerService" scope="instance">
        <parameters>
          <parameter name="service" type="Function" usage="required"/>
          <parameter name="servicePath" type="String" usage="required"/>
          <parameter name="schema" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loader" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="serviceClass" scope="instance" type="Object"/>
      <property name="conflictDateHeader" scope="instance" type="String"/>
      <property name="services" scope="instance" type="Object"/>
      <property name="schemas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.JsonRest.sendToServer">
    <methods/>
    <properties>
      <property name="conflictDateHeader" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.manager">
    <description>Initializes the storage systems and figures out the best available
	storage options on this platform.</description>
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="string" usage="required"/>
          <parameter name="instance" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setProvider" scope="instance">
        <description>Example-
	dojox.storage.setProvider(
	dojox.storage.IEStorageProvider)</description>
        <parameters>
          <parameter name="storageClass" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="autodetect" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="addOnLoad" scope="instance">
        <description>Adds a listener to know when Dojo Offline can be used. This
	ensures that the Dojo Offline framework is loaded and that the
	local dojox.storage system is ready to be used. This method is
	useful if you don't want to have a dependency on Dojo Events
	when using dojox.storage.</description>
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="removeOnLoad" scope="instance">
        <parameters>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isInitialized" scope="instance"/>
      <method name="supportsProvider" scope="instance">
        <description>Example-
	dojox.storage.manager.supportsProvider(
	"dojox.storage.InternetExplorerStorageProvider");</description>
        <parameters>
          <parameter name="storageClass" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getProvider" scope="instance"/>
      <method name="loaded" scope="instance">
        <description>Example 1-
	if(dojox.storage.manager.isInitialized() == false){
	dojo.connect(dojox.storage.manager, "loaded", TestStorage, "initialize");
	}else{
	dojo.connect(dojo, "loaded", TestStorage, "initialize");
	}
	Example 2-
	dojox.storage.manager.addOnLoad(someFunction);</description>
      </method>
      <method name="_fireLoaded" scope="instance"/>
      <method name="getResourceList" scope="instance">
        <description>This will return all files needed by all storage providers for
	this particular environment type. For example, if we are in the
	browser environment, then this will return the hidden SWF files
	needed by the FlashStorageProvider, even if we don't need them
	for the particular browser we are working within. This is meant
	to faciliate Dojo Offline, which must retrieve all resources we
	need offline into the offline cache -- we retrieve everything
	needed, in case another browser that requires different storage
	mechanisms hits the local offline cache. For example, if we
	were to sync against Dojo Offline on Firefox 2, then we would
	not grab the FlashStorageProvider resources needed for Safari.</description>
      </method>
    </methods>
    <properties>
      <property name="available" scope="instance" type="Object"/>
      <property name="currentProvider" scope="instance" type="Object"/>
      <property name="providers" scope="instance" type="Array"/>
      <property name="_initialized" scope="instance" type="Object"/>
      <property name="_onLoadListeners" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.rpc.OfflineRest">
    <methods>
      <method name="turnOffAutoSync" scope="instance"/>
      <method name="downloadChanges" scope="instance"/>
      <method name="addStore" scope="instance">
        <parameters>
          <parameter name="store" type="data-store" usage="required"/>
          <parameter name="baseQuery" type="query" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="sync" scope="instance" type="Object"/>
      <property name="sendChanges" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="OfflineRest">
    <properties>
      <property name="stores" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="drr">
    <methods>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_index" scope="instance" type="Object"/>
      <property name="_timeStamps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.Service">
    <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
        <parameters>
          <parameter name="smd" type="object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_generateService" scope="instance">
        <parameters>
          <parameter name="serviceName" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRequest" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_executeMethod" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_smd" scope="instance" type="Object"/>
      <property name="_options" scope="instance" type="Object"/>
      <property name="_requestId" scope="instance" type="Number"/>
      <property name="_nextId" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.secure">
    <methods>
      <method name="DOM" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unwrap" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sandbox" scope="instance">
        <description>This function will create and return a sandbox object (see dojox.secure.__Sandbox)
	for the provided element.</description>
        <parameters>
          <parameter name="element" type="The" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.secure.__Sandbox"/>
        </return-types>
      </method>
      <method name="_safeDojoFunctions" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="wrap" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="wrap the NodeList"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="badProps" scope="instance" type="RegExp"/>
      <property name="fromJson" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="wrap">
    <properties>
      <property name="safeHTML" scope="instance" type="Object"/>
      <property name="safeCSS" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.secure.capability">
    <properties>
      <property name="keywords" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.secure.capability.validate">
    <methods/>
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch">
    <methods>
      <method name="registerTool" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeToolbar" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="figure" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tools" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Anchor">
    <methods>
      <method name="type" scope="instance"/>
      <method name="beginEdit" scope="instance"/>
      <method name="endEdit" scope="instance"/>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBinding" scope="instance">
        <parameters>
          <parameter name="pt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setUndo" scope="instance"/>
      <method name="enable" scope="instance"/>
      <method name="disable" scope="instance"/>
    </methods>
    <properties>
      <property name="annotation" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_key" scope="instance" type="String"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="isControl" scope="instance" type="Object"/>
      <property name="count" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.sketch.AnnotationTool" superclass="dojox.sketch._Plugin">
    <methods>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="rect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_create" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_omd" scope="instance" type="bool"/>
      <property name="_cshape" scope="instance" type="Object"/>
      <property name="figure" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="onRemove" scope="instance">
        <parameters>
          <parameter name="noundo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="property" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="onPropertyChange" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="oldvalue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCreate" scope="instance"/>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="draw" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="setBinding" scope="instance">
        <parameters>
          <parameter name="pt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextBox" scope="instance">
        <parameters>
          <parameter name="zoomfactor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="writeCommonAttrs" scope="instance"/>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="toolclass" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="_key" scope="instance" type="Object"/>
      <property name="figure" scope="instance" type="Object"/>
      <property name="mode" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="boundingBox" scope="instance" type="Object"/>
      <property name="hasAnchors" scope="instance" type="Object"/>
      <property name="anchors" scope="instance" type="Object"/>
      <property name="_properties" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.beginEdit">
    <methods/>
    <properties>
      <property name="_type" scope="instance" type="Object"/>
      <property name="_prevState" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.endEdit">
    <methods/>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_prevState" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.calculate">
    <methods>
      <method name="slope" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dx" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
          <parameter name="dy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dy" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
          <parameter name="dx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch.Annotation.drawBBox">
    <methods/>
    <properties>
      <property name="boundingBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.setMode">
    <methods/>
    <properties>
      <property name="mode" scope="instance" type="Object"/>
      <property name="boundingBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.readCommonAttrs">
    <methods/>
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.readCommonAttrs.transform">
    <properties>
      <property name="dx" scope="instance" type="Object"/>
      <property name="dy" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.Modes">
    <properties>
      <property name="View" scope="instance" type="Number"/>
      <property name="Edit" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="startRotation" scope="instance" type="Number"/>
      <property name="endRotation" scope="instance" type="Number"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation._rot">
    <methods/>
    <properties>
      <property name="startRotation" scope="instance" type="Object"/>
      <property name="endRotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation._pos">
    <methods/>
    <properties>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.initialize">
    <methods/>
    <properties>
      <property name="endRotation" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.draw">
    <methods/>
    <properties>
      <property name="endRotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.zoom">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.zoom.figure">
    <properties>
      <property name="zoomFactor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure">
    <methods>
      <method name="hasSelections" scope="instance"/>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSelections" scope="instance"/>
      <method name="replaceSelection" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_md" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mm" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calCol" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_delete" scope="instance">
        <parameters>
          <parameter name="arr" type="Object" usage="required"/>
          <parameter name="noundo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClickShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCreateShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeCreateShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="instance"/>
      <method name="draw" scope="instance"/>
      <method name="getFit" scope="instance"/>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keyFromEvt" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fromEvt" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="annotation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="annotation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAnnotator" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="convert" scope="instance">
        <parameters>
          <parameter name="ann" type="Object" usage="required"/>
          <parameter name="t" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="_loadAnnotation" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onUndo" scope="instance"/>
      <method name="onBeforeUndo" scope="instance"/>
      <method name="onRedo" scope="instance"/>
      <method name="onBeforeRedo" scope="instance"/>
      <method name="undo" scope="instance"/>
      <method name="redo" scope="instance"/>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="annCounter" scope="instance" type="Number"/>
      <property name="shapes" scope="instance" type="Array"/>
      <property name="image" scope="instance" type="Object"/>
      <property name="imageSrc" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
      <property name="zoomFactor" scope="instance" type="Number"/>
      <property name="tools" scope="instance" type="Object"/>
      <property name="obj" scope="instance" type="Object"/>
      <property name="selected" scope="instance" type="Array"/>
      <property name="_c" scope="instance" type="Object"/>
      <property name="_ctr" scope="instance" type="Object"/>
      <property name="_lp" scope="instance" type="Object"/>
      <property name="_action" scope="instance" type="Object"/>
      <property name="_prevState" scope="instance" type="Object"/>
      <property name="_startPoint" scope="instance" type="Object"/>
      <property name="_ctool" scope="instance" type="Object"/>
      <property name="_start" scope="instance" type="Object"/>
      <property name="_end" scope="instance" type="Object"/>
      <property name="_absEnd" scope="instance" type="Object"/>
      <property name="_cshape" scope="instance" type="Object"/>
      <property name="gridSize" scope="instance" type="Number"/>
      <property name="getValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.initUndoStack">
    <methods/>
    <properties>
      <property name="history" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.setTool">
    <methods/>
    <properties>
      <property name="_ctool" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.initialize">
    <methods/>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="image" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.destroy">
    <methods/>
    <properties>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="obj" scope="instance" type="Object"/>
      <property name="shapes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.zoom">
    <methods/>
    <properties>
      <property name="zoomFactor" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.unzoom">
    <methods/>
    <properties>
      <property name="zoomFactor" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.setValue">
    <methods/>
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.load">
    <methods/>
    <properties>
      <property name="size" scope="instance" type="Object"/>
      <property name="imageSize" scope="instance" type="Object"/>
      <property name="imageSrc" scope="instance" type="Object"/>
      <property name="_loadDeferred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation._pos">
    <methods/>
    <properties>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply">
    <methods/>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.initialize">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Number"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation._pos">
    <methods/>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.apply">
    <methods/>
    <properties>
      <property name="radius" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.apply.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.apply.end">
    <properties>
      <property name="x" scope="instance" type="String"/>
      <property name="y" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.initialize">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="rotation" scope="instance" type="Number"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation._rot">
    <methods/>
    <properties>
      <property name="rotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation._pos">
    <methods/>
    <properties>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply">
    <methods/>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.initialize">
    <methods/>
    <properties>
      <property name="rotation" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.draw">
    <methods/>
    <properties>
      <property name="rotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.zoom">
    <methods/>
    <properties>
      <property name="_curPct" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.zoom.figure">
    <properties>
      <property name="zoomFactor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Slider" superclass="dojox.sketch._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="_zoomToFit" scope="instance"/>
      <method name="_setZoom" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="t" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="slider" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Slider.slider._movable.node">
    <properties>
      <property name="title" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.sketch.ButtonGroup">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="plugin" type="_Plugin" usage="required"/>
        </parameters>
      </method>
      <method name="_resetGroup" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_children" scope="instance-prototype" type="Array"/>
      <property name="_childMaps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Toolbar" superclass="dijit.Toolbar">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setFigure" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="addGroupItem" scope="instance">
        <parameters>
          <parameter name="item" type="_Plugin" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_setShape" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Toolbar" scope="instance"/>
    </mixins>
    <properties>
      <property name="figure" scope="instance" type="Object"/>
      <property name="plugins" scope="instance" type="Array"/>
      <property name="shapeGroup" scope="instance" type="Object"/>
      <property name="_plugins" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotationTool" superclass="dojox.sketch.AnnotationTool">
    <methods>
      <method name="onMouseDown" scope="instance"/>
      <method name="onMouseUp" scope="instance"/>
      <method name="onMouseMove" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch.AnnotationTool" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.sketch.UnderlineAnnotationTool.figure">
    <properties>
      <property name="_end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.initialize">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.getBBox">
    <methods/>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.getBBox.figure">
    <properties>
      <property name="zoomFactor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UndoStack">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="ann" type="ta.Annotation" usage="optional"/>
          <parameter name="before" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="undo" scope="instance"/>
      <method name="redo" scope="instance"/>
    </methods>
    <properties>
      <property name="_undoedSteps" scope="instance-prototype" type="Array"/>
      <property name="figure" scope="instance" type="Object"/>
      <property name="_steps" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.sketch.CommandTypes">
    <properties>
      <property name="Create" scope="instance" type="String"/>
      <property name="Move" scope="instance" type="String"/>
      <property name="Modify" scope="instance" type="String"/>
      <property name="Delete" scope="instance" type="String"/>
      <property name="Convert" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.sketch._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="onActivate" scope="instance"/>
      <method name="activate" scope="instance">
        <parameters>
          <parameter name="e" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFigure" scope="instance">
        <parameters>
          <parameter name="figure" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="figure" scope="instance" type="Object"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="itemGroup" scope="instance" type="String"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="queryCommand" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="String"/>
      <property name="useDefaultCommand" scope="instance" type="Object"/>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.socket">
    <methods>
      <method name="Reconnect" scope="instance">
        <parameters>
          <parameter name="socket" type="Socket" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
        <return-description>An object that implements the WebSocket API</return-description>
      </method>
    </methods>
  </class>
  <class type="Socket">
    <methods>
      <method name="WebSocket" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="socket" type="Object" usage="required"/>
          <parameter name="newSocket" type="Object" usage="required"/>
          <parameter name="listenForOpen" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="LongPoll" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-description>An object that implements the WebSocket API</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.sql">
    <description>There are four ways to call this:
	1) Straight SQL: dojox.sql("SELECT * FROM FOOBAR");
	2) SQL with parameters: dojox.sql("INSERT INTO FOOBAR VALUES (?)", someParam)
	3) Encrypting particular values:
	dojox.sql("INSERT INTO FOOBAR VALUES (ENCRYPT(?))", someParam, "somePassword", callback)
	4) Decrypting particular values:
	dojox.sql("SELECT DECRYPT(SOMECOL1), DECRYPT(SOMECOL2) FROM
	FOOBAR WHERE SOMECOL3 = ?", someParam,
	"somePassword", callback)
	For encryption and decryption the last two values should be the the password for
	encryption/decryption, and the callback function that gets the result set.
	Note: We only support ENCRYPT(?) statements, and
	and DECRYPT(*) statements for now -- you can not have a literal string
	inside of these, such as ENCRYPT('foobar')
	Note: If you have multiple columns to encrypt and decrypt, you can use the following
	convenience form to not have to type ENCRYPT(?)/DECRYPT(*) many times:
	dojox.sql("INSERT INTO FOOBAR VALUES (ENCRYPT(?, ?, ?))",
	someParam1, someParam2, someParam3,
	"somePassword", callback)
	dojox.sql("SELECT DECRYPT(SOMECOL1, SOMECOL2) FROM
	FOOBAR WHERE SOMECOL3 = ?", someParam,
	"somePassword", callback)</description>
    <methods>
      <method name="_printDebugSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeResults" scope="instance">
        <parameters>
          <parameter name="rs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsEncrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsDecrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sql" scope="instance"/>
    </mixins>
    <properties>
      <property name="dbName" scope="instance" type="Object"/>
      <property name="debug" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql.open">
    <methods/>
    <properties>
      <property name="dbName" scope="instance" type="Object"/>
      <property name="_dbOpen" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql.close">
    <methods/>
    <properties>
      <property name="dbName" scope="instance" type="Object"/>
      <property name="_dbOpen" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.sql._exec">
    <methods/>
    <properties>
      <property name="_autoClose" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._initDb">
    <methods/>
    <properties>
      <property name="db" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._SQLCrypto">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execEncryptSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execDecryptSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="encryptColumns" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decrypt" scope="instance">
        <parameters>
          <parameter name="resultSet" type="Object" usage="required"/>
          <parameter name="needsDecrypt" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stripCryptoSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_flagEncryptedArgs" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_determineDecryptedColumns" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decryptSingleColumn" scope="instance">
        <parameters>
          <parameter name="columnName" type="Object" usage="required"/>
          <parameter name="columnValue" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="currentRowIndex" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_totalCrypto" scope="instance" type="Number"/>
      <property name="_finishedCrypto" scope="instance" type="Number"/>
      <property name="_finishedSpawningCrypto" scope="instance" type="Object"/>
      <property name="_finalArgs" scope="instance" type="Object"/>
      <property name="_finalResultSet" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto">
    <description>Taken from http://www.movable-type.co.uk/scripts/aes.html by
	Chris Veness (CLA signed); adapted for Dojo and Google Gears Worker Pool
	by Brad Neuberg, bkn3@columbia.edu</description>
    <methods>
      <method name="encrypt" scope="instance">
        <parameters>
          <parameter name="plaintext" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decrypt" scope="instance">
        <parameters>
          <parameter name="ciphertext" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_workerHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_POOL_SIZE" scope="instance" type="Size"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto._initWorkerPool">
    <methods/>
    <properties>
      <property name="_unemployed" scope="instance" type="Array"/>
      <property name="_employed" scope="instance" type="Object"/>
      <property name="_handleMessage" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto._initWorkerPool._manager">
    <methods>
      <method name="onmessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sql._crypto._assignWork">
    <methods/>
    <properties>
      <property name="_handleMessage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage">
    <properties>
      <property name="_common" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirDBStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="_sql" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_beginTransaction" scope="instance"/>
      <method name="_commitTransaction" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="DATABASE_FILE" scope="instance" type="String"/>
      <property name="TABLE_NAME" scope="instance" type="String"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_db" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirEncryptedLocalStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirFileStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_storagePath" scope="instance" type="String"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.BehaviorStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="_createStore" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_addKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="storeName" scope="instance" type="String"/>
      <property name="keys" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.CookieStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_save" scope="instance"/>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="cookieName" scope="instance" type="String"/>
      <property name="storageLife" scope="instance" type="Number"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.FlashStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="setFlushDelay" scope="instance">
        <parameters>
          <parameter name="newDelay" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFlushDelay" scope="instance"/>
      <method name="flush" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="_destringify" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="getResourceList" scope="instance"/>
      <method name="_loaded" scope="instance"/>
      <method name="_onStatus" scope="instance">
        <parameters>
          <parameter name="statusResult" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_available" scope="instance" type="bool"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
      <property name="_flashReady" scope="instance" type="bool"/>
      <property name="_pageReady" scope="instance" type="bool"/>
      <property name="_allNamespaces" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.GearsStorageProvider" superclass="dojox.storage.Provider">
    <description>You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableGearsStorage: true };
	Authors of this storage provider-
	Brad Neuberg, bkn3@columbia.edu
	instance methods and properties</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="_initStorage" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="TABLE_NAME" scope="instance" type="String"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_available" scope="instance" type="Object"/>
      <property name="_storageReady" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.LocalStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.Provider">
    <description>dojox.storage exposes the current available storage provider on this
	platform. It gives you methods such as dojox.storage.put(),
	dojox.storage.get(), etc.
	For more details on dojox.storage, see the primary documentation
	page at
	http://manual.dojotoolkit.org/storage.html
	Note for storage provider developers who are creating subclasses-
	This is the base class for all storage providers Specific kinds of
	Storage Providers should subclass this and implement these methods.
	You should avoid initialization in storage provider subclass's
	constructor; instead, perform initialization in your initialize()
	method.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onHideSettingsUI" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <description>Example-
	var resultsHandler = function(status, key, message, namespace){
	alert("status="+status+", key="+key+", message="+message);
	};
	dojox.storage.put("test", "hello world", resultsHandler);
	Arguments:
	status - The status of the put operation, given by
	dojox.storage.FAILED, dojox.storage.SUCCEEDED, or
	dojox.storage.PENDING
	key - The key that was used for the put
	message - An optional message if there was an error or things failed.
	namespace - The namespace of the key. This comes at the end since
	it was added later.
	Important note: if you are using Dojo Storage in conjunction with
	Dojo Offline, then you don't need to provide
	a resultsHandler; this is because for Dojo Offline we
	use Google Gears to persist data, which has unlimited data
	once the user has given permission. If you are using Dojo
	Storage apart from Dojo Offline, then under the covers hidden
	Flash might be used, which is both asychronous and which might
	get denied; in this case you must provide a resultsHandler.</description>
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="hasKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance">
        <return-description>Returns the maximum storage size
	supported by this provider, in
	thousands of bytes (i.e., if it
	returns 60 then this means that 60K
	of storage is supported).
	If this provider can not determine
	it's maximum size, then
	dojox.storage.SIZE_NOT_AVAILABLE is
	returned; if there is no theoretical
	limit on the amount of storage
	this provider can return, then
	dojox.storage.SIZE_NO_LIMIT is
	returned</return-description>
      </method>
      <method name="putMultiple" scope="instance">
        <description>Example-
	var resultsHandler = function(status, key, message){
	alert("status="+status+", key="+key+", message="+message);
	};
	dojox.storage.put(["test"], ["hello world"], resultsHandler);
	Important note: if you are using Dojo Storage in conjunction with
	Dojo Offline, then you don't need to provide
	a resultsHandler; this is because for Dojo Offline we
	use Google Gears to persist data, which has unlimited data
	once the user has given permission. If you are using Dojo
	Storage apart from Dojo Offline, then under the covers hidden
	Flash might be used, which is both asychronous and which might
	get denied; in this case you must provide a resultsHandler.</description>
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isValidKeyArray" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceList" scope="instance">
        <description>This method returns a list of URLs that this
	storage provider depends on to do its work.
	This list is used by the Dojo Offline Toolkit
	to cache these resources to ensure the machinery
	used by this storage provider is available offline.
	What is returned is an array of URLs.
	Note that Dojo Offline uses Gears as its native
	storage provider, and does not support using other
	kinds of storage providers while offline anymore.</description>
      </method>
    </methods>
    <properties>
      <property name="SUCCESS" scope="instance" type="String"/>
      <property name="FAILED" scope="instance" type="String"/>
      <property name="PENDING" scope="instance" type="String"/>
      <property name="SIZE_NOT_AVAILABLE" scope="instance" type="String"/>
      <property name="SIZE_NO_LIMIT" scope="instance" type="String"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.storage.WhatWGStorageProvider" superclass="dojox.storage.Provider">
    <description>The WHAT WG storage API is documented at
	http://www.whatwg.org/specs/web-apps/current-work/#scs-client-side
	You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableWhatWGStorage: true };
	Authors of this storage provider-
	JB Boisseau, jb.boisseau@eutech-ssii.com
	Brad Neuberg, bkn3@columbia.edu</description>
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_domain" scope="instance" type="Object"/>
      <property name="_available" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
      <property name="_allNamespaces" scope="instance" type="Object"/>
      <property name="_storageEventListener" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.BidiComplex">
    <methods>
      <method name="attachInput" scope="instance">
        <parameters>
          <parameter name="field" type="DOMNode" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="createDisplayString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="stripSpecialCharacters" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_ceKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ceKeyUp" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processCopy" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="isReverse" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ceCopyText" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ceCutText" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCaretPos" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedRange" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="selectionStart" type="Object" usage="required"/>
          <parameter name="selectionEnd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string">
    <methods>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="re" type="RegExp" usage="required"/>
          <parameter name="parseDelim" type="Function" usage="optional"/>
          <parameter name="instance" type="Object" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.Builder">
    <methods>
      <method name="append" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="concat" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="appendArray" scope="instance">
        <parameters>
          <parameter name="strings" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="oldStr" type="String" usage="required"/>
          <parameter name="newStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="start" type="Number" usage="required"/>
          <parameter name="len" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf"/>
  <class type="dojox.string.sprintf.Formatter">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="filler" type="mixed" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="formatInt" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatDouble" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zeroPad" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="length" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="fitField" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="spacePad" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="length" type="Int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_re" scope="instance" type="RegExp"/>
      <property name="_zeros10" scope="instance" type="String"/>
      <property name="_spaces10" scope="instance" type="String"/>
      <property name="_mapped" scope="instance" type="bool"/>
      <property name="_format" scope="instance" type="Object"/>
      <property name="_tokens" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._parseDelim">
    <methods/>
    <properties>
      <property name="_mapped" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers"/>
  <class type="dojox.string.sprintf.Formatter._specifiers.b">
    <properties>
      <property name="base" scope="instance" type="Number"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.o">
    <properties>
      <property name="base" scope="instance" type="Number"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.x">
    <properties>
      <property name="base" scope="instance" type="Number"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.X">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.d">
    <properties>
      <property name="base" scope="instance" type="Number"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.i">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.u">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
      <property name="isUnsigned" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.c">
    <methods>
      <method name="setArg" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.s">
    <methods>
      <method name="setMaxWidth" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.e">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.E">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.f">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.F">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.g">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.G">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.testing"/>
  <class type="dojox.testing.DocTest">
    <description>DocTests are tests that are defined inside the comment.
	A doctest looks as if it was copied from the shell (which it mostly is).
	A doctest is executed when the following conditions match:
	1) all lines are comments
	2) the line always starts with spaces/tabs followed by "//"
	and at least one space
	3) the line(s) of the test to execute starts with "&gt;&gt;&gt;"
	preceeded by what is described in 2)
	4) the first line after 3) starting without "&gt;&gt;&gt;" is the exptected result.
	preceeded by what is described in 2)
	5) the test sequence is terminated by an empty line, or the next
	test in the following line, or a new line that does not start as described in 2)
	(simple said: is not a comment)
	preceeded by what is described in 2)
	I.e. the following is a simple doctest, that will actually also be run
	if you run this class against this file here:
	&gt;&gt;&gt; 1+1 // A simple test case. Terminated by an empty line
	2
	&gt;&gt;&gt; 1==2
	false
	&gt;&gt;&gt; "a"+"b" // Also without the empty line before, this is a new test.
	"ab"
	&gt;&gt;&gt; var anything = "anything" // Multiple commands for one test.
	&gt;&gt;&gt; "something"==anything
	false
	DocTests are great for inline documenting a class or method, they also
	are very helpful in understanding what the class/method actually does.
	They don't make sense everywhere, but sometimes they are really handy.</description>
    <methods>
      <method name="getTests" scope="instance">
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTestsFromString" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getTestsFromString" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
          <parameter name="insideComments" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="run" scope="instance">
        <parameters>
          <parameter name="moduleName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_run" scope="instance">
        <parameters>
          <parameter name="tests" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="runTest" scope="instance">
        <parameters>
          <parameter name="commands" type="Object" usage="required"/>
          <parameter name="expected" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="errors" scope="instance" type="Array"/>
      <property name="tests" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing">
    <properties>
      <property name="ThreadPool" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Sequence">
    <description>This array will contain the sequence defines resolved, so that
	ie. repeat:10 will result in 10 elements in the sequence, so
	the repeat handling is easier and we don't need to handle that
	many extra cases. Also the doneFunction, if given is added at the
	end of the resolved-sequences.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="go" scope="instance">
        <parameters>
          <parameter name="defs" type="Array" usage="required"/>
          <parameter name="doneFunction" type="Function|Array" usage="optional"/>
        </parameters>
      </method>
      <method name="_go" scope="instance"/>
      <method name="goOn" scope="instance"/>
      <method name="stop" scope="instance">
        <description>This can only interrupt the sequence not the last function that
	had been started. If the last function was i.e. a slideshow
	that is handled inside a function that you have given as
	one sequence item it cant be stopped, since it is not controlled
	by this object here. In this case it would be smarter to
	run the slideshow using a sequence object so you can also stop
	it using this method.</description>
      </method>
    </methods>
    <properties>
      <property name="_defsResolved" scope="instance-prototype" type="Array"/>
      <property name="_goOnPause" scope="instance" type="Integer"/>
      <property name="_running" scope="instance" type="bool"/>
      <property name="_curId" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.timing.Streamer">
    <methods>
      <method name="inputFunction" scope="instance"/>
      <method name="outputFunction" scope="instance"/>
      <method name="setInterval" scope="instance">
        <parameters>
          <parameter name="ms" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="onTick" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.timing.Streamer" usage="required"/>
        </parameters>
      </method>
      <method name="start" scope="instance"/>
      <method name="onStart" scope="instance"/>
      <method name="stop" scope="instance"/>
      <method name="onStop" scope="instance"/>
    </methods>
    <properties>
      <property name="interval" scope="instance" type="the"/>
      <property name="minimumSize" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.timing.threadStates">
    <properties>
      <property name="UNSTARTED" scope="instance" type="String"/>
      <property name="STOPPED" scope="instance" type="String"/>
      <property name="PENDING" scope="instance" type="String"/>
      <property name="RUNNING" scope="instance" type="String"/>
      <property name="SUSPENDED" scope="instance" type="String"/>
      <property name="WAITING" scope="instance" type="String"/>
      <property name="COMPLETE" scope="instance" type="String"/>
      <property name="ERROR" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.timing.threadPriorities">
    <properties>
      <property name="LOWEST" scope="instance" type="Number"/>
      <property name="BELOWNORMAL" scope="instance" type="Number"/>
      <property name="NORMAL" scope="instance" type="Number"/>
      <property name="ABOVENORMAL" scope="instance" type="Number"/>
      <property name="HIGHEST" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.timing.Thread">
    <methods>
      <method name="invoke" scope="instance"/>
    </methods>
    <properties>
      <property name="state" scope="instance" type="Object"/>
      <property name="priority" scope="instance" type="Object"/>
      <property name="lastError" scope="instance" type="Object"/>
      <property name="func" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer">
    <methods>
      <method name="onTick" scope="instance"/>
    </methods>
    <properties>
      <property name="timer" scope="instance" type="Object"/>
      <property name="isRunning" scope="instance" type="bool"/>
      <property name="interval" scope="instance" type="Interval"/>
      <property name="onStart" scope="instance" type="Object"/>
      <property name="onStop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer.setInterval">
    <methods/>
    <properties>
      <property name="interval" scope="instance" type="New"/>
      <property name="timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer.start">
    <description>Calls the "onStart()" handler, if defined.
	Note that the onTick() function is not called right away,
	only after first interval passes.</description>
    <methods/>
    <properties>
      <property name="isRunning" scope="instance" type="Object"/>
      <property name="timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer.stop">
    <description>Calls the "onStop()" handler, if defined.</description>
    <methods/>
    <properties>
      <property name="isRunning" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.timing.doLater">
    <description>dojox.timing.doLater(conditional) is testing if the call
	should be done later. So it returns
	true if the param is false.
	arguments:</description>
  </class>
  <class type="dojox.timing.doLater.caller">
    <properties>
      <property name="arguments" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid">
    <methods>
      <method name="assert" scope="instance">
        <description>If the asserted condition is true, this method does nothing. If the
	condition is false, we throw an error with a error message.</description>
        <parameters>
          <parameter name="booleanValue" type="Boolean" usage="required"/>
          <parameter name="message" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="generateNilUuid" scope="instance">
        <description>The Nil UUID is described in section 4.1.7 of
	RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.1.7
	examples:
	var string = dojox.uuid.generateNilUuid();</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="getVariant" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.variant"/>
        </return-types>
      </method>
      <method name="getVersion" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.version"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String (a 12-character string, which will look something like &quot;917bf397618a&quot;)"/>
        </return-types>
      </method>
      <method name="getTimestamp" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
          <parameter name="returnType" type="String" usage="optional"/>
        </parameters>
        <return-description>Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	examples:
	var uuidString = "b4308fb0-86cd-11da-a72b-0800200c9a66";
	var date, string, hexString;
	date   = dojox.uuid.getTimestamp(uuidString);         // returns a JavaScript Date
	date   = dojox.uuid.getTimestamp(uuidString, Date);     //
	string = dojox.uuid.getTimestamp(uuidString, String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	hexString = dojox.uuid.getTimestamp(uuidString, "hex"); // "1da86cdb4308fb0"</return-description>
        <return-types>
          <return-type type="String (e.g. &quot;Mon, 16 Jan 2006 20:21:41 GMT&quot;)"/>
          <return-type type="String (e.g. &quot;1da86cdb4308fb0&quot;)"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="generateRandomUuid" scope="instance">
        <description>A typical generated value would be something like this:
	"3b12f1df-5232-4804-897e-917bf397618a"
	For more information about random UUIDs, see sections 4.4 and
	4.5 of RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.4
	This generator function is designed to be small and fast,
	but not necessarily good.
	Small: This generator has a small footprint. Once comments are
	stripped, it's only about 25 lines of code, and it doesn't
	dojo.require() any other modules.
	Fast: This generator can generate lots of new UUIDs fairly quickly
	(at least, more quickly than the other dojo UUID generators).
	Not necessarily good: We use Math.random() as our source
	of randomness, which may or may not provide much randomness.
	examples:
	var string = dojox.uuid.generateRandomUuid();</description>
        <return-types>
          <return-type type="for example: &quot;3B12F1DF&quot;"/>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="NIL_UUID" scope="instance" type="String"/>
      <property name="_ourVariantLookupTable" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid">
    <methods>
      <method name="compare" scope="instance">
        <description>This implementation is intended to match the sample implementation
	in IETF RFC 4122: http://www.ietf.org/rfc/rfc4122.txt</description>
        <parameters>
          <parameter name="uuidOne" type="dojox.uuid.Uuid" usage="required"/>
          <parameter name="uuidTwo" type="dojox.uuid.Uuid" usage="required"/>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="integer"/>
          <return-type type="integer (either 0, 1, or -1)"/>
        </return-types>
      </method>
      <method name="setGenerator" scope="instance">
        <parameters>
          <parameter name="generator" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="getGenerator" scope="instance">
        <return-types>
          <return-type type="generator (A UUID generator, such as dojox.uuid.TimeBasedGenerator)."/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="isEqual" scope="instance">
        <parameters>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isValid" scope="instance"/>
      <method name="getVariant" scope="instance"/>
    </methods>
    <properties>
      <property name="_uuidString" scope="instance" type="Object"/>
      <property name="_ourGenerator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid.getVersion">
    <methods/>
    <properties>
      <property name="_versionNumber" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid.getNode">
    <methods/>
    <properties>
      <property name="_nodeString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid.getTimestamp">
    <methods/>
    <properties>
      <property name="_timestampAsHexString" scope="instance" type="Object"/>
      <property name="_timestampAsDate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.version">
    <properties>
      <property name="UNKNOWN" scope="instance" type="Number"/>
      <property name="TIME_BASED" scope="instance" type="Number"/>
      <property name="DCE_SECURITY" scope="instance" type="Number"/>
      <property name="NAME_BASED_MD5" scope="instance" type="Number"/>
      <property name="RANDOM" scope="instance" type="Number"/>
      <property name="NAME_BASED_SHA1" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.uuid.variant">
    <properties>
      <property name="NCS" scope="instance" type="String"/>
      <property name="DCE" scope="instance" type="String"/>
      <property name="MICROSOFT" scope="instance" type="String"/>
      <property name="UNKNOWN" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.uuid.generateTimeBasedUuid">
    <description>For more info, see
	http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt
	http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm
	http://kruithof.xs4all.nl/uuid/uuidgen
	http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20
	http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html</description>
    <methods>
      <method name="isValidNode" scope="instance">
        <parameters>
          <parameter name="node" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <return-types>
          <return-type type="String (a 12-character hex string representing a pseudoNode or hardwareNode)"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_generator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.generateTimeBasedUuid.setNode">
    <methods/>
    <properties>
      <property name="_uniformNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.validate.br">
    <methods>
      <method name="isValidCnpj" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="computeCnpjDv" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="isValidCpf" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="computeCpfDv" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.validate.ca">
    <methods>
      <method name="isPhoneNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isProvince" scope="instance">
        <parameters>
          <parameter name="value" type="String[2]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isSocialInsuranceNumber" scope="instance">
        <description>Validates Canadian 9 digit social insurance number for several
	common formats. This routine only pattern matches and does not
	use the Luhn Algorithm to validate number.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isPostalCode" scope="instance">
        <description>Validates Canadian 6 digit postal code.
	Canadian postal codes are in the format ANA NAN,
	where A is a letter and N is a digit, with a space
	separating the third and fourth characters.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.validate._cardInfo">
    <description>A hash of valid CC abbreviations and regular expressions</description>
    <properties>
      <property name="mc" scope="instance" type="Mastercard"/>
      <property name="ec" scope="instance" type="Eurocard"/>
      <property name="vi" scope="instance" type="Visa"/>
      <property name="ax" scope="instance" type="American"/>
      <property name="dc" scope="instance" type="Diners"/>
      <property name="bl" scope="instance" type="Carte"/>
      <property name="di" scope="instance" type="Discover"/>
      <property name="jcb" scope="instance" type="JCB"/>
      <property name="er" scope="instance" type="Enroute"/>
    </properties>
  </class>
  <class type="dojox.validate.regexp">
    <methods>
      <method name="ipAddress" scope="instance">
        <description>Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	Supports 2 formats for Ipv6.
	flags  An object.  All flags are boolean with default = true.
	flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	Case insensitive.  Zero padding allowed.
	flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	FIXME: ipv6 can be written multiple ways IIRC
	flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="host" scope="instance">
        <description>A host is a named host (A-z0-9_- but not starting with -), a domain name or an IP address, possibly followed by a port number.</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="url" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="&quot;; } return &quot;&quot;; }"/>
        </return-types>
      </method>
      <method name="emailAddress" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="numberFormat" scope="instance">
        <description>Use this method for phone numbers, social security numbers, zip-codes, etc.
	The RE can match one format or one of multiple formats.
	Format
	#        Stands for a digit, 0-9.
	?        Stands for an optional digit, 0-9 or nothing.
	All other characters must appear literally in the expression.
	Example
	"(###) ###-####"       -&gt;   (510) 542-9742
	"(###) ###-#### x#???" -&gt;   (510) 542-9742 x153
	"###-##-####"          -&gt;   506-82-1089       i.e. social security number
	"#####-####"           -&gt;   98225-1649        i.e. zip code</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="emailAddressList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.validate.regexp.ca">
    <methods>
      <method name="postalCode" scope="instance"/>
      <method name="province" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.validate.regexp.us">
    <methods>
      <method name="state" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.validate.us">
    <methods>
      <method name="isState" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isPhoneNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isSocialSecurityNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isZipCode" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.widget.gauge"/>
  <class type="dojox.widget.gauge.AnalogLineIndicator" superclass="dojox.widget.gauge._Indicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge._Indicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="text" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="String"/>
      <property name="length" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="highlight" scope="instance" type="String"/>
      <property name="shapes" scope="instance" type="Object"/>
      <property name="currentValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget">
    <description>These are standalone widgets with varying levels of stability. Some are useful,
	some were created for demonstration purposes, and learning tools. The each maintain
	their own .css file (typically dojox/widget/WidgetName/WidgetName.css)</description>
    <properties>
      <property name="CalendarFx" scope="instance" type="Object"/>
      <property name="CalendarViews" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.AnalogGauge" superclass="dojox.widget.gauge._Gauge">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_getAngle" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueForAngle" scope="instance">
        <parameters>
          <parameter name="angle" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_getRadians" scope="instance">
        <parameters>
          <parameter name="angle" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_getDegrees" scope="instance">
        <parameters>
          <parameter name="radians" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <description>Draws the gauge by drawing the surface, the ranges, and the indicators.</description>
      </method>
      <method name="drawRange" scope="instance">
        <description>Draws a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRangeUnderMouse" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dragIndicator" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge._Gauge" scope="instance"/>
    </mixins>
    <properties>
      <property name="startAngle" scope="instance" type="Number"/>
      <property name="endAngle" scope="instance" type="Number"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="radius" scope="instance" type="Number"/>
      <property name="_defaultIndicator" scope="instance" type="override"/>
      <property name="_oppositeMiddle" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.AutoRotator" superclass="dojox.widget.Rotator">
    <description>Adds automatic rotating to the dojox.widget.Rotator.  The
	AutoRotator has parameters that control how user input can
	affect the rotator including a suspend when hovering over the
	rotator and pausing when the user manually advances to another
	pane.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="skipCycleDecrement" type="boolean" usage="optional"/>
          <parameter name="skipDuration" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="instance"/>
      <method name="_now" scope="instance"/>
      <method name="_resetTimer" scope="instance"/>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="manual" type="boolean|int" usage="optional"/>
        </parameters>
      </method>
      <method name="onManualChange" scope="instance">
        <parameters>
          <parameter name="action" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Rotator" scope="instance"/>
    </mixins>
    <properties>
      <property name="suspendOnHover" scope="instance" type="boolean"/>
      <property name="duration" scope="instance" type="int"/>
      <property name="autoStart" scope="instance" type="boolean"/>
      <property name="pauseOnManualChange" scope="instance" type="boolean"/>
      <property name="cycles" scope="instance" type="int"/>
      <property name="random" scope="instance" type="boolean"/>
      <property name="reverse" scope="instance" type="boolean"/>
      <property name="playing" scope="instance" type="bool"/>
      <property name="_resumeDuration" scope="instance" type="Number"/>
      <property name="_endTime" scope="instance" type="String"/>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_suspended" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.BarLineIndicator" superclass="dojox.widget.gauge._Indicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge._Indicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="shapes" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="String"/>
      <property name="length" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="highlight" scope="instance" type="String"/>
      <property name="highlight2" scope="instance" type="String"/>
      <property name="currentValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.BarLineIndicator._gauge">
    <properties>
      <property name="max" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.BarGauge" superclass="dojox.widget.gauge._Gauge">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a bar graph component, used to display numerical data in a familiar format.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.BarGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div 	dojoType="dojox.widget.BarGauge"
	id="testBarGauge"
	barGaugeHeight="55"
	dataY="25"
	dataHeight="25"
	dataWidth="225"&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_getPosition" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueForPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <description>Draws the bar graph by drawing the surface, the ranges, and the indicators.</description>
      </method>
      <method name="drawRange" scope="instance">
        <description>Draws a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRangeUnderMouse" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dragIndicator" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge._Gauge" scope="instance"/>
    </mixins>
    <properties>
      <property name="dataX" scope="instance" type="Number"/>
      <property name="dataY" scope="instance" type="Number"/>
      <property name="dataWidth" scope="instance" type="Number"/>
      <property name="dataHeight" scope="instance" type="Number"/>
      <property name="_defaultIndicator" scope="instance" type="override"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="parseInitialValue" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="new Date(value);"/>
        </return-types>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="addFx" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInvalidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_onDateSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goToToday" scope="instance"/>
      <method name="_transitionVert" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_updateTitleStyle" scope="instance"/>
      <method name="_slideTable" scope="instance">
        <parameters>
          <parameter name="widget" type="String" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_addView" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getClassForDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_adjustDisplay" scope="instance">
        <parameters>
          <parameter name="part" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
          <parameter name="noSlide" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_views" scope="instance-prototype" type="Array"/>
      <property name="useFx" scope="instance" type="Boolean"/>
      <property name="widgetsInTemplate" scope="instance" type="Boolean"/>
      <property name="value" scope="instance-prototype" type="Date"/>
      <property name="footerFormat" scope="instance" type="String"/>
      <property name="displayMonth" scope="instance" type="Object"/>
      <property name="_currentChild" scope="instance" type="Number"/>
      <property name="_internalValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase.constraints">
    <properties>
      <property name="min" scope="instance" type="Object"/>
      <property name="max" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase.footer">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase._children">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarView" superclass="dijit._Widget">
    <methods>
      <method name="cloneClass" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeader" scope="instance"/>
      <method name="onValueSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplay" scope="instance"/>
      <method name="onBeforeDisplay" scope="instance"/>
      <method name="onBeforeUnDisplay" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="headerClass" scope="instance" type="String"/>
      <property name="useHeader" scope="instance" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarDay">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <properties>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarDayView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onDisplay" scope="instance"/>
      <method name="_onDayClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateDays" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="datePart" scope="instance" type="String"/>
      <property name="dayWidth" scope="instance" type="String"/>
      <property name="_addedFx" scope="instance" type="Object"/>
      <property name="_lastDate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarMonthYear">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._CalendarMonthYearView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeader" scope="instance"/>
      <method name="_getMonthNames" scope="instance">
        <parameters>
          <parameter name="format" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateMonths" scope="instance"/>
      <method name="_populateYears" scope="instance">
        <parameters>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelectedYear" scope="instance"/>
      <method name="_updateSelectedMonth" scope="instance"/>
      <method name="_updateSelectedNode" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="filter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onOk" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="datePart" scope="instance" type="String"/>
      <property name="displayedYears" scope="instance" type="Number"/>
      <property name="useHeader" scope="instance" type="bool"/>
      <property name="monthContainer" scope="instance" type="Object"/>
      <property name="yearContainer" scope="instance" type="Object"/>
      <property name="_decBtn" scope="instance" type="Object"/>
      <property name="_incBtn" scope="instance" type="Object"/>
      <property name="_cachedDate" scope="instance" type="Object"/>
      <property name="_monthNames" scope="instance" type="Object"/>
      <property name="_displayedYear" scope="instance" type="Object"/>
      <property name="_year" scope="instance" type="Object"/>
      <property name="_month" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Calendar2Pane" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.Calendar" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.DailyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.MonthAndYearlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._FisheyeFX">
    <methods>
      <method name="addFx" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.widget.CalendarFisheye" superclass="dojox.widget.Calendar">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._FisheyeFX.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget.Calendar" scope="instance"/>
      <mixin type="dojox.widget._FisheyeFX" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._CalendarMonth">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._CalendarMonthView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="datePart" scope="instance" type="String"/>
      <property name="headerClass" scope="instance" type="String"/>
      <property name="_getMonthNames" scope="instance" type="Object"/>
      <property name="_populateMonths" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarMonthView.header">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarYear">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <properties>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarYearView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="displayedYears" scope="instance" type="Number"/>
      <property name="_populateYears" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Calendar3Pane" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.MonthlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarMonth.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.YearlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.ColorPicker" superclass="dijit.form._FormWidget">
    <description>Provides an interactive HSV ColorPicker similar to
	PhotoShop's color selction tool. This is an enhanced
	version of the default dijit.ColorPalette, though provides
	no accessibility.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColor" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setTimer" scope="instance">
        <parameters>
          <parameter name="mover" type="d.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_clearTimer" scope="instance">
        <parameters>
          <parameter name="mover" type="d.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_setHue" scope="instance">
        <parameters>
          <parameter name="h" type="Decimal" usage="required"/>
        </parameters>
      </method>
      <method name="_updateHueCursorNode" scope="instance">
        <parameters>
          <parameter name="count" type="-1" usage="required"/>
          <parameter name="node" type="The" usage="required"/>
          <parameter name="e" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_updateCursorNode" scope="instance">
        <parameters>
          <parameter name="count" type="-1" usage="required"/>
          <parameter name="node" type="The" usage="required"/>
          <parameter name="e" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColor" scope="instance"/>
      <method name="_colorInputChange" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValue" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
          <parameter name="fireChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePickerLocations" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColorInputs" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
        </parameters>
      </method>
      <method name="_setHuePoint" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_stopDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="showRgb" scope="instance" type="Boolean"/>
      <property name="showHsv" scope="instance" type="Boolean"/>
      <property name="showHex" scope="instance" type="Boolean"/>
      <property name="webSafe" scope="instance" type="Boolean"/>
      <property name="animatePoint" scope="instance" type="Boolean"/>
      <property name="slideDuration" scope="instance" type="Integer"/>
      <property name="liveUpdate" scope="instance" type="Boolean"/>
      <property name="PICKER_HUE_H" scope="instance" type="int"/>
      <property name="PICKER_SAT_VAL_H" scope="instance" type="int"/>
      <property name="PICKER_SAT_VAL_W" scope="instance" type="int"/>
      <property name="PICKER_HUE_SELECTOR_H" scope="instance" type="int"/>
      <property name="PICKER_SAT_SELECTOR_H" scope="instance" type="int"/>
      <property name="PICKER_SAT_SELECTOR_W" scope="instance" type="int"/>
      <property name="value" scope="instance" type="String"/>
      <property name="_underlay" scope="instance" type="Object"/>
      <property name="_hueUnderlay" scope="instance" type="Object"/>
      <property name="_pickerPointer" scope="instance" type="Object"/>
      <property name="_huePickerPointer" scope="instance" type="Object"/>
      <property name="_huePickerPointerAlly" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_uId" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="_mover" scope="instance" type="Object"/>
      <property name="_hueMover" scope="instance" type="Object"/>
      <property name="_subs" scope="instance" type="Array"/>
      <property name="_keyListeners" scope="instance" type="Array"/>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.colorUnderlay.style">
    <properties>
      <property name="filter" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.colorUnderlay">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.rgbNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hsvNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hexNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.safePreviewNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
      <property name="backgroundColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Rval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Gval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Bval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Hval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Sval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Vval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hexCode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.previewNode.style">
    <properties>
      <property name="backgroundColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setURL" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="optional"/>
          <parameter name="urlContent" type="Object" usage="optional"/>
          <parameter name="refreshInterval" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="optional"/>
          <parameter name="refreshInterval" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="cancelRefresh" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="optional"/>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="queryOptions" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setPreparedStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="optional"/>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="queryOptions" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="renderChartWidget" scope="instance"/>
      <method name="renderGridWidget" scope="instance"/>
      <method name="getChartWidget" scope="instance"/>
      <method name="getGridWidget" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="chartType" scope="instance" type="String"/>
      <property name="reverse" scope="instance" type="Boolean"/>
      <property name="animate" scope="instance" type="Object"/>
      <property name="labelMod" scope="instance" type="Integer"/>
      <property name="legendHorizontal" scope="instance-prototype" type="Boolean"/>
      <property name="url" scope="instance" type="Object"/>
      <property name="urlContent" scope="instance" type="Object"/>
      <property name="refreshInterval" scope="instance" type="Object"/>
      <property name="refreshIntervalPending" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="preparedstore" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="queryOptions" scope="instance" type="Object"/>
      <property name="chartWidget" scope="instance" type="Object"/>
      <property name="legendWidget" scope="instance" type="Object"/>
      <property name="gridWidget" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.chartNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.legendNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.gridNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.footerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Dialog" superclass="dojox.widget.DialogSimple">
    <description>An HTML-capable Dialog widget with advanced sizing
	options, animated show/hide and other useful options.
	This Dialog is also very easy to apply custom styles to.
	It works identically to a `dijit.Dialog` with several
	additional parameters.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setup" scope="instance"/>
      <method name="layout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSize" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="_handleNav" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_position" scope="instance">
        <return-types>
          <return-type type="prevent content: from firing this anim #8914"/>
        </return-types>
      </method>
      <method name="_showContent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.DialogSimple" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="sizeToViewport" scope="instance" type="Boolean"/>
      <property name="viewportPadding" scope="instance" type="Integer"/>
      <property name="dimensions" scope="instance-prototype" type="Array"/>
      <property name="easing" scope="instance-prototype" type="Function|String"/>
      <property name="sizeDuration" scope="instance" type="Integer"/>
      <property name="sizeMethod" scope="instance" type="String"/>
      <property name="showTitle" scope="instance" type="Boolean"/>
      <property name="draggable" scope="instance" type="Boolean"/>
      <property name="modal" scope="instance" type="Boolean"/>
      <property name="_navIn" scope="instance" type="Object"/>
      <property name="_navOut" scope="instance" type="Object"/>
      <property name="_vp" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_sizing" scope="instance" type="Object"/>
      <property name="_sizingConnect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Dialog._displaysize">
    <properties>
      <property name="w" scope="instance" type="Object"/>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DialogSimple" superclass="dojox.layout.ContentPane">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._DialogBase.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._DialogBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.DocTester" superclass="dijit._Widget">
    <methods>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="runTests" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="_unescapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="doctests" scope="instance" type="Object"/>
      <property name="tests" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.numTestsNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.numTestsNokNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.numTestsOkNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DynamicTooltip" superclass="dijit.Tooltip">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setLoadingLabel" scope="instance"/>
      <method name="_setHrefAttr" scope="instance">
        <description>resets so next show loads new href</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required"/>
        </parameters>
      </method>
      <method name="loadContent" scope="instance">
        <description>1. checks if content already loaded
	2. if not, sends XHR to download new data</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Tooltip" scope="instance"/>
    </mixins>
    <properties>
      <property name="hasLoaded" scope="instance" type="Boolean"/>
      <property name="href" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="preventCache" scope="instance" type="Boolean"/>
      <property name="_connectNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FeedPortlet" superclass="dojox.widget.Portlet">
    <description>The feed is displayed as
	an unordered list of links.	When a link is hovered over
	by the mouse, it displays a summary in a tooltip.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onFeedError" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getTitle" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLink" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getContent" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setUrlAttr" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="load" scope="instance"/>
      <method name="generateResults" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Portlet" scope="instance"/>
    </mixins>
    <properties>
      <property name="local" scope="instance" type="Boolean"/>
      <property name="maxResults" scope="instance" type="Number"/>
      <property name="url" scope="instance" type="String"/>
      <property name="openNew" scope="instance" type="Boolean"/>
      <property name="showFeedTitle" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_resultList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FeedPortlet.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ExpandableFeedPortlet" superclass="dojox.widget.FeedPortlet">
    <methods>
      <method name="generateResults" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.FeedPortlet" scope="instance"/>
    </mixins>
    <properties>
      <property name="onlyOpenOne" scope="instance" type="Boolean"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_resultList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PortletFeedSettings" superclass="dojox.widget.PortletSettings">
    <description>It provides form items that the user can use to change the URL
	for a feed to load into the FeedPortlet.
	There are two forms that it can take.	&lt;br&gt;
	The first is to display a text field, with Load and Cancel buttons,
	which is prepopulated with the enclosing FeedPortlet's URL.
	If a &lt;select&gt; DOM node is used as the source node for this widget,
	it displays a list of predefined URLs that the user can select from
	to load into the enclosing FeedPortlet.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setContentAttr" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_getFeedPortletUrlAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.PortletSettings" scope="instance"/>
    </mixins>
    <properties>
      <property name="class" scope="instance" type="String"/>
      <property name="urls" scope="instance" type="Array"/>
      <property name="selectedIndex" scope="instance" type="Number"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane" superclass="dojox.widget._RollingListPane">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onItems" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._RollingListPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_messages" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.items">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.nameNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.pathNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.sizeNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FilePicker" superclass="dojox.widget.RollingList">
    <methods>
      <method name="_itemsMatch" scope="instance">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="getChildItems" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_setPathValueAttr" scope="instance">
        <parameters>
          <parameter name="path" type="string" usage="required"/>
          <parameter name="resetLastExec" type="boolean" usage="optional"/>
          <parameter name="onSet" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="_getPathValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="item" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.RollingList" scope="instance"/>
    </mixins>
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="pathSeparator" scope="instance" type="string"/>
      <property name="topDir" scope="instance" type="string"/>
      <property name="parentAttr" scope="instance" type="string"/>
      <property name="pathAttr" scope="instance" type="string"/>
      <property name="preloadItems" scope="instance" type="boolean"/>
      <property name="selectDirectories" scope="instance" type="boolean"/>
      <property name="selectFiles" scope="instance" type="boolean"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_initializePositioning" scope="instance"/>
      <method name="_overElement" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBodyOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setDormant" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already dormant?"/>
        </return-types>
      </method>
      <method name="_setActive" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already activated?"/>
        </return-types>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onScroll" scope="instance"/>
      <method name="onResized" scope="instance"/>
      <method name="_onGridMouseMove" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_paint" scope="instance"/>
      <method name="_weighAt" scope="instance">
        <parameters>
          <parameter name="cen" type="Integer" usage="required"/>
          <parameter name="i" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_setItemSize" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionElementsFrom" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionLabel" scope="instance">
        <parameters>
          <parameter name="itm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcHitGrid" scope="instance"/>
      <method name="_toEdge" scope="instance">
        <parameters>
          <parameter name="inp" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_expandSlowly" scope="instance"/>
      <method name="destroyRecursive" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="snarfChildDomOutput" scope="instance" type="Object"/>
      <property name="itemWidth" scope="instance" type="Integer"/>
      <property name="itemHeight" scope="instance" type="Integer"/>
      <property name="itemMaxWidth" scope="instance" type="Integer"/>
      <property name="itemMaxHeight" scope="instance" type="Integer"/>
      <property name="imgNode" scope="instance" type="Object"/>
      <property name="orientation" scope="instance" type="String"/>
      <property name="isFixed" scope="instance" type="Boolean"/>
      <property name="conservativeTrigger" scope="instance" type="Boolean"/>
      <property name="effectUnits" scope="instance" type="Number"/>
      <property name="itemPadding" scope="instance" type="Integer"/>
      <property name="attachEdge" scope="instance" type="String"/>
      <property name="labelEdge" scope="instance" type="String"/>
      <property name="isHorizontal" scope="instance" type="bool"/>
      <property name="selectedNode" scope="instance" type="Number"/>
      <property name="isOver" scope="instance" type="Object"/>
      <property name="hitX1" scope="instance" type="Number"/>
      <property name="hitY1" scope="instance" type="Number"/>
      <property name="hitX2" scope="instance" type="String"/>
      <property name="hitY2" scope="instance" type="String"/>
      <property name="anchorEdge" scope="instance" type="Object"/>
      <property name="proximityLeft" scope="instance" type="Number"/>
      <property name="proximityRight" scope="instance" type="Number"/>
      <property name="proximityTop" scope="instance" type="Number"/>
      <property name="proximityBottom" scope="instance" type="Number"/>
      <property name="children" scope="instance" type="Object"/>
      <property name="_onMouseMoveHandle" scope="instance" type="Object"/>
      <property name="_onScrollHandle" scope="instance" type="Object"/>
      <property name="_onMouseOutHandle" scope="instance" type="Object"/>
      <property name="_addChildHandle" scope="instance" type="Object"/>
      <property name="_onResizeHandle" scope="instance" type="Object"/>
      <property name="itemCount" scope="instance" type="Object"/>
      <property name="barWidth" scope="instance" type="Number"/>
      <property name="barHeight" scope="instance" type="Number"/>
      <property name="totalWidth" scope="instance" type="String"/>
      <property name="totalHeight" scope="instance" type="String"/>
      <property name="timerScale" scope="instance-prototype" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.EDGE">
    <properties>
      <property name="CENTER" scope="instance" type="Number"/>
      <property name="LEFT" scope="instance" type="Number"/>
      <property name="RIGHT" scope="instance" type="Number"/>
      <property name="TOP" scope="instance" type="Number"/>
      <property name="BOTTOM" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.pos">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem" superclass="dijit._Widget">
    <methods>
      <method name="_isNode" scope="instance">
        <parameters>
          <parameter name="wh" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_hasParent" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconSrc" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="id" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem.imgNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem.imgNode.style">
    <properties>
      <property name="filter" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeLite" superclass="dijit._Widget">
    <description>A Simple FisheyeList-like widget which (in the interest of
	performance) relies on well-styled content for positioning,
	and natural page layout for rendering.
	use position:absolute/relative nodes to prevent layout
	changes, and use caution when seleting properties to
	scale. Negative scaling works, but some properties
	react poorly to being set to negative values, IE being
	particularly annoying in that regard.
	quirk: uses the domNode as the target of the animation
	unless it finds a node class="fisheyeTarget" in the container
	being turned into a FisheyeLite instance</description>
    <methods>
      <method name="easeIn" scope="instance"/>
      <method name="easeOut" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="_makeAnims" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="durationIn" scope="instance" type="Number"/>
      <property name="durationOut" scope="instance" type="Integer"/>
      <property name="properties" scope="instance-prototype" type="Object"/>
      <property name="units" scope="instance" type="String"/>
      <property name="_target" scope="instance" type="Object"/>
      <property name="_runningIn" scope="instance" type="Object"/>
      <property name="_runningOut" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Iterator" superclass="dijit.Declaration">
    <methods>
      <method name="_setSrcIndex" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttrValuesObj" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDataAvailable" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Declaration" scope="instance"/>
    </mixins>
    <properties>
      <property name="constructor" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Number"/>
      <property name="fetchMax" scope="instance" type="Number"/>
      <property name="attrs" scope="instance-prototype" type="Object"/>
      <property name="defaultValue" scope="instance" type="String"/>
      <property name="widgetCtor" scope="instance-prototype" type="Object"/>
      <property name="dataValues" scope="instance" type="Array"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_srcIndex" scope="instance" type="Number"/>
      <property name="_srcParent" scope="instance" type="Object"/>
      <property name="children" scope="instance" type="Array"/>
      <property name="_classes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Iterator.query">
    <properties>
      <property name="name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_putLoader" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_show" scope="instance"/>
      <method name="_hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="loadIcon" scope="instance" type="String"/>
      <property name="loadMessage" scope="instance" type="String"/>
      <property name="hasVisuals" scope="instance" type="Boolean"/>
      <property name="attachToPointer" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="_offset" scope="instance" type="Integer"/>
      <property name="_pointerConnect" scope="instance" type="Object"/>
      <property name="_xhrStart" scope="instance" type="Object"/>
      <property name="_xhrEnd" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader.loadNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader.loadMessageNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Pager" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_a11yStyle" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderPages" scope="instance"/>
      <method name="_renderPager" scope="instance"/>
      <method name="_renderStatus" scope="instance"/>
      <method name="_pagerSkip" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pagerNext" scope="instance"/>
      <method name="_pagerPrevious" scope="instance"/>
      <method name="onScrollEnd" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="iconPrevious" scope="instance" type="String"/>
      <property name="iconNext" scope="instance" type="String"/>
      <property name="iconPage" scope="instance" type="Object"/>
      <property name="iconPageActive" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="orientation" scope="instance" type="String"/>
      <property name="statusPos" scope="instance" type="String"/>
      <property name="pagerPos" scope="instance" type="String"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="itemSpace" scope="instance" type="Integer"/>
      <property name="resizeChildren" scope="instance" type="Boolean"/>
      <property name="itemClass" scope="instance" type="String"/>
      <property name="itemsPage" scope="instance" type="Integer"/>
      <property name="items" scope="instance" type="Object"/>
      <property name="pagerContainerView" scope="instance" type="Object"/>
      <property name="pagerContainerPager" scope="instance" type="Object"/>
      <property name="_totalPages" scope="instance" type="Object"/>
      <property name="iconWidth" scope="instance" type="Number"/>
      <property name="iconHeight" scope="instance" type="Number"/>
      <property name="iconsLoaded" scope="instance" type="Number"/>
      <property name="_iconConnects" scope="instance" type="Array"/>
      <property name="_toScroll" scope="instance" type="Object"/>
      <property name="_currentPage" scope="instance" type="Number"/>
      <property name="_anim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Pager.pagerIconNext">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._PagerItem" superclass="dijit._Widget">
    <methods>
      <method name="resizeChildren" scope="instance"/>
      <method name="parseChildren" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.PlaceholderMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="menuItems" type="dijit.MenuItem[]" usage="required"/>
        </parameters>
        <return-description>true if the replace happened, false if not</return-description>
      </method>
      <method name="unReplace" scope="instance">
        <parameters>
          <parameter name="destroy" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>The array of items that were actually removed</return-description>
        <return-types>
          <return-type type="dijit.MenuItem[]"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="_replaced" scope="instance" type="bool"/>
      <property name="_replacedWith" scope="instance" type="Array"/>
      <property name="_isPlaceholder" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PlaceholderMenuItem.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Portlet" superclass="dijit.TitlePane">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_placeSettingsWidgets" scope="instance"/>
      <method name="_createIcon" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="hoverClazz" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSizeChange" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSize" scope="instance"/>
      <method name="onUpdateSize" scope="instance"/>
      <method name="_publish" scope="instance"/>
      <method name="_onTitleClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_setCss" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.TitlePane" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="resizeChildren" scope="instance" type="Boolean"/>
      <property name="closable" scope="instance" type="Boolean"/>
      <property name="_parents" scope="instance" type="Array"/>
      <property name="_size" scope="instance" type="Object"/>
      <property name="dragRestriction" scope="instance" type="Boolean"/>
      <property name="closeIcon" scope="instance" type="Object"/>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PortletSettings" superclass="dijit._Container">
    <description>This widget should be placed inside a dojox.widget.Portlet widget.
	It is used to set some preferences for that Portlet.	It is essentially
	a ContentPane, and should contain other widgets and DOM nodes that
	do the real work of setting preferences for the portlet.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setPortletAttr" scope="instance">
        <parameters>
          <parameter name="portlet" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="portletIconClass" scope="instance" type="String"/>
      <property name="portletIconHoverClass" scope="instance" type="String"/>
      <property name="portlet" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PortletDialogSettings" superclass="dojox.widget.PortletSettings">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.PortletSettings" scope="instance"/>
    </mixins>
    <properties>
      <property name="dimensions" scope="instance-prototype" type="Array"/>
      <property name="dialog" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Roller" superclass="dijit._Widget">
    <description>The Roller widget takes an unordered-list of items, and converts
	them to a single-area (the size of one list-item, however you so choose
	to style it) and loops continually, fading between items.
	In it's current state, it requires it be created from an unordered (or ordered)
	list, though can contain complex markup.
	You can manipulate the `items` array at any point during the cycle with
	standard array manipulation techniques.
	The class "dojoxRoller" is added to the UL element for styling purposes.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="makeAnims" scope="instance"/>
      <method name="_setupConnects" scope="instance"/>
      <method name="start" scope="instance"/>
      <method name="_run" scope="instance"/>
      <method name="stop" scope="instance"/>
      <method name="_setIndex" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="delay" scope="instance" type="Integer"/>
      <property name="autoStart" scope="instance" type="Boolean"/>
      <property name="itemSelector" scope="instance" type="String"/>
      <property name="durationIn" scope="instance" type="Integer"/>
      <property name="durationOut" scope="instance" type="Integer"/>
      <property name="items" scope="instance" type="Array"/>
      <property name="_idx" scope="instance" type="Integer"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
      <property name="rolling" scope="instance" type="bool"/>
      <property name="_timeout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Roller._roller">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.RollerSlide" superclass="dojox.widget.Roller">
    <methods>
      <method name="makeAnims" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Roller" scope="instance"/>
    </mixins>
    <properties>
      <property name="durationOut" scope="instance" type="Number"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollerHover">
    <description>A mixin class used to provide a way to automate a "stop on hover" behavior,
	while still allowing for ambigious subclassing for custom animations.
	Simply mix this class into a `dojox.widget.Roller` variant, and instantiate
	as you would. The hover connection is done automatically.
	The "hover" functionality is as such: Stop rotation while the mouse is over the
	instance, and resume again once leaving. Even if autoStart is disabled, the widget
	will start if a mouse enters and leaves the node in this case.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._RollingListPane" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="_setContentAndScroll" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
          <parameter name="isFakeContent" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_updateNodeWidth" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="min" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMinWidthChange" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinWidthAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="_focusKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="instance"/>
      <method name="_load" scope="instance"/>
      <method name="_doLoadItems" scope="instance">
        <parameters>
          <parameter name="items" type="item[]" usage="required"/>
          <parameter name="callback" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance"/>
      <method name="_hasItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required"/>
          <parameter name="newValue" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNewItem" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchStart" scope="instance"/>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadStart" scope="instance"/>
      <method name="onLoadError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="string"/>
      <property name="parentPane" scope="instance" type="dojox.widget._RollingListPane"/>
      <property name="store" scope="instance" type="store"/>
      <property name="items" scope="instance" type="item[]"/>
      <property name="query" scope="instance" type="object"/>
      <property name="queryOptions" scope="instance" type="object"/>
      <property name="_focusByNode" scope="instance" type="Object"/>
      <property name="minWidth" scope="instance" type="integer"/>
      <property name="isLoaded" scope="instance" type="bool"/>
      <property name="onLoadDeferred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListPane.parentWidget">
    <properties>
      <property name="_focusedPane" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListGroupPane" superclass="dojox.widget._RollingListPane">
    <methods>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_onMinWidthChange" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="instance"/>
      <method name="_checkScrollConnection" scope="instance">
        <parameters>
          <parameter name="doLoad" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenu" scope="instance"/>
      <method name="_onScrollPane" scope="instance"/>
      <method name="_loadVisibleItems" scope="instance"/>
      <method name="_getSelected" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
      <method name="_setSelected" scope="instance">
        <parameters>
          <parameter name="item" type="dijit.MenuItem" usage="optional"/>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._RollingListPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="string"/>
      <property name="_menu" scope="instance" type="dijit.Menu"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_scrollConn" scope="instance" type="Object"/>
      <property name="_focusByNode" scope="instance" type="Object"/>
      <property name="_pendingFocus" scope="instance" type="Object"/>
      <property name="_visibleLoadPending" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListGroupPane.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.RollingList" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setShowButtonsAttr" scope="instance">
        <parameters>
          <parameter name="doShow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_itemsMatch" scope="instance">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_removeAfter" scope="instance">
        <parameters>
          <parameter name="idx" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_setMinPaneWidthAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="childWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_onChange" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="dojo.data.api.Read" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_resetValue" scope="instance"/>
      <method name="_onCancel" scope="instance"/>
      <method name="_onExecute" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateChildClasses" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="getChildItems" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="onExecute" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="className" scope="instance" type="string"/>
      <property name="store" scope="instance" type="store"/>
      <property name="query" scope="instance" type="object"/>
      <property name="queryOptions" scope="instance" type="object"/>
      <property name="childrenAttrs" scope="instance" type="String[]"/>
      <property name="parentAttr" scope="instance" type="string"/>
      <property name="value" scope="instance" type="item"/>
      <property name="executeOnDblClick" scope="instance" type="boolean"/>
      <property name="preloadItems" scope="instance" type="boolean"/>
      <property name="showButtons" scope="instance" type="boolean"/>
      <property name="okButtonLabel" scope="instance" type="string"/>
      <property name="cancelButtonLabel" scope="instance" type="string"/>
      <property name="minPaneWidth" scope="instance" type="integer"/>
      <property name="_declaredClasses" scope="instance" type="Object"/>
      <property name="_scrollingTimeout" scope="instance" type="Object"/>
      <property name="buttonsNode" scope="instance" type="Object"/>
      <property name="_focusedPane" scope="instance" type="Object"/>
      <property name="_setInProgress" scope="instance" type="Object"/>
      <property name="_visibleItem" scope="instance" type="Object"/>
      <property name="_isIdentity" scope="instance" type="Object"/>
      <property name="_lastExecutedValue" scope="instance" type="Object"/>
      <property name="_savedFocus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.RollingList.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Rotator">
    <description>A small, fast, extensible, awesome rotator that cycles, with transitions,
	through panes (child nodes) displaying only one at a time and ties into
	controllers used to change state.
	The Rotator does not rely on dijit.  It is designed to be as lightweight
	as possible.  Controllers and transitions have been externalized
	so builds can be as optimized with only the components you want to use.
	For best results, each rotator pane should be the same height and width as
	the Rotator container node and consider setting overflow to hidden.
	While the Rotator will accept any DOM node for a rotator pane, a block
	element or element with display:block is recommended.
	Note: When the Rotator begins, it does not transition the first pane.
	subscribed topics:
	[id]/rotator/control - Controls the Rotator
	Parameters:
	/*string*/ action        - The name of a method of the Rotator to run
	/*anything?*/ args       - One or more arguments to pass to the action
	published topics:
	[id]/rotator/update - Notifies controllers that a pane or state has changed.
	Parameters:
	/*string*/ type          - the type of notification
	/*dojox.widget.Rotator*/ rotator
	- the rotator instance
	/*object?*/ params		 - params
	declarative dojo/method events (per pane):
	onBeforeIn  - Fired before the transition in starts.
	onAfterIn   - Fired after the transition in ends.
	onBeforeOut - Fired before the transition out starts.
	onAfterOut  - Fired after the transition out ends.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="prev" scope="instance"/>
      <method name="go" scope="instance">
        <parameters>
          <parameter name="p" type="int|string" usage="optional"/>
        </parameters>
      </method>
      <method name="onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
          <parameter name="params" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_resetWaitForEvent" scope="instance"/>
      <method name="control" scope="instance">
        <parameters>
          <parameter name="action" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="width" type="int" usage="required"/>
          <parameter name="height" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="onManualChange" scope="instance"/>
    </methods>
    <properties>
      <property name="transition" scope="instance" type="string"/>
      <property name="transitionParams" scope="instance" type="string"/>
      <property name="panes" scope="instance" type="array"/>
      <property name="wfe" scope="instance" type="Object"/>
      <property name="_domNodeContentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList" superclass="dijit.layout._LayoutWidget">
    <methods>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="onSort" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_unset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValues" scope="instance"/>
      <method name="_sorter" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onChanged" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="heading" scope="instance" type="String"/>
      <property name="descending" scope="instance" type="Boolean"/>
      <property name="selected" scope="instance" type="Array"/>
      <property name="sortable" scope="instance" type="Boolean"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="key" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList.bodyWrapper.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList.focusNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Standby" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="isVisible" scope="instance">
        <return-description>boolean indicating if the widget is in 'show' state or not.</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onShow" scope="instance"/>
      <method name="onHide" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="_size" scope="instance"/>
      <method name="_cloneStyles" scope="instance">
        <parameters>
          <parameter name="list" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_fadeIn" scope="instance"/>
      <method name="_fadeOut" scope="instance"/>
      <method name="_ignore" scope="instance">
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollerWidths" scope="instance">
        <return-description>Object of form: {v: Number, h: Number} where v is vertical scrollbar width
	and h is horizontal scrollbar width.</return-description>
      </method>
      <method name="_setTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setColorAttr" scope="instance">
        <parameters>
          <parameter name="c" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setImageTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setImageAttr" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setCenterIndicatorAttr" scope="instance">
        <parameters>
          <parameter name="indicator" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_disableOverflow" scope="instance"/>
      <method name="_enableOverflow" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_underlayNode" scope="instance" type="DOMNode"/>
      <property name="_imageNode" scope="instance" type="DOMNode"/>
      <property name="_centerNode" scope="instance" type="DOMNode"/>
      <property name="image" scope="instance" type="String"/>
      <property name="imageText" scope="instance" type="String"/>
      <property name="text" scope="instance" type="String"/>
      <property name="centerIndicator" scope="instance" type="String"/>
      <property name="_displayed" scope="instance" type="Boolean"/>
      <property name="_resizeCheck" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="String"/>
      <property name="duration" scope="instance" type="integer"/>
      <property name="_started" scope="instance" type="Boolean"/>
      <property name="_parent" scope="instance" type="DOMNode"/>
      <property name="zIndex" scope="instance" type="String"/>
      <property name="_ieFixNode" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
      <property name="_overflowDisabled" scope="instance" type="Object"/>
      <property name="_oldOverflow" scope="instance" type="String"/>
      <property name="_oldBodyParentOverflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Standby._textNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Standby.target">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.TitleGroup" superclass="dijit._Widget">
    <description>A container which controls a series of `dijit.TitlePane`s,
	allowing one to be visible and hiding siblings. Behaves similarly
	to a `dijit.layout.AccordionContainer` in that the children
	are all stacked, though merges the TitlePane behavior of
	variable height</description>
    <methods>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit.TitlePane" usage="required"/>
          <parameter name="position" type="String|Int" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dijit.TitlePane"/>
        </return-types>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.TitlePane"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="class" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_handleMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_capitalize" scope="instance">
        <parameters>
          <parameter name="w" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <parameters>
          <parameter name="message" type="String|Function" usage="required"/>
          <parameter name="messageType" type="String" usage="required"/>
          <parameter name="duration" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cancelHideTimer" scope="instance"/>
      <method name="_setHideTimer" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeClip" scope="instance"/>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="messageTopic" scope="instance" type="String"/>
      <property name="defaultType" scope="instance" type="String"/>
      <property name="positionDirection" scope="instance" type="String"/>
      <property name="positionDirectionTypes" scope="instance" type="Array"/>
      <property name="duration" scope="instance" type="Integer"/>
      <property name="slideDuration" scope="instance" type="Integer"/>
      <property name="separator" scope="instance" type="String"/>
      <property name="slideAnim" scope="instance" type="Object"/>
      <property name="_hideTimer" scope="instance" type="Object"/>
      <property name="_stickyMessage" scope="instance" type="Object"/>
      <property name="_scrollConnected" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.messageTypes">
    <properties>
      <property name="MESSAGE" scope="instance" type="String"/>
      <property name="WARNING" scope="instance" type="String"/>
      <property name="ERROR" scope="instance" type="String"/>
      <property name="FATAL" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.containerNode"/>
  <class type="dojox.widget.Toaster.containerNode.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.contentNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.clipNode">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.clipNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="clip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.bgIframe">
    <properties>
      <property name="iframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.bgIframe.iframe.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.UpgradeBar" superclass="dijit._Widget">
    <description>You can insert custom validations to trigger the UpgradeBar
	to display. An evaluation of 'true' shows the bar (as this
	version *is* less than it should be). Multiple validations
	may be checked, although only the first in the list will be
	displayed.
	Markup and programmatic are supported. Markup is a little
	cleaner, since a majority of the parameters are the HTML
	snippets to be displayed. In markup, the validate code should
	be an expression that will evaluate to true or false. This
	expression is wrapped in a try/catch, so if it blows up, it
	is assumed to be true and trigger the bar.
	In programmtic, a function should be used that returns true
	or false. You would need to use your own try/catch in that.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkNotifications" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="notify" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="_onDontRemindClick" scope="instance"/>
      <method name="_onCloseEnter" scope="instance"/>
      <method name="_onCloseLeave" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="notifications" scope="instance" type="Array"/>
      <property name="buttonCancel" scope="instance" type="String"/>
      <property name="noRemindButton" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_bodyMarginTop" scope="instance" type="Object"/>
      <property name="_size" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard" superclass="dijit.layout.StackContainer">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="_checkButtons" scope="instance"/>
      <method name="_setButtonClass" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forward" scope="instance"/>
      <method name="done" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="nextButtonLabel" scope="instance" type="String"/>
      <property name="previousButtonLabel" scope="instance" type="String"/>
      <property name="cancelButtonLabel" scope="instance" type="String"/>
      <property name="doneButtonLabel" scope="instance" type="String"/>
      <property name="cancelFunction" scope="instance" type="Function|String"/>
      <property name="hideDisabled" scope="instance" type="Boolean"/>
      <property name="_subscription" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.cancelButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.selectedChildWidget">
    <properties>
      <property name="isLastChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.doneButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.nextButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.WizardPane" superclass="dijit.layout.ContentPane">
    <description>An extended ContentPane with additional hooks for passing named
	functions to prevent the pane from going either forward or
	backwards.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_onShow" scope="instance"/>
      <method name="_checkPass" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="done" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="canGoBack" scope="instance" type="Boolean"/>
      <property name="passFunction" scope="instance" type="String"/>
      <property name="doneFunction" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.AnalogArcIndicator" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <methods>
      <method name="_createArc" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge.AnalogLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="currentValue" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="Object"/>
      <property name="shapes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.AnalogArcIndicator._gauge">
    <properties>
      <property name="max" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.AnalogArrowIndicator" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge.AnalogLineIndicator" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.gauge.AnalogNeedleIndicator" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge.AnalogLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.BarIndicator" superclass="dojox.widget.gauge.BarLineIndicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
      <method name="_createShapes" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge.BarLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="currentValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.BarIndicator._gauge">
    <properties>
      <property name="max" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Gauge" superclass="dijit._Widget">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format
	usage:
	this widget is not to be used alone. it is meant to be subclassed, such as
	dojox.widget.BarGauge or dojox.widget.AnalogGauge</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_setTicks" scope="instance">
        <parameters>
          <parameter name="oldTicks" type="Object" usage="required"/>
          <parameter name="newTicks" type="Object" usage="required"/>
          <parameter name="label" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setMinorTicks" scope="instance">
        <parameters>
          <parameter name="ticks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMajorTicks" scope="instance">
        <parameters>
          <parameter name="ticks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="createSurface" scope="instance"/>
      <method name="setBackground" scope="instance">
        <description>Sets the background using the given object.  Must be the same 'type' of object
	as the original background argument.</description>
        <parameters>
          <parameter name="background" type="An" usage="required"/>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <description>Creates a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRanges" scope="instance">
        <description>Creates a range (colored area on the background of the gauge)
	based on the given arguments.
	range:
	A range is either a dojox.widget.gauge.Range object, or a object
	with similar parameters (low, high, hover, etc.).</description>
        <parameters>
          <parameter name="ranges" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="addIndicator" scope="instance">
        <description>This method adds an indicator, such as a tick mark or needle,
	to the bar graph.</description>
        <parameters>
          <parameter name="indicator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeIndicator" scope="instance">
        <parameters>
          <parameter name="indicator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveIndicatorToFront" scope="instance">
        <parameters>
          <parameter name="indicator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="drawText" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required"/>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="y" type="Number" usage="required"/>
          <parameter name="align" type="String" usage="optional"/>
          <parameter name="vAlign" type="String" usage="optional"/>
          <parameter name="color" type="String" usage="optional"/>
          <parameter name="font" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="removeText" scope="instance">
        <parameters>
          <parameter name="t" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="updateTooltip" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseOver" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseOut" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseUp" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="The"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="background" scope="instance" type="Object"/>
      <property name="min" scope="instance" type="Number"/>
      <property name="max" scope="instance" type="Number"/>
      <property name="image" scope="instance" type="String"/>
      <property name="useRangeStyles" scope="instance" type="Number"/>
      <property name="useTooltip" scope="instance" type="Boolean"/>
      <property name="majorTicks" scope="instance" type="Object"/>
      <property name="minorTicks" scope="instance" type="Object"/>
      <property name="_defaultIndicator" scope="instance" type="Objection"/>
      <property name="defaultColors" scope="instance" type="Array"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="hideValues" scope="instance" type="Boolean"/>
      <property name="gaugeContent" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_rangeData" scope="instance" type="Array"/>
      <property name="_drag" scope="instance" type="Object"/>
      <property name="_img" scope="instance" type="Object"/>
      <property name="_overOverlay" scope="instance" type="bool"/>
      <property name="_lastHover" scope="instance" type="String"/>
      <property name="ranges" scope="instance" type="Object"/>
      <property name="indicators" scope="instance" type="Object"/>
      <property name="_background" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Gauge._backgroundDefault">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Gauge.gaugeContent.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Gauge._indicatorData">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.Range" superclass="dijit._Widget">
    <description>a range widget, which has given properties.  drawn by a _Gauge.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;div	dojoType="dojox.widget.gauge.Range"
	low=5
	high=10
	hover="5 - 10"
	&gt;&lt;/div&gt;
	&lt;div	dojoType="dojox.widget.gauge.Range"
	low=10
	high=20
	hover="10 - 20"
	&gt;&lt;/div&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="low" scope="instance" type="Number"/>
      <property name="high" scope="instance" type="Numbe"/>
      <property name="hover" scope="instance" type="String"/>
      <property name="color" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Indicator" superclass="dijit._Widget">
    <description>an indicator widget, which has given properties.  drawn by a gauge.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;div 	dojoType="dojox.widget.gauge.Indicator"
	value=17
	type="arrow"
	length=135
	width=3
	hover="Value: 17"
	onDragMove="handleDragMove"&gt;
	&lt;/div&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="onDragMove" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_update" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="value" scope="instance" type="Number"/>
      <property name="type" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="length" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="hover" scope="instance" type="String"/>
      <property name="front" scope="instance" type="boolean"/>
      <property name="easing" scope="instance" type="String|Object"/>
      <property name="duration" scope="instance" type="Number"/>
      <property name="hideValue" scope="instance" type="bool"/>
      <property name="noChange" scope="instance" type="Boolean"/>
      <property name="_gauge" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Indicator.font">
    <properties>
      <property name="family" scope="instance" type="String"/>
      <property name="size" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Indicator.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator">
    <methods>
      <method name="fade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="crossFade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pan" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continuous gets a linear easing by default"/>
        </return-types>
      </method>
      <method name="panDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continuous gets a linear easing by default"/>
        </return-types>
      </method>
      <method name="panFadeDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="Fade" scope="instance" type="Object"/>
      <property name="Pan" scope="instance" type="Object"/>
      <property name="PanFade" scope="instance" type="Object"/>
      <property name="Slide" scope="instance" type="Object"/>
      <property name="Wipe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.Controller">
    <description>Displays a series of controls that send actions to a Rotator or
	AutoRotator.  The Controller supports the following controls:
	* Next pane
	* Previous pane
	* Play/Pause toggler
	* Numbered tabs
	* Titled tabs
	* Information
	You may specify any of these controls in any order.  You may also
	have multiple Controllers tied to a single Rotator instance.
	The Controller's DOM node may also be styled for positioning or
	other styled preferences.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_togglePlay" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_buildInfo" scope="instance">
        <parameters>
          <parameter name="r" type="dojox.widget.Rotator" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="commands" scope="instance" type="string"/>
      <property name="_domNode" scope="instance" type="Object"/>
      <property name="_con" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.Controller.rotator">
    <properties>
      <property name="playing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.Controller._info">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.ThumbnailController">
    <description>The ThumbnailController will look at each of the rotator's panes and
	only if the node is an &lt;img&gt; tag, then it will create an thumbnail of
	the pane's image using the &lt;img&gt; tag's "thumbsrc" or "src" attribute.
	The size of the thumbnails and the style of the selected thumbnail is
	controlled using CSS.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rotator" scope="instance-prototype" type="dojox.widget.Rotator"/>
      <property name="_domNode" scope="instance" type="Object"/>
      <property name="_con" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire">
    <methods>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="wireClass" type="Function||String" usage="required"/>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getClass" scope="instance">
        <description>The class is loaded by dojo.require() and returned
	by dojo.getObject().</description>
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-description>A class</return-description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <description>If 'args' specifies 'wireClass', it is used as a class or full
	qualified class name to create a Wire with 'args' as arguments.
	Otherwise, a Wire class is determined by other proeprties of 'args'
	checking if 'args' specifies a key property for a Wire class.
	If no key property found, the default Wire class is used.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-description>A Wire</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="isWire" scope="instance">
        <description>If the specified object is a Wire, true is returned.
	Otherwise, false is returned.</description>
        <parameters>
          <parameter name="wire" type="Object" usage="required"/>
        </parameters>
        <return-description>True if the object is a Wire, otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="transfer" scope="instance">
        <description>If 'source' and/or 'target' are not Wires, Wires are created with
	them as arguments.
	A value is got through the source Wire and set through the target
	Wire.
	'defaultObject' is passed to Wires as a default root object.
	If 'defaultTargetObject' is specified, it is passed to the target
	Wire as a default root object, instead of 'defaultObject'.</description>
        <parameters>
          <parameter name="source" type="Wire||Object" usage="required"/>
          <parameter name="target" type="Wire||Object" usage="required"/>
          <parameter name="defaultObject" type="Object" usage="optional"/>
          <parameter name="defaultTargetObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>If 'trigger' specifies 'topic', the topic is subscribed to transer
	a value on the topic.
	Otherwise, the event specified to 'event' of 'trigger' is listened
	to transfer a value.
	On the specified event or topic, transfer() is called with
	'source', 'target' and the arguments of the event or topic (as
	default root objects).</description>
        <parameters>
          <parameter name="trigger" type="Object" usage="required"/>
          <parameter name="source" type="Wire||Object" usage="required"/>
          <parameter name="target" type="Wire||Object" usage="required"/>
        </parameters>
        <return-description>A connection handle for disconnect()</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>If 'handle' has 'topic', the topic is unsubscribed.
	Otherwise, the listener to an event is removed.</description>
        <parameters>
          <parameter name="connection" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_defaultWireClass" scope="instance" type="String"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.CompositeWire" superclass="dojox.wire.Wire">
    <description>This class has multiple child Wires for object properties or array
	elements.
	When an object with Wires is specified to 'children' property, they
	are used to get or set an object with property values.
	When an array of Wiares is specified to 'children' property, they
	are used to get or set an array with element values.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties or array elements specified in 'children'
	property are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method calls getValue() method of the child Wires with
	'object' argument and returns an object with the values as
	properties or an arary of the values as elements.</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
        </parameters>
        <return-description>An object or array with values</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
          <parameter name="value" type="Object||Array" usage="required"/>
        </parameters>
        <return-description>'object'</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_initializeChildren" scope="instance">
        <description>If object properties or array elements specified in 'children'
	argument are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="children" type="Object||Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.DataWire" superclass="dojox.wire.Wire">
    <description>This class accesses item attributes of data stores with a dotted
	notation of attribute names specified to 'attribute' property,
	using data APIs of a data store specified to 'dataStore' property.
	The root object for this class must be an item of the data store.
	Intermediate attribute names in the dotted notation specify
	attributes for child items, which are used for repeated calls to
	data APIs until reached to a descendant attribute.
	Attribute names may have an array index, such as "a[0]", to
	identify an array element of the attribute value.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If 'dataStore' property is not specified, but 'parent' property
	is specified, 'dataStore' property is copied from the parent.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method uses a root item passed in 'object' argument and
	'attribute' property to call getValue() method of
	'dataStore'.
	If an attribute name have an array suffix ("[]"), getValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is returned, instead of the array itself.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <description>This method uses a root item passed in 'object' argument and
	'attribute' property to identify an item.
	Then, setValue() method of 'dataStore' is called with a leaf
	attribute name and 'value' argument.
	If an attribute name have an array suffix ("[]"), setValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is set to 'value', instead of the array itself.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>'object', or 'undefined' for invalid attribute</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getAttributeValue" scope="instance">
        <description>This method uses an item passed in 'item' argument and
	'attribute' argument to call getValue() method of 'dataStore'.
	If an attribute name have an array suffix ("[]"), getValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is returned, instead of the array itself.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setAttributeValue" scope="instance">
        <description>This method uses an item passed in 'item' argument and
	'attribute' argument to call setValue() method of 'dataStore'
	with 'value' argument.
	If an attribute name have an array suffix ("[]"), setValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is set to 'value', instead of the array itself.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
      <property name="dataStore" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.TableAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for object properties or array
	elements of a table row.
	The root object for this class must be an array.
	When an object with Wires is specified to 'columns' property, they
	are used to get a row object with property values.
	When an array of Wires is specified to 'columns' property, they
	are used to get a row array with element values.
	The row values are returned in an array.
	This class only supports getValue(), but not setValue().</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties or array elements specified in 'columns'
	property are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method iterates over an array specified to 'object'
	argument and calls getValue() method of the child Wires with
	each element of the array to get a row object or array.
	Finally, an array with the row objects or arrays are retuned.</description>
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
        </parameters>
        <return-description>An array of table row value</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_getRow" scope="instance">
        <description>This method calls getValue() method of the child Wires to
	create a row object or array.</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
        </parameters>
        <return-description>An array or object for a table row</return-description>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.TextAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for text segment values.
	Wires in 'segments' property are used to get text segments and
	values are concatenated with an optional delimiter string specified
	to 'delimiter' property.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If array elements specified in 'segments' are not Wires, Wires
	are created from them as arguments, with 'parent' property set
	to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method calls getValue() method of the child Wires wuth
	'object' argument and concatenate the values with 'delimiter'
	property to return.
	arg:
	A root object</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
        </parameters>
        <return-description>A concatinated text</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_addSegment" scope="instance">
        <description>This method add a text segment specified to 'segment' argument
	to a base text specified to 'text', with 'delimiter' property.</description>
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="segment" type="String" usage="required"/>
        </parameters>
        <return-description>A concatinated text</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
      <property name="delimiter" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.TreeAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for tree nodes, their title and
	child nodes.
	The root object for this class must be an array.
	'node' Wires in 'nodes' property is used to identify an object
	representing a node.
	'title' Wires in 'nodes' property is used to get the title string
	of a node.
	'children' Wires in 'nodes' property is used to iterate over child
	node objects.
	The node values are returned in an array as follows:
	[
	{title: title1,
	children: [
	{title: title2,
	child: ...},
	{title: title3,
	child: ...},
	...
	]},
	...
	]
	This class only supports getValue(), but not setValue().</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties ('node', 'title' and 'children') of array
	elements specified in 'nodes' property are not Wires, Wires are
	created from them as arguments, with 'parent' property set to
	this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method iterates over an array specified to 'object'
	argument and calls getValue() method of 'node' Wires with each
	element of the array to get object(s) that represetns nodes.
	(If 'node' Wires are omitted, the array element is used for
	further processing.)
	Then, getValue() method of 'title' Wires are called to get
	title strings for nodes.
	(If 'title' Wires are omitted, the objects representing nodes
	are used as title strings.)
	And if an array of objects with 'node' and 'title' Wires is
	specified to 'children', it is used to gather child nodes and
	their title strings in the same way recursively.
	Finally, an array of the top-level node objects are retuned.</description>
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
        </parameters>
        <return-description>An array of tree node values</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_initializeChildren" scope="instance">
        <description>If 'node' or 'title' properties of array elements specified in
	'children' argument are not Wires, Wires are created from them
	as arguments, with 'parent' property set to this Wire instance.
	If an array element has 'children' property, this method is
	called recursively with it.</description>
        <parameters>
          <parameter name="children" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getNodes" scope="instance">
        <description>This method calls getValue() method of 'node' Wires with
	'object' argument to get object(s) that represents nodes.
	(If 'node' Wires are omitted, 'object' is used for further
	processing.)
	Then, getValue() method of 'title' Wires are called to get
	title strings for nodes.
	(If 'title' Wires are omitted, the objects representing nodes
	are used as title strings.)
	And if an array of objects with 'node' and 'title' Wires is
	specified to 'children', it is used to gather child nodes and
	their title strings in the same way recursively.
	Finally, an array of node objects are returned.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.Wire">
    <description>This class accesses a property of an object with a dotted notation
	specified to 'property' property, such as "a.b.c", which identifies
	a descendant property, "object.a.b.c".
	Property names in the dotted notation may have an array index, such
	as "a[0]", to identify an array element, literally, "object.a[0]".
	When a notation start with an array index, such as "[0].a", it
	specifies an array element of the root object (array),
	"object[0].a".
	This class also serves as a base class for other Wire classes,
	preparing a root object and converting a return value, so that
	sub-classes just can implement _getValue() and _setValue() called
	from getValue() and setValue() implemented by this calss.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If 'converter' property is specified and is a string for
	a converter class, an instanceof the converter class is
	created.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>This method first determins a root object as follows:
	1. If 'object' property specified,
	1.1 If 'object' is a Wire, its getValue() method is called to
	obtain a root object.
	1.2 Otherwise, use 'object' as a root object.
	2. Otherwise, use 'defaultObject' argument.
	3. If 'property' is specified, it is used to get a property
	value.
	Then, if a sub-class implements _getValue() method, it is
	called with the root object to get the return value.
	Otherwise, the root object (typically, a property valye) is
	used for the return value.
	Finally, if 'type' property is specified, the return value is
	converted to the specified primitive type ("string", "number",
	"boolean" and "array").
	If 'converter' property is specified, its convert() method is
	called to convert the value.</description>
        <parameters>
          <parameter name="defaultObject" type="Object||Array" usage="required"/>
        </parameters>
        <return-description>A value found</return-description>
        <return-types>
          <return-type type="anything (null, undefined, etc)"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <description>This method first determins a root object as follows:
	1. If 'object' property specified,
	1.1 If 'object' is a Wire, its getValue() method is called to
	obtain a root object.
	1.2 Otherwise, use 'object' as a root object.
	2. Otherwise, use 'defaultObject' argument.
	3. If 'property' is specified, it is used to get a property
	value.
	Then, if a sub-class implements _setValue() method, it is
	called with the root object and 'value' argument to set
	the value.
	Otherwise, 'value' is set to a property specified with
	'property' property.
	If the root object is undefined and 'object' property is a Wire
	and a new object is created and returned by _setValue() it is
	set through 'object' (setValue() method).</description>
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="defaultObject" type="Object||Array" usage="required"/>
        </parameters>
      </method>
      <method name="_getPropertyValue" scope="instance">
        <description>A value for 'property' of 'object' is returned.
	If 'property' ends with an array index, it is used to indentify
	an element of an array property.
	If 'object' implements getPropertyValue(), it is called with
	'property' to obtain the property value.
	If 'object' implements a getter for the property, it is called
	to obtain the property value.</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setPropertyValue" scope="instance">
        <description>'value' is set to 'property' of 'object'.
	If 'property' ends with an array index, it is used to indentify
	an element of an array property to set the value.
	If 'object' implements setPropertyValue(), it is called with
	'property' and 'value' to set the property value.
	If 'object' implements a setter for the property, it is called
	with 'value' to set the property value.</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_useGet" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_useSet" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required"/>
        </parameters>
      </method>
      <method name="_useAttr" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
      <property name="converter" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.XmlWire" superclass="dojox.wire.Wire">
    <description>This class accesses XML nodes or value with a simplified XPath
	specified to 'path' property.
	The root object for this class must be an DOM document or element
	node.
	"@name" accesses to an attribute value of an element and "text()"
	accesses to a text value of an element.
	The hierarchy of the elements from the root node can be specified
	with slash-separated list, such as "a/b/@c", which specifies
	the value of an attribute named "c" of an element named "b" as
	a child of another element named "a" of a child of the root node.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>'args' is just mixed in with no further processing.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method first uses a root node passed in 'object' argument
	and 'path' property to identify an attribute, a text or
	elements.
	If 'path' starts with a slash (absolute), the first path
	segment is ignored assuming it point to the root node.
	(That is, "/a/b/@c" and "b/@c" against a root node access
	the same attribute value, assuming the root node is an element
	with a tag name, "a".)</description>
        <parameters>
          <parameter name="object" type="Node" usage="required"/>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <description>This method first uses a root node passed in 'object' argument
	and 'path' property to identify an attribute, a text or
	elements.
	If an intermediate element does not exist, it creates
	an element of the tag name in the 'path' segment as a child
	node of the current node.
	Finally, 'value' argument is set to an attribute or a text
	(a child node) of the leaf element.</description>
        <parameters>
          <parameter name="object" type="Node" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getNodeValue" scope="instance">
        <description>If 'exp' starts with '@', an attribute value of the specified
	attribute is returned.
	If 'exp' is "text()", a child text value is returned.
	Otherwise, an array of child elements, the tag name of which
	match 'exp', is returned.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="exp" type="String" usage="required"/>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setNodeValue" scope="instance">
        <description>If 'exp' starts with '@', 'value' is set to the specified
	attribute.
	If 'exp' is "text()", 'value' is set to a child text.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="exp" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildNode" scope="instance">
        <description>A child element of the tag name specified with 'name' is
	returned.
	If 'name' ends with an array index, it is used to pick up
	the corresponding element from multiple child elements.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-description>A child node</return-description>
        <return-types>
          <return-type type="Node"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="instance">
        <description>If 'node' is specified, a DOM document of the node is returned.
	Otherwise, a DOM document is created.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire._wireClasses">
    <properties>
      <property name="attribute" scope="instance" type="String"/>
      <property name="path" scope="instance" type="String"/>
      <property name="children" scope="instance" type="String"/>
      <property name="columns" scope="instance" type="String"/>
      <property name="nodes" scope="instance" type="String"/>
      <property name="segments" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml">
    <methods>
      <method name="_getValue" scope="instance">
        <description>This method obtains an object by an ID of a widget or an DOM
	element.
	If 'source' specifies a dotted notation to its property, a Wire is
	used to get the object property.
	If 'source' starts with "arguments", 'args' is used as a root
	object for the Wire.</description>
        <parameters>
          <parameter name="source" type="String" usage="required"/>
          <parameter name="args" type="Array" usage="required"/>
        </parameters>
        <return-description>A value</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <description>This method stores a value by an ID of a widget or an DOM
	element with a dotted notation to its property, using a Wire.</description>
        <parameters>
          <parameter name="target" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="util" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Action" superclass="dijit._Widget">
    <description>This widget represents a controller task to be run when an event
	(a function) or a topic is issued.
	Sub-classes must implement _run() method to implement their tasks.
	'trigger' specifies an event scope, an ID of a widget or an DOM
	element, or its property with the optional dotted notation.
	If this widget has child ActionFilter widgets, their filter()
	methods are called with the arguments to the event or the topic.
	If one of filter() methods returns false, run() won't be invoked.
	This widget also can serve as a composite task to run child
	Actions on an event or a topic specified to this widget.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>See _connect().</description>
      </method>
      <method name="_connect" scope="instance">
        <description>If 'triggerEvent' and 'trigger' are specified, connect() is
	used to set up run() to be called on the event.
	If 'triggerTopic' is specified, subscribe() is used to set up
	run() to be called on the topic.</description>
      </method>
      <method name="_disconnect" scope="instance">
        <description>If 'triggerEvent' and 'trigger' are specified, disconnect() is
	used to set up run() not to be called on the event.
	If 'triggerTopic' is specified, unsubscribe() is used to set up
	run() not to be called on the topic.</description>
      </method>
      <method name="run" scope="instance">
        <description>This method calls filter() method of child ActionFilter
	widgets.
	If one of them returns false, this method returns.
	Otherwise, _run() method is called.</description>
      </method>
      <method name="_run" scope="instance">
        <description>If this widget has child Action widgets, their run() methods
	are called.</description>
      </method>
      <method name="uninitialize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="trigger" scope="instance" type="An"/>
      <property name="triggerEvent" scope="instance" type="An"/>
      <property name="triggerTopic" scope="instance" type="A"/>
      <property name="_triggerHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.ActionFilter" superclass="dijit._Widget">
    <description>This base class checks a required property specified with
	'required' attribute.
	If 'message' is specified, the message is set to a property
	specified with 'error'.
	Subclasses may implement their own filter() method.</description>
    <methods>
      <method name="filter" scope="instance">
        <description>If a value is undefined for a property, specified with
	'required', this method returns false.
	If the value for a property is defined, but there isn't a requiredValue for it
	then any non-false value will cause the method to return true.
	if requiredValue is set, then filter compares that value with the value from
	the required property and returns true if and only if they match.
	The type option just allows for a way to convert the required property values
	into a proper form for comparison (boolean, number, etc).
	If 'message' is specified, it is set to a proeprty specified
	with 'error' or shown with alert().
	If 'required' starts with "arguments", a property of
	the method arguments are checked.</description>
        <return-description>True if a required property is specified (and if requiredValue is specified,
	that they match), otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="A"/>
      <property name="requiredValue" scope="instance" type="Optional."/>
      <property name="type" scope="instance" type="Optional."/>
      <property name="message" scope="instance" type="An"/>
      <property name="error" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Data" superclass="dijit._Widget">
    <description>This widget represents an object with '_properties' property.
	If child 'DataProperty' widgets exist, they are used to initialize
	propertiy values of '_properties' object.</description>
    <methods>
      <method name="startup" scope="instance">
        <description>See _initializeProperties().</description>
      </method>
      <method name="_initializeProperties" scope="instance">
        <description>If this widget has child DataProperty widgets, their getValue()
	methods are called and set the return value to a property
	specified by 'name' attribute of the child widgets.</description>
        <parameters>
          <parameter name="reset" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getPropertyValue" scope="instance">
        <description>This method returns the value of a property, specified with
	'property' argument, in '_properties' object.</description>
        <parameters>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="instance">
        <description>This method stores 'value' as a property, specified with
	'property' argument, in '_properties' object.</description>
        <parameters>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataProperty" superclass="dijit._Widget">
    <description>Attributes of this widget are used to add a property to the parent
	Data widget.
	'type' attribute specifies one of "string", "number", "boolean",
	"array", "object" and "element" (DOM Element)
	(default to "string").
	If 'type' is "array" or "object", child DataProperty widgets are
	used to initialize the array elements or the object properties.</description>
    <methods>
      <method name="_getValueAttr" scope="instance"/>
      <method name="getValue" scope="instance">
        <description>If 'type' is specified, 'value' attribute is converted to
	the specified type and returned.
	Otherwise, 'value' attribute is returned as is.</description>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="A"/>
      <property name="type" scope="instance" type="A"/>
      <property name="value" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataStore" superclass="dijit._Widget">
    <description>This widget represents a data store of 'storeClass' attribute.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>See _createStore().</description>
      </method>
      <method name="_createStore" scope="instance">
        <return-description>A data store</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <description>See dojo.data.api.Read.getFeatures().</description>
        <return-description>A features object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="fetch" scope="instance">
        <description>See dojo.data.api.Read.fetch().</description>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
        <return-description>A request object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <description>See dojo.data.api.Write.save().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <description>See dojo.data.api.Write.newItem().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-description>A new item</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <description>See dojo.data.api.Write.deleteItem().</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="revert" scope="instance">
        <description>See dojo.data.api.Write.revert().</description>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="storeClass" scope="instance" type="A"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataStore.domNode">
    <properties>
      <property name="attributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Invocation" superclass="dojox.wire.ml.Action">
    <description>This widget represents a controller task to invoke a method or
	publish a topic when an event (a function) or a topic is issued.</description>
    <methods>
      <method name="_run" scope="instance">
        <description>If 'topic' is specified, the topic is published with arguments
	specified to 'parameters'.
	If 'method' and 'object' are specified, the method is invoked
	with arguments specified to 'parameters' and set the return
	value to a property specified to 'result'.
	'object', 'parameters' and 'result' can specify properties of
	a widget or an DOM element with the dotted notation.
	If 'parameters' are omitted, the arguments to this method are
	passed as is.</description>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="onComplete" scope="instance">
        <description>If 'result' attribute is specified, the result object also set
	to the specified property.</description>
        <parameters>
          <parameter name="result" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <description>If 'error' attribute is specified, the error object also set to
	the specified property.</description>
        <parameters>
          <parameter name="error" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getParameters" scope="instance">
        <description>This method retunrs an array of arguments specified by
	'parameters' attribute, a comma-separated list of IDs and
	their properties in a dotted notation.
	If 'parameters' are omitted, the original arguments are
	used.</description>
        <parameters>
          <parameter name="args" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.Action" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance" type="A"/>
      <property name="method" scope="instance" type="A"/>
      <property name="topic" scope="instance" type="A"/>
      <property name="parameters" scope="instance" type="Arguments"/>
      <property name="result" scope="instance" type="A"/>
      <property name="error" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Service" superclass="dijit._Widget">
    <description>This widget represents a service defined by a service description
	specified with 'url' attribute.
	If 'serviceType' and 'serviceUrl' attributes are specified, 'url'
	attribute can be omitted.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>See _createHandler().</description>
      </method>
      <method name="_createHandler" scope="instance">
        <return-description>A service handler</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="callMethod" scope="instance">
        <parameters>
          <parameter name="method" type="A" usage="required"/>
          <parameter name="parameters" type="An" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="A"/>
      <property name="serviceUrl" scope="instance" type="A"/>
      <property name="serviceType" scope="instance" type="A"/>
      <property name="handlerClass" scope="instance" type="A"/>
      <property name="preventCache" scope="instance" type="Object"/>
      <property name="handler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Service._handlerClasses">
    <properties>
      <property name="TEXT" scope="instance" type="String"/>
      <property name="XML" scope="instance" type="String"/>
      <property name="JSON" scope="instance" type="String"/>
      <property name="JSON-RPC" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.RestHandler">
    <description>This class serves as a base REST service.
	Sub-classes may override _getContent() and _getResult() to handle
	specific content types.</description>
    <methods>
      <method name="bind" scope="instance">
        <description>A service is called with a URL generated by _getUrl() and
	an HTTP method specified with 'method'.
	For "POST" and "PUT", a content is generated by _getContent().
	When data is loaded, _getResult() is used to pass the result to
	Deferred.callback().</description>
        <parameters>
          <parameter name="method" type="A" usage="required"/>
          <parameter name="parameters" type="An" usage="required"/>
          <parameter name="deferred" type="'Deferred'" usage="required"/>
          <parameter name="url" type="A" usage="required"/>
        </parameters>
      </method>
      <method name="_getUrl" scope="instance">
        <description>If 'method' is "GET" or "DELETE", a query string is generated
	from a query object specified to the first parameter in
	'parameters' and appended to 'url'.
	If 'url' contains variable seguments ("{parameter_name}"),
	they are replaced with corresponding parameter values, instead.</description>
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="parameters" type="Array" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
        <return-description>A URL</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameters' is returned.</description>
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="parameters" type="Array" usage="required"/>
        </parameters>
        <return-description>A request content</return-description>
        <return-types>
          <return-type type="anything"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getResult" scope="instance">
        <description>A response data is returned as is.</description>
        <parameters>
          <parameter name="data" type="anything" usage="required"/>
        </parameters>
        <return-description>A result object</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="contentType" scope="instance" type="String"/>
      <property name="handleAs" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.XmlHandler" superclass="dojox.wire.ml.RestHandler">
    <description>This class provides XML handling for a REST service.</description>
    <methods>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameters' is used to generate an XML content.</description>
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="parameters" type="Array" usage="required"/>
        </parameters>
        <return-description>A request content</return-description>
      </method>
      <method name="_getResult" scope="instance">
        <description>A response data (XML Document) is returned wrapped with
	XmlElement.</description>
        <parameters>
          <parameter name="data" type="Document" usage="required"/>
        </parameters>
        <return-description>A result object</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.RestHandler" scope="instance"/>
    </mixins>
    <properties>
      <property name="contentType" scope="instance" type="String"/>
      <property name="handleAs" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.JsonHandler" superclass="dojox.wire.ml.RestHandler">
    <description>This class provides JSON handling for a REST service.</description>
    <methods>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameter' is used to generate a JSON content.</description>
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="parameters" type="Array" usage="required"/>
        </parameters>
        <return-description>A request content</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.RestHandler" scope="instance"/>
    </mixins>
    <properties>
      <property name="contentType" scope="instance" type="String"/>
      <property name="handleAs" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.JsonHandler.headers">
    <properties>
      <property name="Accept" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Transfer" superclass="dojox.wire.ml.Action">
    <description>This widget represents a controller task to transfer a value from
	a source to a target, through a source and a target Wires, when
	an event (a function) or a topic is issued.
	If this widget has child ChildWire widgets, their _addWire()
	methods are called to add Wire arguments to a source or a target
	Wire.</description>
    <methods>
      <method name="_run" scope="instance">
        <description>First, Wires for a source and a target are created from attributes.
	Then, a value is obtained by getValue() of the source Wire is set
	by setValue() of the target Wire.
	The arguments to this method is passed to getValue() and setValue()
	of Wires, so that they can be used to identify the root objects off
	the arguments.</description>
      </method>
      <method name="_getWire" scope="instance">
        <description>Arguments object for a source or a target Wire, specified by
	'which' argument, are build from corresponding attributes,
	including '*Store' (for 'dataStore'), '*Attribute'
	(for 'attribute), '*Path' (for 'path'), 'type' and 'converter'.
	'source' or 'target' attribute is parsed as:
	"object_id.property_name[.sub_property_name...]"
	If 'source' or 'target' starts with "arguments", 'object'
	argument for a Wire is set to null, so that the root object is
	given as an event or topic arguments.
	If this widget has child ChildWire widgets with a corresponding
	'which' attribute, their _addWire() methods are called to add
	additional Wire arguments and nested Wire is created,
	specifying the Wire defined by this widget to 'object' argument.</description>
        <parameters>
          <parameter name="which" type="String" usage="required"/>
        </parameters>
        <return-description>Wire arguments object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.Action" scope="instance"/>
    </mixins>
    <properties>
      <property name="source" scope="instance" type="A"/>
      <property name="sourceStore" scope="instance" type="A"/>
      <property name="sourceAttribute" scope="instance" type="An"/>
      <property name="sourcePath" scope="instance" type="A"/>
      <property name="type" scope="instance" type="A"/>
      <property name="converter" scope="instance" type="A"/>
      <property name="delimiter" scope="instance" type="String"/>
      <property name="target" scope="instance" type="A"/>
      <property name="targetStore" scope="instance" type="A"/>
      <property name="targetAttribute" scope="instance" type="An"/>
      <property name="targetPath" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.ChildWire" superclass="dijit._Widget">
    <description>Attributes of this widget are used to add a child Wire to
	a composite Wire of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>If 'name' attribute is specified, a child Wire is added as
	the named property of 'children' object of 'args'.
	Otherwise, a child Wire is added to 'children' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getWire" scope="instance">
        <description>Arguments object for a child Wire are build from attributes,
	including 'object', 'property', 'type', 'converter',
	'attribute' and 'path'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required"/>
        </parameters>
        <return-description>Wire arguments object</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="which" scope="instance" type="Which"/>
      <property name="object" scope="instance" type="A"/>
      <property name="property" scope="instance" type="A"/>
      <property name="type" scope="instance" type="A"/>
      <property name="converter" scope="instance" type="A"/>
      <property name="attribute" scope="instance" type="A"/>
      <property name="path" scope="instance" type="A"/>
      <property name="name" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.ColumnWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add a column Wire to
	a TableAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>If 'column' attribute is specified, a column Wire is added as
	the named property of 'columns' object of 'args'.
	Otherwise, a column Wire is added to 'columns' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
    </mixins>
    <properties>
      <property name="column" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.NodeWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add node Wires to
	a TreeAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>Node Wires are added to 'nodes' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getWires" scope="instance">
        <description>Arguments object for 'node' Wire are build from attributes,
	including 'object', 'property', 'type', 'converter',
	'attribute' and 'path'.
	Arguments object for 'title' Wire are build from another set of
	attributes, 'titleProperty', 'titleAttribute' and 'titlePath'.
	If this widget has child NodeWire widgets, their _getWires()
	methods are called recursively to build 'children' array of
	'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required"/>
        </parameters>
        <return-description>Wire arguments object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="titleProperty" scope="instance" type="A"/>
      <property name="titleAttribute" scope="instance" type="A"/>
      <property name="titlePath" scope="instance" type="A"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.SegmentWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add a segment Wire to
	a TextAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>A segment Wire is added to 'segments' array of 'args'.
	If 'parent' has 'delimiter' attribute, it is used for
	'delimiter' property of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.XmlElement">
    <description>This class represents an XML element.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="element" type="Element||String" usage="required"/>
        </parameters>
      </method>
      <method name="getPropertyValue" scope="instance">
        <description>If 'property' starts with '@', the attribute value is returned.
	If 'property' specifies "text()", the value of the first child
	text is returned.
	Otherwise, child elements of the tag name specified with
	'property' are returned.</description>
        <parameters>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
          <return-type type="XmlElement"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="instance">
        <description>If 'property' starts with '@', 'value' is set to the attribute.
	If 'property' specifies "text()", 'value' is set as the first
	child text.
	If 'value' is a string, a child element of the tag name
	specified with 'property' is created and 'value' is set as
	the first child text of the child element.
	Otherwise, 'value' is set to as child elements.</description>
        <parameters>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="String||Array||XmlElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <description>A value of the first text child of the element is returned.</description>
        <return-description>A value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toObject" scope="instance">
        <description>An object with properties for child elements, attributes and
	text is returned.</description>
        <return-description>An object representation of the element</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="instance">
        <description>If 'element' is specified, a DOM document of the element is
	returned.
	Otherwise, a DOM document is created.</description>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.wire.ml.XmlElement.element"/>
  <class type="dojox.wire.ml.XmlElement.element.firstChild">
    <properties>
      <property name="nodeValue" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.XmlElement.element.attributes">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.xml">
    <properties>
      <property name="DomParser" scope="instance" type="Object"/>
      <property name="widgetParser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xml.Script">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xml.parser">
    <methods>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="optional"/>
          <parameter name="mimetype" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="textContent" scope="instance">
        <description>Implementation of the DOM Level 3 attribute; scan node for text
	This function can also update the text of a node by replacing all child
	content of the node.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="text" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="replaceChildren" scope="instance">
        <description>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required"/>
          <parameter name="newChildren" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="removeChildren" scope="instance">
        <parameters>
          <parameter name="node" type="Element" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="innerXML" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp"/>
  <class type="dojox.xmpp.ChatService">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="recieveMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="initial" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSession" scope="instance">
        <parameters>
          <parameter name="session" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invite" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendChatState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onNewMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onInvite" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="state" scope="instance-prototype" type="String"/>
      <property name="session" scope="instance" type="Object"/>
      <property name="uid" scope="instance" type="Object"/>
      <property name="_currentState" scope="instance" type="Object"/>
      <property name="chatid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.chat">
    <properties>
      <property name="CHAT_STATE_NS" scope="instance" type="String"/>
      <property name="ACTIVE_STATE" scope="instance" type="String"/>
      <property name="COMPOSING_STATE" scope="instance" type="String"/>
      <property name="INACTIVE_STATE" scope="instance" type="String"/>
      <property name="PAUSED_STATE" scope="instance" type="String"/>
      <property name="GONE_STATE" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.PresenceService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppService" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <parameters>
          <parameter name="presence" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendAvatarHash" scope="instance">
        <parameters>
          <parameter name="avatarHash" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPresence" scope="instance"/>
      <method name="toggleBlockContact" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleContactInvisiblity" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRestrictedJid" scope="instance"/>
      <method name="_updateRestricted" scope="instance"/>
      <method name="_setVisible" scope="instance"/>
      <method name="_setInvisible" scope="instance"/>
      <method name="_manageSubscriptions" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="approveSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="declineSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="avatarHash" scope="instance-prototype" type="Object"/>
      <property name="isInvisible" scope="instance-prototype" type="bool"/>
      <property name="session" scope="instance" type="Object"/>
      <property name="restrictedContactjids" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.PresenceService.presence">
    <properties>
      <property name="priority" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.xmpp.presence">
    <properties>
      <property name="UPDATE" scope="instance" type="Number"/>
      <property name="SUBSCRIPTION_REQUEST" scope="instance" type="Number"/>
      <property name="SUBSCRIPTION_SUBSTATUS_NONE" scope="instance" type="Number"/>
      <property name="SUBSCRIPTION_NONE" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_FROM" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_TO" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_BOTH" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_REQUEST_PENDING" scope="instance" type="203,"/>
      <property name="STATUS_ONLINE" scope="instance" type="String"/>
      <property name="STATUS_AWAY" scope="instance" type="String"/>
      <property name="STATUS_CHAT" scope="instance" type="String"/>
      <property name="STATUS_DND" scope="instance" type="String"/>
      <property name="STATUS_EXTENDED_AWAY" scope="instance" type="String"/>
      <property name="STATUS_OFFLINE" scope="instance" type="String"/>
      <property name="STATUS_INVISIBLE" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.RosterService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppSession" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="groups" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="groups" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="verifyRoster" scope="instance">
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItemToGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
          <parameter name="newGroup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItemFromGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rosterItemRenameGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="oldGroup" type="Object" usage="required"/>
          <parameter name="newGroup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="newName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAvatar" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="publishAvatar" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="binval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRoster" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRosterFailed" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.RosterService.session">
    <properties>
      <property name="roster" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.roster">
    <properties>
      <property name="ADDED" scope="instance" type="Number"/>
      <property name="CHANGED" scope="instance" type="Number"/>
      <property name="REMOVED" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession">
    <methods>
      <method name="_sendLogin" scope="instance"/>
      <method name="_sendRestart" scope="instance"/>
      <method name="processScriptSrc" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="protocolMsg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="redispatchPacket" scope="instance">
        <parameters>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToOutboundQueue" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeFromOutboundQueue" scope="instance">
        <parameters>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processInboundQueue" scope="instance"/>
      <method name="addToInboundQueue" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isTerminated" scope="instance"/>
      <method name="onTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onProcessProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rid" scope="instance" type="Number"/>
      <property name="hold" scope="instance" type="Number"/>
      <property name="polling" scope="instance" type="Number"/>
      <property name="secure" scope="instance" type="bool"/>
      <property name="wait" scope="instance" type="Number"/>
      <property name="lang" scope="instance" type="String"/>
      <property name="submitContentType" scope="instance" type="String"/>
      <property name="serviceUrl" scope="instance" type="String"/>
      <property name="defaultResource" scope="instance" type="String"/>
      <property name="domain" scope="instance" type="String"/>
      <property name="sendTimeout" scope="instance-prototype" type="Number"/>
      <property name="useScriptSrcTransport" scope="instance" type="bool"/>
      <property name="keepAliveTimer" scope="instance" type="Object"/>
      <property name="state" scope="instance" type="String"/>
      <property name="transmitState" scope="instance" type="String"/>
      <property name="protocolPacketQueue" scope="instance" type="Array"/>
      <property name="outboundQueue" scope="instance" type="Array"/>
      <property name="outboundRequests" scope="instance" type="Object"/>
      <property name="inboundQueue" scope="instance" type="Array"/>
      <property name="deferredRequests" scope="instance" type="Object"/>
      <property name="matchTypeIdAttribute" scope="instance" type="Object"/>
      <property name="transportIframes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.open">
    <methods/>
    <properties>
      <property name="status" scope="instance" type="String"/>
      <property name="rid" scope="instance" type="Object"/>
      <property name="protocolPacketQueue" scope="instance" type="Array"/>
      <property name="outboundQueue" scope="instance" type="Array"/>
      <property name="outboundRequests" scope="instance" type="Object"/>
      <property name="inboundQueue" scope="instance" type="Array"/>
      <property name="deferredRequests" scope="instance" type="Object"/>
      <property name="matchTypeIdAttribute" scope="instance" type="Object"/>
      <property name="keepAliveTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession._keepAlive">
    <methods/>
    <properties>
      <property name="keepAliveTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.dispatchPacket">
    <methods/>
    <properties>
      <property name="dispatchTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession._dispatchPacket">
    <methods/>
    <properties>
      <property name="dispatchTimer" scope="instance" type="Object"/>
      <property name="lastPollTime" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processProtocolPacketQueue">
    <methods/>
    <properties>
      <property name="protocolPacketQueue" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.sendXml">
    <methods/>
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processDocument">
    <methods/>
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processDocument.outboundQueue.0">
    <properties>
      <property name="rid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processResponse">
    <methods/>
    <properties>
      <property name="sid" scope="instance" type="Object"/>
      <property name="authId" scope="instance" type="Object"/>
      <property name="wait" scope="instance" type="Object"/>
      <property name="polling" scope="instance" type="Number"/>
      <property name="inactivity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.setState">
    <methods/>
    <properties>
      <property name="state" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processError">
    <methods/>
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.UserService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppService" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPersonalProfile" scope="instance"/>
      <method name="setPersonalProfile" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfileFailure" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onGetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfileFailure" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.bosh">
    <methods>
      <method name="_iframeOnload" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findOpenIframe" scope="instance"/>
      <method name="handle" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.xmpp.bosh.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_deferredCancel" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_validCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="transportIframes" scope="instance" type="Array"/>
      <property name="_deadScripts" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.xmpp.bosh.__initArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <properties>
      <property name="iframes" scope="instance" type="The"/>
      <property name="load" scope="instance" type="The"/>
    </properties>
  </class>
  <class type="dojox.xmpp.bosh.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="rid" scope="instance" type="The"/>
    </properties>
  </class>
  <class type="dojox.xmpp.bosh.initialize">
    <methods/>
    <properties>
      <property name="transportIframes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl">
    <properties>
      <property name="saslNS" scope="instance" type="String"/>
      <property name="registry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl._Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="session" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startAuth" scope="instance"/>
      <method name="appendToAuth" scope="instance">
        <parameters>
          <parameter name="auth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstChallenge" scope="instance"/>
      <method name="onSecondChallenge" scope="instance"/>
      <method name="onSuccess" scope="instance"/>
    </methods>
    <properties>
      <property name="mechanism" scope="instance" type="Object"/>
      <property name="closeAuthTag" scope="instance" type="Object"/>
      <property name="first_challenge" scope="instance" type="Object"/>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl.SunWebClientAuth" superclass="dojox.xmpp.sasl._Base">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl.Plain" superclass="dojox.xmpp.sasl._Base">
    <methods>
      <method name="appendToAuth" scope="instance">
        <parameters>
          <parameter name="auth" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="instance" type="String"/>
      <property name="closeAuthTag" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl.DigestMD5" superclass="dojox.xmpp.sasl._Base">
    <methods>
      <method name="onFirstChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSecondChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="instance" type="String"/>
      <property name="rspauth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.util">
    <methods>
      <method name="xmlEncode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encodeJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createElement" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
          <parameter name="attributes" type="Object" usage="required"/>
          <parameter name="terminal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stripHtml" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeHtmlEntities" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="htmlToPlain" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.util.Base64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.widget"/>
  <class type="dojox.xmpp.widget.ChatSession" superclass="dijit.layout.LayoutContainer">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goToLastMessage" scope="instance"/>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.LayoutContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="enableSubWidgets" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="widgetType" scope="instance" type="String"/>
      <property name="chatWith" scope="instance" type="Object"/>
      <property name="instance" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.widget.ChatSession.messages.domNode">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.widget.ChatSession.chatInput">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession">
    <methods>
      <method name="processProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="messageHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iqHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saslHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRestart" scope="instance"/>
      <method name="simpleMessageHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerChatInstance" scope="instance">
        <parameters>
          <parameter name="chatInstance" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iqSetHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendIqResult" scope="instance">
        <parameters>
          <parameter name="iqId" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rosterSetHandler" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceUpdate" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="retrieveRoster" scope="instance"/>
      <method name="getRosterIndex" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRosterEntry" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bindResource" scope="instance">
        <parameters>
          <parameter name="hasSession" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNextIqId" scope="instance"/>
      <method name="presenceSubscriptionRequest" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchPacket" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="matchId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="search" scope="instance">
        <parameters>
          <parameter name="searchString" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="searchAttribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSearchResults" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLogin" scope="instance"/>
      <method name="onLoginFailure" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBindSession" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSearchResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRetrieveRoster" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterUpdated" scope="instance"/>
      <method name="onSubscriptionRequest" scope="instance">
        <parameters>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPresenceUpdate" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTransportTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onConnected" scope="instance"/>
      <method name="onTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onActive" scope="instance"/>
      <method name="onRegisterChatInstance" scope="instance">
        <parameters>
          <parameter name="chatInstance" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterAdded" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterRemoved" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterChanged" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
          <parameter name="previousCopy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processXmppError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendStanzaError" scope="instance">
        <parameters>
          <parameter name="stanzaType" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="errorType" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBareJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceFromJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="roster" scope="instance-prototype" type="Array"/>
      <property name="chatRegister" scope="instance-prototype" type="Array"/>
      <property name="_iqId" scope="instance-prototype" type="Object"/>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.open">
    <methods/>
    <properties>
      <property name="jid" scope="instance" type="String"/>
      <property name="password" scope="instance" type="Object"/>
      <property name="resource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.close">
    <methods/>
    <properties>
      <property name="state" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.featuresHandler">
    <methods/>
    <properties>
      <property name="auth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.chatHandler">
    <methods/>
    <properties>
      <property name="useChatState" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.setState">
    <methods/>
    <properties>
      <property name="state" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.onBindResource">
    <methods/>
    <properties>
      <property name="jid" scope="instance" type="Object"/>
      <property name="resource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.onTransportReady">
    <methods/>
    <properties>
      <property name="rosterService" scope="instance" type="Object"/>
      <property name="presenceService" scope="instance" type="Object"/>
      <property name="userService" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmpp">
    <properties>
      <property name="STREAM_NS" scope="instance" type="String"/>
      <property name="CLIENT_NS" scope="instance" type="String"/>
      <property name="STANZA_NS" scope="instance" type="String"/>
      <property name="SASL_NS" scope="instance" type="String"/>
      <property name="BIND_NS" scope="instance" type="String"/>
      <property name="SESSION_NS" scope="instance" type="String"/>
      <property name="BODY_NS" scope="instance" type="String"/>
      <property name="XHTML_BODY_NS" scope="instance" type="String"/>
      <property name="XHTML_IM_NS" scope="instance" type="String"/>
      <property name="INACTIVE" scope="instance" type="String"/>
      <property name="CONNECTED" scope="instance" type="String"/>
      <property name="ACTIVE" scope="instance" type="String"/>
      <property name="TERMINATE" scope="instance" type="String"/>
      <property name="LOGIN_FAILURE" scope="instance" type="String"/>
      <property name="INVALID_ID" scope="instance" type="Number"/>
      <property name="NO_ID" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmpp.error">
    <properties>
      <property name="BAD_REQUEST" scope="instance" type="String"/>
      <property name="CONFLICT" scope="instance" type="String"/>
      <property name="FEATURE_NOT_IMPLEMENTED" scope="instance" type="String"/>
      <property name="FORBIDDEN" scope="instance" type="String"/>
      <property name="GONE" scope="instance" type="String"/>
      <property name="INTERNAL_SERVER_ERROR" scope="instance" type="String"/>
      <property name="ITEM_NOT_FOUND" scope="instance" type="String"/>
      <property name="ID_MALFORMED" scope="instance" type="String"/>
      <property name="NOT_ACCEPTABLE" scope="instance" type="String"/>
      <property name="NOT_ALLOWED" scope="instance" type="String"/>
      <property name="NOT_AUTHORIZED" scope="instance" type="String"/>
      <property name="SERVICE_UNAVAILABLE" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_REQUIRED" scope="instance" type="String"/>
      <property name="UNEXPECTED_REQUEST" scope="instance" type="String"/>
    </properties>
  </class>
</javascript>
